/* NSC -- new Scala compiler
 * Copyright 2005-2013 LAMP/EPFL
 * @author  Martin Odersky
 */

package scala.tools.nsc
package backend.jvm

import java.io.{DataOutputStream, FileOutputStream, IOException, File => JFile}
import java.nio.ByteBuffer
import java.nio.file.{StandardOpenOption, Files => JNFiles, Path => JNPath}
import java.nio.file.attribute.{FileAttribute => JNFileAttribute}
import java.nio.channels.{Channels => JNChannels}
import java.util

import scala.tools.nsc.io._
import java.util.jar.Attributes.Name
import java.util.regex.Pattern

import scala.language.postfixOps
import scala.reflect.internal.util.SourceFile

/** Can't output a file due to the state of the file system. */
class FileConflictException(msg: String, val file: AbstractFile, cause:Throwable) extends IOException(msg, cause)

object OutputDirectories {

  def apply(file:AbstractFile) :OutputDirectories = {
    require (file.isDirectory)
    if (file.file ne null) new PathDirInfo(file.file.toPath)
    else new AbstractFileDirInfo(file)
  }

  private class PathDirInfo (val base:JNPath) extends OutputDirectories {
    //should be strict, when we fix duplicate file names
    val optsStrict = util.EnumSet.of(StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE)
    val optsLax = util.EnumSet.of(StandardOpenOption.CREATE, StandardOpenOption.WRITE)
    val noAttr = Array[JNFileAttribute[_]]()

    class PathFile(path:JNPath) extends OutputFile{
      override def writeFile(bytes: Array[Byte]): Unit = {

        val channel = path.getFileSystem.provider.newByteChannel(path, optsLax, noAttr : _*)

        val bb = ByteBuffer.wrap(bytes)
        try while (bb.remaining() > 0)
          channel.write(bb)
        finally channel.close()

      }
    }
    class PathDir(path:String) extends OutputDirectory{
      lazy val dir = JNFiles.createDirectories(base.resolve(path))
      override def file(name: String): OutputFile = new PathFile(dir.resolve(name))
    }
    private val dirs = new collection.concurrent.TrieMap[String, PathDir]()
    def directory(path:String): OutputDirectory = {
      dirs.getOrElseUpdate(path, new PathDir(path))
    }
    lazy val root:OutputDirectory = new PathDir(".")
    val caseInsensitive = base.resolve("a") == base.resolve("A")
  }
  private class AbstractFileDirInfo (val base:AbstractFile) extends OutputDirectories {
    private class SimpleFile(outfile:AbstractFile) extends OutputFile{
      override def writeFile(bytes: Array[Byte]): Unit = {
        val outstream = outfile.output
        try outstream.write(bytes, 0, bytes.length)
        finally outstream.close()
      }
    }
    private class SimpleDir(file:AbstractFile) extends OutputDirectory {
      override def file(name: String): OutputFile = new SimpleFile(file.fileNamed(name))
    }
    val root:OutputDirectory = new SimpleDir(base)
    def directory(path:String): OutputDirectory = {
      val file = path.split("/").foldLeft(base) {
        case (parentDir, child) => parentDir.subdirectoryNamed(child)
      }
      new SimpleDir(file)
    }
    val caseInsensitive = {
      if (base.file == null) false
      else {
        val path = base.file.toPath
        path.resolve("a") == path.resolve("A")
      }
    }
  }
}
trait OutputDirectories {
  def directory(path:String): OutputDirectory
  def root: OutputDirectory
  val caseInsensitive : Boolean
}
trait OutputDirectory {
  def file(name:String):OutputFile
}
trait OutputFile {
  def writeFile(bytes:Array[Byte])
}


/** For the last mile: turning generated bytecode in memory into
 *  something you can use.  Has implementations for writing to class
 *  files, jars, and disassembled/javap output.
 */
trait BytecodeWriters extends HasReporter{
  val global: Global
  import global.{reporter => _, _}

  def outputDirectory(source: SourceFile): AbstractFile =
    settings.outputDirs outputDirFor source.file


  /**
   * @param clsName cls.getName
   */
  def getFile(known: OutputDirectories, clsName: String, suffix: String): OutputFile = {
    val pathAndName = clsName.replace('.', '/')
    val split = pathAndName.lastIndexOf('/')
    if (split == -1) known.root.file(clsName + suffix)
    else {
      val dirPath = pathAndName.substring(0, split)
      val filename = pathAndName.substring(split + 1) + suffix
      known.directory(dirPath).file(filename)
    }
  }

  def factoryNonJarBytecodeWriter(): BytecodeWriter = {
    val emitAsmp  = settings.Ygenasmp.isSetByUser
    val doDump    = settings.Ydumpclasses.isSetByUser
    (emitAsmp, doDump) match {
      case (false, false) => new ClassBytecodeWriter { }
      case (false, true ) => new ClassBytecodeWriter with DumpBytecodeWriter { }
      case (true,  false) => new ClassBytecodeWriter with AsmpBytecodeWriter
      case (true,  true ) => new ClassBytecodeWriter with AsmpBytecodeWriter with DumpBytecodeWriter { }
    }
  }

  trait BytecodeWriter {
    def writeClass(label: String, jclassName: String, jclassBytes: Array[Byte], path: OutputFile): Unit
    def close(): Unit = ()
    def isSingleThreaded = true
    def needsOutputFile : Boolean

  }

  class DirectToJarfileWriter(jfile: JFile) extends BytecodeWriter {
    val jarMainAttrs = (
      if (settings.mainClass.isDefault) Nil
      else List(Name.MAIN_CLASS -> settings.mainClass.value)
    )
    val writer = new Jar(jfile).jarWriter(jarMainAttrs: _*)

    def writeClass(label: String, jclassName: String, jclassBytes: Array[Byte], outfile: OutputFile) {
      assert(outfile == null,
             "The outfile formal param is there just because ClassBytecodeWriter overrides this method and uses it.")
      val path = jclassName + ".class"
      val out  = writer.newOutputStream(path)

      try out.write(jclassBytes, 0, jclassBytes.length)
      finally out.flush()

      informProgress("added " + label + path + " to jar")
    }
    override def close() = writer.close()
    final override def needsOutputFile: Boolean = false
  }

  /*
   * The ASM textual representation for bytecode overcomes disadvantages of javap output in three areas:
   *    (a) pickle dingbats undecipherable to the naked eye;
   *    (b) two constant pools, while having identical contents, are displayed differently due to physical layout.
   *    (c) stack maps (classfile version 50 and up) are displayed in encoded form by javap,
   *        their expansion by ASM is more readable.
   *
   * */
  trait AsmpBytecodeWriter extends BytecodeWriter {
    import scala.tools.asm

    private val baseDir = Directory(settings.Ygenasmp.value).createDirectory()

    private def emitAsmp(jclassBytes: Array[Byte], asmpFile: io.File) {
      val pw = asmpFile.printWriter()
      try {
        val cnode = new asm.tree.ClassNode()
        val cr    = new asm.ClassReader(jclassBytes)
        cr.accept(cnode, 0)
        val trace = new scala.tools.asm.util.TraceClassVisitor(new java.io.PrintWriter(new java.io.StringWriter()))
        cnode.accept(trace)
        trace.p.print(pw)
      }
      finally pw.close()
    }

    abstract override def writeClass(label: String, jclassName: String, jclassBytes: Array[Byte], path: OutputFile) {
      super.writeClass(label, jclassName, jclassBytes, path)

      val segments = jclassName.split("[./]")
      val asmpFile = segments.foldLeft(baseDir: Path)(_ / _) changeExtension "asmp" toFile;

      asmpFile.parent.createDirectory()
      emitAsmp(jclassBytes, asmpFile)
    }
  }

  trait ClassBytecodeWriter extends BytecodeWriter {
    def writeClass(label: String, jclassName: String, jclassBytes: Array[Byte], path: OutputFile) {
      assert(path != null,
             "Precisely this override requires its invoker to hand out a non-null AbstractFile.")

      path.writeFile(jclassBytes)
      informProgress("wrote '" + label + "' to " + path)
    }

    final override def needsOutputFile: Boolean = true

    override def isSingleThreaded: Boolean = false
  }

  trait DumpBytecodeWriter extends BytecodeWriter {
    val baseDir = Directory(settings.Ydumpclasses.value).createDirectory()

    abstract override def writeClass(label: String, jclassName: String, jclassBytes: Array[Byte], path: OutputFile) {
      super.writeClass(label, jclassName, jclassBytes, path)

      val pathName = jclassName
      val dumpFile = pathName.split("[./]").foldLeft(baseDir: Path) (_ / _) changeExtension "class" toFile;
      dumpFile.parent.createDirectory()
      val outstream = new DataOutputStream(new FileOutputStream(dumpFile.path))

      try outstream.write(jclassBytes, 0, jclassBytes.length)
      finally outstream.close()
    }
  }
}
