{
  val $u: ru.type = ru;
  val $m: $u.Mirror = ru.rootMirror;
  $u.Expr.apply[Int(2)]($m, {
    final class $treecreator1 extends TreeCreator {
      def <init>(): $treecreator1 = {
        $treecreator1.super.<init>();
        ()
      };
      def apply[U <: scala.reflect.base.Universe with Singleton]($m$untyped: scala.reflect.base.MirrorOf[U]): U#Tree = {
        val $u: scala.reflect.api.Universe = $m$untyped.universe.asInstanceOf[scala.reflect.api.Universe];
        val $m: $u.Mirror = $m$untyped.asInstanceOf[$u.Mirror];
        $treecreator1.this.applyImpl[$u.type]($m).asInstanceOf[U#Tree]
      };
      private def applyImpl[U <: scala.reflect.api.Universe with Singleton]($m$untyped: scala.reflect.base.MirrorOf[U]): scala.reflect.base.Universe#Tree = {
        val $u: U = $m$untyped.universe;
        val $m: $u.Mirror = $m$untyped.asInstanceOf[$u.Mirror];
        $u.Literal.apply($u.Constant.apply(2))
      }
    };
    new $treecreator1()
  })($u.TypeTag.apply[Int(2)]($m, {
    final class $typecreator2 extends TypeCreator {
      def <init>(): $typecreator2 = {
        $typecreator2.super.<init>();
        ()
      };
      def apply[U <: scala.reflect.base.Universe with Singleton]($m$untyped: scala.reflect.base.MirrorOf[U]): U#Type = {
        val $u: U = $m$untyped.universe;
        val $m: $u.Mirror = $m$untyped.asInstanceOf[$u.Mirror];
        $u.ConstantType.apply($u.Constant.apply(2))
      }
    };
    new $typecreator2()
  }))
}
ru.reify[Int](2)
