<?xml version="1.0" encoding="UTF-8"?>

<project name="sabbus" default="build"
  xmlns:artifact="urn:maven-artifact-ant"
  xmlns:rsel="antlib:org.apache.tools.ant.types.resources.selectors">
  <include file="test/build-partest.xml" as="partest"/>
  <include file="src/build/maven/maven-deploy.xml" as="maven-deploy"/>

  <description>
SuperSabbus for Scala core, builds the scala library and compiler. It can also package it as a simple distribution, tests it for stable bootstrapping and against the Scala test suite.
  </description>

<!-- HINTS

 - for faster builds, have a build.properties in the same directory as build.xml that says:
      locker.skip=1
      starr.use.released=1

-->

<!-- USAGE FROM JENKINS SCRIPTS IS (CURRENTLY) AS FOLLOWS:
ant $antArgs $scalacArgs $targets

antArgs tend to be:
 -Darchives.skipxz=true
 -Dscalac.args.optimise=-optimise

scalacArgs examples:
  "-Dscalac.args=\"-Yrangepos\" -Dpartest.scalac_opts=\"-Yrangepos\""

targets exercised:
  distpack-maven-opt nightly locker.done build-opt test.suite test.continuations.suite test.scaladoc

NOTE: after distpack-maven-opt, it is expected there's a build file in dists/maven/latest that defines targets deploy and deploy.local
TODO: get rid of this separate step
-->

<!-- To use Zinc with the ant build:
  - install zinc and symlink the installed zinc script to ${basedir}/tools/zinc  (${basedir} is where build.xml and the rest of your checkout resides)
  - make sure to set ZINC_OPTS to match ANT_OPTS!
-->

<!--
TODO:
  - detect zinc anywhere on PATH
  - automatically set ZINC_OPTS
  - skip locker (and test.stability) by default to speed up PR validation, still do full build & testing during nightly
  - (rework the build to pack locker and build using that when using zinc)
-->


<!-- ===========================================================================
                                  END-USER TARGETS
============================================================================ -->
  <target name="build"     depends="pack.done"      description="Builds the Scala compiler and library. Executables are in 'build/pack/bin'."/>
  <target name="test"      depends="test.done"      description="Runs test suite and bootstrapping test on Scala compiler and library."/>
  <target name="docs"      depends="docs.done"      description="Builds documentation for the Scala library. Scaladoc is in 'build/scaladoc/library'."/>
  <target name="docscomp"  depends="docs.comp"      description="Builds documentation for the Scala compiler and library. Scaladoc is in 'build/scaladoc'."/>
  <target name="dist" depends="all.clean, all.done" description="Cleans all and builds and tests a new distribution."/>
  <target name="partialdist" depends="dist.partial" description="Makes a new distribution without documentation, so just for testing."/>
  <target name="fastdist"    depends="dist.done"    description="Makes a new distribution without testing it or removing partially build elements."/>

  <target name="build-opt"       description="Optimized version of build.">       <optimized name="build"/></target>
  <target name="test-opt"        description="Optimized version of test.">        <optimized name="test"/></target>
  <target name="test-core-opt"   description="Optimized version of test.core.">   <optimized name="test.core"/></target>
  <target name="test-stab-opt"   description="Optimized version of test.stability.">   <optimized name="test.stability"/></target>
  <target name="dist-opt"        description="Optimized version of dist.">        <optimized name="dist"/></target>
  <target name="partialdist-opt" description="Optimized version of partialdist."> <optimized name="partialdist"/></target>
  <target name="fastdist-opt"    description="Optimized version of fastdist.">    <optimized name="fastdist"/></target>

  <!-- packaging -->
  <target name="distpack" depends="pack-archives.done, pack-maven.done"/>
  <target name="distpack-maven" depends="pack-maven.done"/>

  <target name="distpack-opt" description="Builds an optimised distribution."> <optimized name="distpack"/></target>
  <target name="distpack-maven-opt" description="Builds an optimised maven distribution."><optimized name="distpack-maven"/></target>

  <!-- The IDE build requires actors/swing/continuations, so need to publish them during PR validation until they are modules -->
  <target name="publish-opt-nodocs" description="Publishes Scala (optimized) without generating docs/testing (library/reflect/compiler/actors/swing/continuations).">
    <antcall target="publish">
      <param name="docs.skip" value="1"/>
      <param name="scalac.args.optimise" value="-optimise"/>
    </antcall>
  </target>

  <target name="publish-core-opt-nodocs" description="Builds an untested, undocumented optimised core (library/reflect/compiler) and publishes to maven.">
    <antcall target="publish-core">
      <param name="docs.skip" value="1"/>
      <param name="scalac.args.optimise" value="-optimise"/>
    </antcall>
  </target>
  <target name="publish-core-local-nodocs" description="Builds an untested, undocumented core (library/reflect/compiler) and locally publishes to maven">
    <antcall target="publish-core-local">
      <param name="docs.skip" value="1"/>
    </antcall>
  </target>

  <target name="all.done" depends="test.done, distpack"/>

  <target name="nightly-nopt" depends="all.done"/>
  <target name="nightly"><optimized name="nightly-nopt"/></target>

  <target name="nightly.checkall">
    <antcall target="nightly-nopt"> <param name="partest.scalac_opts" value="-Ycheck:all"/></antcall></target>

  <target name="clean"       depends="quick.clean"  description="Removes binaries of compiler and library. Locker and distributions are untouched."/>
  <target name="docsclean"   depends="docs.clean"   description="Removes generated documentation. Distributions are untouched."/>
  <target name="distclean"   depends="dist.clean"   description="Removes all distributions. Binaries and documentation are untouched."/>

  <macrodef name="optimized" >
    <attribute name="name"/>
    <sequential>
      <antcall target="@{name}"><param name="scalac.args.optimise" value="-optimise"/></antcall>
    </sequential>
  </macrodef>

<!-- ===========================================================================
                                  PROPERTIES
============================================================================ -->

  <property environment="env"/>
  <!-- Prevents system classpath from being used -->
  <property name="build.sysclasspath"     value="ignore"/>

  <!-- Defines the repository layout -->
  <property name="docs.dir"               value="${basedir}/docs"/>
  <property name="lib.dir"                value="${basedir}/lib"/>
  <property name="src.dir"                value="${basedir}/src"/>
  <property name="partest.dir"            value="${basedir}/test"/>

  <property name="lib-ant.dir"            value="${lib.dir}/ant"/>
  <!-- For developers: any jars placed in this dir will be added to the classpath
       of all targets and copied into quick/pack/etc builds. -->
  <property name="lib-extra.dir"          value="${lib.dir}/extra"/>

  <!-- Loads custom properties definitions -->
  <property file="${basedir}/build.properties"/>

  <!-- Generating version number -->
  <property file="${basedir}/build.number"/>

  <!-- read versions.properties -->
  <property file="${basedir}/versions.properties"/>

  <!-- Sets location of pre-compiled libraries -->
  <property name="library.starr.jar"       value="${lib.dir}/scala-library.jar"/>
  <property name="reflect.starr.jar"       value="${lib.dir}/scala-reflect.jar"/>
  <property name="compiler.starr.jar"      value="${lib.dir}/scala-compiler.jar"/>
  <property name="ant.jar"                 value="${ant.home}/lib/ant.jar"/>

  <!-- Sets location of build folders -->
  <property name="build.dir"               value="${basedir}/build"/>
  <property name="build-deps.dir"          value="${build.dir}/deps"/>
  <property name="build-libs.dir"          value="${build.dir}/libs"/>
  <property name="build-asm.dir"           value="${build.dir}/asm"/>
  <property name="build-forkjoin.dir"      value="${build-libs.dir}"/>
  <property name="build-locker.dir"        value="${build.dir}/locker"/>
  <property name="build-palo.dir"          value="${build.dir}/palo"/>
  <property name="build-quick.dir"         value="${build.dir}/quick"/>
  <property name="build-pack.dir"          value="${build.dir}/pack"/>
  <property name="build-osgi.dir"          value="${build.dir}/osgi"/>
  <property name="build-junit.dir"         value="${build.dir}/junit"/>
  <property name="build-strap.dir"         value="${build.dir}/strap"/>
  <property name="build-docs.dir"          value="${build.dir}/scaladoc"/>
  <property name="build-sbt.dir"           value="${build.dir}/sbt-interface"/>

  <property name="test.osgi.src"           value="${partest.dir}/osgi/src"/>
  <property name="test.osgi.classes"       value="${build-osgi.dir}/classes"/>

  <property name="test.junit.src"          value="${partest.dir}/junit"/>
  <property name="test.junit.classes"      value="${build-junit.dir}/classes"/>

  <property name="dists.dir"               value="${basedir}/dists"/>

  <property name="copyright.string"        value="Copyright 2002-2013, LAMP/EPFL"/>

  <property name="jline.version"           value="2.11"/>

  <!-- These are NOT the flags used to run SuperSabbus, but the ones written
       into the script runners created with scala.tools.ant.ScalaTool -->
  <property name="java.flags"              value="-Xmx256M -Xms32M"/>
  <property name="jvm.opts"                value=""/>

  <!-- if ANT_OPTS is already set by the environment, it will be unaltered,
       but if it is unset it will take this default value. -->
  <property name="env.ANT_OPTS"            value="-Xms1536M -Xmx1536M -Xss1M -XX:MaxPermSize=192M -XX:+UseParallelGC" />

  <property name="scalacfork.jvmargs"      value="${env.ANT_OPTS} ${jvm.opts}"/>

<!-- ===========================================================================
                                  INITIALIZATION
============================================================================ -->
  <target name="desired.jars.uptodate">
    <patternset id="desired.jars">
      <include name="lib/**/*.desired.sha1"/>
      <include name="test/files/**/*.desired.sha1"/>
      <include name="tools/**/*.desired.sha1"/>
    </patternset>

    <uptodate property="lib.jars.uptodate">
      <srcfiles dir="${basedir}"><patternset refid="desired.jars"/></srcfiles>
      <mapper type="glob" from="*.desired.sha1" to="*"/>
    </uptodate>
  </target>

  <target name="boot" depends="desired.jars.uptodate" unless="lib.jars.uptodate">
    <echo level="warn" message="Updating bootstrap libs.  (To do this by hand, run ./pull-binary-libs.sh)"/>
    <exec osfamily="unix" vmlauncher="false" executable="./pull-binary-libs.sh" failifexecutionfails="true" />
    <exec osfamily="windows" vmlauncher="false" executable="pull-binary-libs.sh" failifexecutionfails="true" />
    <!-- uptodate task needs to know these are what's in the sha. -->
    <touch>
      <fileset dir="${basedir}"><patternset refid="desired.jars"/></fileset>
      <mapper type="glob" from="*.desired.sha1" to="*"/>
    </touch>
  </target>

  <macrodef name="copy-deps" description="Copy a file set based on maven dependency resolution to a directory. Currently used by the IntelliJ config files.">
    <attribute name="project" />
    <attribute name="refid" default="@{project}.fileset"/>
    <sequential>
      <delete dir="${build-deps.dir}/@{project}" includes="*.jar"/>
      <copy todir="${build-deps.dir}/@{project}">
        <resources refid="@{refid}" />
        <mapper type="flatten" />
      </copy>
    </sequential>
  </macrodef>

  <target name="init" depends="boot">
    <!-- Set up Ant contrib tasks so we can use <if><then><else> instead of the clunky `unless` attribute -->
    <taskdef resource="net/sf/antcontrib/antlib.xml" classpath="${lib-ant.dir}/ant-contrib.jar"/>

    <property name="scala.ant.min.version" value="1.8.2"/>
    <if><not><antversion atleast="${scala.ant.min.version}"/></not>
      <then><fail message="Ant version ${scala.ant.min.version} is required. You are running ${ant.version}"/></then>
    </if>

    <!-- Add our maven ant tasks -->
    <path id="maven-ant-tasks.classpath" path="${lib-ant.dir}/maven-ant-tasks-2.1.1.jar" />
    <typedef resource="org/apache/maven/artifact/ant/antlib.xml" uri="urn:maven-artifact-ant" classpathref="maven-ant-tasks.classpath" />

    <!-- Resolve maven dependencies -->

    <!-- work around http://jira.codehaus.org/browse/MANTTASKS-203:
         java.lang.ClassCastException: org.codehaus.plexus.DefaultPlexusContainer cannot be cast to org.codehaus.plexus.PlexusContainer
         on repeated use of artifact:dependencies
    -->
    <if><not><isset property="maven-deps-done"></isset></not><then>
      <mkdir dir="${user.home}/.m2/repository"/>
      <!-- This task has an issue where if the user directory does not exist, so we create it above. UGH. -->
      <artifact:dependencies pathId="extra.tasks.classpath" filesetId="extra.tasks.fileset">
        <dependency groupId="biz.aQute" artifactId="bnd" version="1.50.0"/>
      </artifact:dependencies>

      <!-- JUnit -->
      <property name="junit.version" value="4.10"/>
      <artifact:dependencies pathId="junit.classpath" filesetId="junit.fileset">
        <dependency groupId="junit" artifactId="junit" version="${junit.version}"/>
      </artifact:dependencies>
      <copy-deps project="junit"/>

      <!-- Pax runner -->
      <property name="pax.exam.version" value="2.5.0"/>
      <artifact:dependencies pathId="pax.exam.classpath" filesetId="pax.exam.fileset">
        <dependency groupId="org.ops4j.pax.exam" artifactId="pax-exam-container-native" version="${pax.exam.version}"/>
        <dependency groupId="org.ops4j.pax.exam" artifactId="pax-exam-junit4" version="${pax.exam.version}"/>
        <dependency groupId="org.ops4j.pax.exam" artifactId="pax-exam-link-assembly" version="${pax.exam.version}"/>
        <dependency groupId="org.ops4j.pax.url" artifactId="pax-url-aether" version="1.4.0"/>
        <dependency groupId="org.ops4j.pax.swissbox" artifactId="pax-swissbox-framework" version="1.5.1"/>
        <dependency groupId="ch.qos.logback" artifactId="logback-core" version="0.9.20"/>
        <dependency groupId="ch.qos.logback" artifactId="logback-classic" version="0.9.20"/>
        <dependency groupId="junit" artifactId="junit" version="${junit.version}"/>
        <dependency groupId="org.apache.felix" artifactId="org.apache.felix.framework" version="3.2.2"/>
      </artifact:dependencies>


      <artifact:remoteRepository id="extra-repo" url="${extra.repo.url}"/>

      <artifact:dependencies pathId="partest.classpath" filesetId="partest.fileset" versionsId="partest.versions">
        <!-- uncomment the following if you're deploying your own partest locally -->
        <!-- <localRepository path="${user.home}/.m2/repository"/> -->
        <!-- so we don't have to wait for artifacts to synch to maven central
            (we don't distribute partest with Scala, so the risk of sonatype and maven being out of synch is irrelevant):
          -->
        <artifact:remoteRepository refid="extra-repo"/>
        <dependency groupId="org.scala-lang.modules" artifactId="scala-partest_${scala.binary.version}" version="${partest.version.number}" />
      </artifact:dependencies>
      <copy-deps project="partest"/>

      <artifact:dependencies pathId="repl.deps.classpath" filesetId="repl.fileset" versionsId="repl.deps.versions">
        <dependency groupId="jline" artifactId="jline" version="${jline.version}"/>
      </artifact:dependencies>
      <copy-deps project="repl"/>

      <!-- used by the test.osgi target to create osgi bundles for the xml, parser-combinator jars
           must specify sourcesFilesetId, javadocFilesetId to download these types of artifacts -->
      <artifact:dependencies pathId="external-modules.deps.classpath" sourcesFilesetId="external-modules.sources.fileset" javadocFilesetId="external-modules.javadoc.fileset">
        <artifact:remoteRepository refid="extra-repo"/>
        <dependency groupId="org.scala-lang.modules" artifactId="scala-xml_${scala.binary.version}" version="${scala-xml.version.number}"/>
        <dependency groupId="org.scala-lang.modules" artifactId="scala-parser-combinators_${scala.binary.version}" version="${scala-parser-combinators.version.number}"/>
      </artifact:dependencies>

      <!-- External modules, excluding the core -->
      <path id="external-modules-nocore">
        <restrict>
          <path refid="external-modules.deps.classpath"/>
          <rsel:not><rsel:or>
            <rsel:name name="scala-library*.jar"/>
            <rsel:name name="scala-reflect*.jar"/>
            <rsel:name name="scala-compiler*.jar"/>
          </rsel:or></rsel:not>
        </restrict>
      </path>
      <copy-deps refid="external-modules-nocore" project="scaladoc"/>

      <!--
        include partest and its run-time dependencies,
        but filter out the compiler we just built, as that's what we want to test!
        TODO: mark partest's compiler dependencies as provided when publishing to maven,
        so that we don't have to filter them out here...
      -->
      <path id="partest-deps-nocore">
        <restrict>
          <path refid="partest.classpath"/>
          <rsel:not><rsel:or>
            <rsel:name name="scala-library*.jar"/>
            <rsel:name name="scala-reflect*.jar"/>
            <rsel:name name="scala-compiler*.jar"/>
            <!-- TODO: remove actors & scalap, move to external modules -->
            <rsel:name name="scala-actors*.jar"/>
            <rsel:name name="scala-scalap*.jar"/>
          </rsel:or></rsel:not>
        </restrict>
      </path>

      <!-- Set property named @{name} to the jar resolved as @{jar}_${scala.binary.version}:jar.
           @{jar}_${scala.binary.version} must be a maven dependency. -->
      <macrodef name="propertyForCrossedArtifact">
          <attribute name="name" />
          <attribute name="jar" />
          <sequential>
            <readProperty name="@{name}"         property="@{jar}_${scala.binary.version}:jar" />
            <readProperty name="@{name}-sources" property="@{jar}_${scala.binary.version}:java-source:sources" />
            <readProperty name="@{name}-javadoc" property="@{jar}_${scala.binary.version}:java-source:javadoc" />
          </sequential>
      </macrodef>

      <!-- Set property named @{name} to the value of the property named @{property}.
           Helper for performing nested property expansion without using the ant props lib -->
      <macrodef name="readProperty">
        <attribute name="name" />
        <attribute name="property" />
        <sequential>
          <property name="@{name}" value="${@{property}}" />
        </sequential>
      </macrodef>

      <propertyForCrossedArtifact name="scala-parser-combinators" jar="org.scala-lang.modules:scala-parser-combinators"/>
      <propertyForCrossedArtifact name="scala-xml"                jar="org.scala-lang.modules:scala-xml"/>

      <!-- BND support -->
      <typedef resource="aQute/bnd/ant/taskdef.properties" classpathref="extra.tasks.classpath" />

      <!-- Download STARR via maven if `starr.use.released` is set,
           and `starr.version` is specified (see the versions.properties properties file).
           Want to slow down STARR changes, using only released versions. -->
      <if><isset property="starr.use.released"/><then>
        <echo message="Using Scala ${starr.version} for STARR."/>
        <artifact:dependencies pathId="starr.core.path">
          <artifact:remoteRepository refid="extra-repo"/>
          <dependency groupId="org.scala-lang" artifactId="scala-library" version="${starr.version}"/>
          <dependency groupId="org.scala-lang" artifactId="scala-reflect" version="${starr.version}"/>
          <dependency groupId="org.scala-lang" artifactId="scala-compiler" version="${starr.version}"/>
        </artifact:dependencies></then>
      <else>
        <path id="starr.core.path">
          <pathelement location="${library.starr.jar}"/>
          <pathelement location="${reflect.starr.jar}"/>
          <pathelement location="${compiler.starr.jar}"/>
        </path></else>
      </if>

      <property name="maven-deps-done"     value="yep!"/>
    </then></if>


    <!-- NOTE: ant properties are write-once: second writes are silently discarded; the logic below relies on this -->

    <!-- Compute defaults (i.e., if not specified on command-line) for OSGi/maven version suffixes.
      Try to establish the invariant (verified below):
      `version.suffix == maven.version.suffix == osgi.version.suffix`,
      except for:
        - snapshot builds, where:
          - `maven.suffix == "-SNAPSHOT"`
          - `version.suffix == osgi.version.suffix == ""`
        - final builds, where:
          - `osgi.suffix == "-VFINAL"`
          - `version.suffix == maven.version.suffix == ""`
    -->
    <if><not><equals arg1="${version.bnum}" arg2="0"/></not><then>
      <property name="version.suffix"          value="-${version.bnum}"/>
    </then></if>

    <if><or><not><isset property="version.suffix"/></not><equals arg1="${version.suffix}" arg2=""/></or><then>
      <if><isset property="build.release"/><then>
        <property name="maven.version.suffix"  value=""/>
        <property name="version.suffix"        value="${maven.version.suffix}"/>
        <if><equals arg1="${maven.version.suffix}" arg2=""/><then>
          <property name="osgi.version.suffix" value="-VFINAL"/></then>
        <else>
          <property name="osgi.version.suffix" value="${maven.version.suffix}"/></else></if></then></if></then>
    <else> <!-- version.suffix set and not empty -->
      <property name="maven.version.suffix"    value="${version.suffix}"/>
      <property name="osgi.version.suffix"     value="${version.suffix}"/></else></if>

    <!-- if a maven version suffix was set (or inferred), assume we're building a release -->
    <if><isset property="maven.version.suffix"/><then>
      <property name="build.release"  value="1"/></then></if>

    <!-- not building a release and no version.suffix specified -->
    <property name="maven.version.suffix"      value="-SNAPSHOT"/>

    <if><equals arg1="${maven.version.suffix}" arg2="-SNAPSHOT"/><then>
      <property name="osgi.version.suffix"     value=""/>
      <property name="version.suffix"          value=""/></then>
    <else>
      <property name="osgi.version.suffix"     value="${maven.version.suffix}"/>
      <property name="version.suffix"          value="${maven.version.suffix}"/></else></if>


    <exec osfamily="unix" executable="tools/get-scala-commit-sha" outputproperty="git.commit.sha" failifexecutionfails="false" />
    <exec osfamily="windows" executable="cmd.exe" outputproperty="git.commit.sha" failifexecutionfails="false">
      <arg value="/c"/>
      <arg value="tools\get-scala-commit-sha.bat"/>
      <arg value="-p"/>
    </exec>
    <exec osfamily="unix" executable="tools/get-scala-commit-date" outputproperty="git.commit.date" failifexecutionfails="false" />
    <exec osfamily="windows" executable="cmd.exe" outputproperty="git.commit.date" failifexecutionfails="false">
      <arg value="/c"/>
      <arg value="tools\get-scala-commit-date.bat"/>
      <arg value="-p"/>
    </exec>

    <!-- some default in case something went wrong getting the revision -->
    <property name="git.commit.sha"          value="unknown"/>
    <property name="git.commit.date"         value="unknown"/>

    <!-- We use the git describe to determine the OSGi modifier for our build. -->
    <property name="maven.version.number"
      value="${version.major}.${version.minor}.${version.patch}${maven.version.suffix}"/>
    <property name="osgi.version.number"
      value="${version.major}.${version.minor}.${version.patch}.v${git.commit.date}${osgi.version.suffix}-${git.commit.sha}"/>

    <if><isset property="build.release"/><then>
      <property name="version.number"        value="${maven.version.number}"/>
    </then><else>
      <property name="version.number"        value="${version.major}.${version.minor}.${version.patch}${version.suffix}-${git.commit.date}-${git.commit.sha}"/>
    </else></if>

    <condition property="has.java6">
        <equals arg1="${ant.java.version}" arg2="1.6"/>
    </condition>
    <condition property="has.java7">
        <equals arg1="${ant.java.version}" arg2="1.7"/>
    </condition>
    <condition property="has.unsupported.jdk">
       <not><or>
         <isset property="has.java7" />
         <isset property="has.java6" />
       </or></not>
    </condition>

    <fail if="has.unsupported.jdk" message="JDK ${ant.java.version} is not supported by this build!"/>

    <if><isset property="has.java7"/><then>
      <echo level="warning"> You are using JDK7 for this build.
        While this will be able to build most of Scala, it will not build the Swing project.
        You will be unable to create a distribution.
      </echo>
    </then></if>

    <!-- Allow this to be overridden simply -->
    <property name="sbt.latest.version"    value="0.12.4"/>

    <property name="sbt.src.dir"           value="${build-sbt.dir}/${sbt.latest.version}/src"/>
    <property name="sbt.lib.dir"           value="${build-sbt.dir}/${sbt.latest.version}/lib"/>

    <property name="sbt.interface.jar"     value="${sbt.lib.dir}/interface.jar"/>
    <property name="sbt.interface.url"     value="http://private-repo.typesafe.com/typesafe/ivy-releases/org.scala-sbt/interface/${sbt.latest.version}/jars/interface.jar"/>
    <property name="sbt.interface.src.jar" value="${sbt.src.dir}/compiler-interface-src.jar"/>
    <property name="sbt.interface.src.url" value="http://private-repo.typesafe.com/typesafe/ivy-releases/org.scala-sbt/compiler-interface/${sbt.latest.version}/jars/compiler-interface-src.jar"/>


    <!-- Additional command line arguments for scalac. They are added to all build targets -->
    <property name="scalac.args"           value=""/>
    <property name="javac.args"            value=""/>

    <property name="scalac.args.always"    value="-feature" />
    <property name="scalac.args.optimise"  value=""/> <!-- scalac.args.optimise is selectively overridden in certain antcall tasks. -->
    <property name="scalac.args.all"       value="${scalac.args.always} ${scalac.args} ${scalac.args.optimise}"/>
    <property name="scalac.args.locker"    value="${scalac.args.all}"/>
    <property name="scalac.args.quick"     value="${scalac.args.all}"/>
    <property name="scalac.args.strap"     value="${scalac.args.quick}"/>

    <!-- This is the start time for the distribution -->
    <tstamp prefix="time">
      <format property="human" pattern="d MMMM yyyy, HH:mm:ss" locale="en,US"/>
      <format property="short" pattern="yyyyMMddHHmmss"/>
    </tstamp>

    <!-- some default in case something went wrong getting the revision -->
    <property name="version.number"       value="-unknown-"/>
    <property name="init.avail"           value="yes"/>

    <!-- Local libs (developer use.) -->
    <mkdir dir="${lib-extra.dir}"/>

    <!-- Auxiliary libs placed on every classpath. -->
    <path id="aux.libs">
      <pathelement location="${ant.jar}"/>
      <!-- needs ant 1.7.1 -->
      <!-- <fileset dir="${lib-extra.dir}" erroronmissingdir="false"> -->
      <fileset dir="${lib-extra.dir}">
        <include name="**/*.jar"/>
      </fileset>
    </path>

    <!-- And print-out what we are building -->
    <echo message="       build time: ${time.human}" />
    <echo message="     java version: ${java.vm.name} ${java.version} (${ant.java.version})" />
    <echo message="        java args: ${env.ANT_OPTS} ${jvm.opts}" />
    <echo message="       javac args: ${javac.args}" />
    <echo message="      scalac args: ${scalac.args.all}" />
    <echo message="scalac quick args: ${scalac.args.quick}" />
    <echo message="         git date: ${git.commit.date}" />
    <echo message="         git hash: ${git.commit.sha}" />
    <echo message="    maven version: ${maven.version.number}"/>
    <echo message="     OSGi version: ${osgi.version.number}" />
    <echo message="canonical version: ${version.number}" />

    <echoproperties destfile="buildcharacter.properties">
      <propertyset>
        <propertyref regex="time.*" />
        <propertyref regex="git.*" />
        <propertyref name="java.vm.name" />
        <propertyref regex=".*version.*" />
        <propertyref regex="scalac.args.*" />
        <propertyref name="scalacfork.jvmargs" />
      </propertyset>
    </echoproperties>

    <!-- validate version suffixes -->
    <if><equals arg1="${maven.version.suffix}" arg2="-SNAPSHOT"/><then>
      <condition property="version.suffixes.consistent"><and>
        <equals arg1="${osgi.version.suffix}" arg2=""/>
        <equals arg1="${version.suffix}" arg2=""/>
      </and></condition></then>
    <else>
      <if><equals arg1="${osgi.version.suffix}" arg2="-VFINAL"/><then>
        <condition property="version.suffixes.consistent"><and>
          <equals arg1="${maven.version.suffix}" arg2=""/>
          <equals arg1="${version.suffix}" arg2=""/>
        </and></condition></then>
      <else>
        <condition property="version.suffixes.consistent"><and>
          <equals arg1="${osgi.version.suffix}" arg2="${maven.version.suffix}"/>
          <equals arg1="${version.suffix}" arg2="${maven.version.suffix}"/>
        </and></condition></else></if></else></if>

    <!-- <echo message="    maven suffix: ${maven.version.suffix}"/>
    <echo message="     OSGi suffix: ${osgi.version.suffix}" />
    <echo message="canonical suffix: ${version.suffix}" /> -->
    <fail unless="version.suffixes.consistent" message="Version suffixes inconsistent!"/>

    <path id="forkjoin.classpath" path="${build-libs.dir}/classes/forkjoin"/>
    <path id="asm.classpath"      path="${build-asm.dir}/classes"/>
    <property name="forkjoin-classes" refid="forkjoin.classpath"/>
    <property name="asm-classes" refid="asm.classpath"/>

    <!-- the following properties fully define staged-docs, staged-pack, make-bundle, copy-bundle and mvn-package for each of the projects -->
    <property name="library.description"           value="Scala Standard Library"/>
    <property name="library.docroot"               value="rootdoc.txt"/>
    <property name="library.skipPackages"          value="scala.concurrent.impl"/>

    <property name="reflect.description"           value="Scala Reflection Library"/>
    <property name="reflect.skipPackages"          value="scala.reflect.macros.internal:scala.reflect.internal:scala.reflect.io"/>

    <property name="compiler.description"          value="Scala Compiler"/>
    <property name="compiler.name"                 value="scala-compiler"/>
    <property name="compiler.docroot"              value="rootdoc.txt"/>

    <property name="actors.description"            value="Scala Actors Library"/>

    <property name="continuations-plugin.description"     value="Scala Delimited Continuations Compiler Plugin"/>
    <property name="continuations-plugin.package"         value="plugins." />
    <property name="continuations-plugin.dir"             value="plugins/"/>
    <property name="continuations-plugin.name"            value="continuations"/>
    <property name="continuations-plugin.targetdir"       value="misc/scala-devel/plugins"/>
    <property name="continuations-plugin.srcdir"          value="continuations/plugin"/>

    <property name="continuations-library.description" value="Scala Delimited Continuations Library"/>
    <property name="continuations-library.srcdir"       value="continuations/library"/>

    <property name="swing.description"             value="Scala Swing Library"/>

    <property name="parser-combinators.description" value="Scala Parser Combinators Library"/>
    <property name="parser-combinators.package"    value="modules."/>
    <property name="parser-combinators.jar"        value="${scala-parser-combinators}"/>
    <property name="parser-combinators.src"        value="false"/>
    <property name="parser-combinators.srcjar"     value="${scala-parser-combinators-sources}"/>

    <property name="xml.description"               value="Scala XML Library"/>
    <property name="xml.package"                   value="modules."/>
    <property name="xml.jar"                       value="${scala-xml}"/>
    <property name="xml.src"                       value="false"/>
    <property name="xml.srcjar"                    value="${scala-xml-sources}"/>

    <property name="scalap.description"            value="Scala Bytecode Parser"/>
    <property name="scalap.targetjar"              value="scalap.jar"/>

    <property name="partest.description"           value="Scala Compiler Testing Tool"/>
    <property name="partest-extras.description"    value="Scala Compiler Testing Tool (compiler-specific extras)"/>
    <property name="partest-javaagent.description" value="Scala Compiler Testing Tool (compiler-specific java agent)"/>

    <macrodef name="init-project-prop">
      <attribute name="project" />
      <attribute name="name" />
      <attribute name="default" />
      <sequential>
        <local name="@{name}"/>

        <if><not><isset property="@{project}.@{name}"/></not><then>
          <property name="@{project}.@{name}" value="@{default}" />
        </then></if>
      </sequential>
    </macrodef>

    <!-- projects without project-specific options: asm, forkjoin, manual, bin, repl -->
    <for list="actors,compiler,continuations-library,continuations-plugin,library,parser-combinators,partest,partest-extras,partest-javaagent,reflect,scalap,swing,xml" param="project">
      <sequential>
        <!-- description is mandatory -->
        <init-project-prop project="@{project}" name="package"     default=""/>
        <init-project-prop project="@{project}" name="dir"         default=""/>
        <init-project-prop project="@{project}" name="name"        default="scala-@{project}"/>
        <init-project-prop project="@{project}" name="namesuffix"  default=""/>
        <init-project-prop project="@{project}" name="version"     default="${osgi.version.number}"/>
        <init-project-prop project="@{project}" name="targetdir"   default="lib"/>
        <init-project-prop project="@{project}" name="targetjar"   default="${@{project}.name}.jar"/>
        <init-project-prop project="@{project}" name="jar"         default="${build-pack.dir}/${@{project}.targetdir}/${@{project}.targetjar}" />
        <init-project-prop project="@{project}" name="docroot"     default="NOT SET"/>
        <init-project-prop project="@{project}" name="skipPackages" default=""/>
        <init-project-prop project="@{project}" name="srcdir"      default="@{project}"/>
        <init-project-prop project="@{project}" name="src"         default="true"/>
        <init-project-prop project="@{project}" name="srcjar"      default="${build-osgi.dir}/${@{project}.name}-src.jar"/>
      </sequential>
    </for>


    <!-- Compilers to use for the various stages.

      There must be a variable of the shape @{stage}.compiler.path  for all @{stage} in starr, locker, quick, strap.
    -->
    <path id="starr.compiler.path">
      <path refid="starr.core.path"/>
      <pathelement location="${lib.dir}/forkjoin.jar"/>
      <path refid="aux.libs"/>
    </path>

    <!-- To skip locker, use -Dlocker.skip=1 -->
    <if><isset property="locker.skip"/><then>
      <echo message="Using STARR to build the quick stage (skipping locker)."/>
      <path id="locker.compiler.path" refid="starr.compiler.path"/>
       <!-- this is cheating (we don't know the classpath used to build starr)
            but should be close enough: -->
      <path id="locker.compiler.build.path" refid="starr.compiler.path"/>
      <property name="locker.locked" value="locker skipped"/></then>
    <else>
      <path id="locker.compiler.path"><path refid="locker.compiler.build.path"/></path></else></if>

    <!-- compilerpathref for compiling with quick -->
    <path id="quick.compiler.path"> <path refid="quick.compiler.build.path"/></path>


    <!-- What to have on the compilation path when compiling during certain phases.

      There must be a variable of the shape @{stage}.@{project}.build.path
      for all @{stage} in locker, quick, strap
      and all @{project} in library, reflect, compiler
        when stage is quick, @{project} also includes: actors, repl, swing, continuations-plugin, continuations-library, interactive, scaladoc, scalap
    -->

    <!-- LOCKER -->
    <path id="locker.library.build.path">
      <pathelement location="${build-locker.dir}/classes/library"/>
      <path refid="forkjoin.classpath"/>
      <path refid="aux.libs"/>
    </path>

    <path id="locker.reflect.build.path">
      <path refid="locker.library.build.path"/>
      <pathelement location="${build-locker.dir}/classes/reflect"/>
    </path>

    <if><not><isset property="locker.skip"/></not><then>
    <path id="locker.compiler.build.path">
      <path refid="locker.reflect.build.path"/>
      <pathelement location="${build-locker.dir}/classes/compiler"/>
      <path refid="asm.classpath"/>
    </path>
    </then></if>
    <!-- else, locker.compiler.build.path is set above -->

    <!-- QUICK -->
    <path id="quick.library.build.path">
      <pathelement location="${build-quick.dir}/classes/library"/>
      <path refid="forkjoin.classpath"/>
      <path refid="aux.libs"/>
    </path>

    <path id="quick.actors.build.path">
      <path refid="quick.library.build.path"/>
      <pathelement location="${build-quick.dir}/classes/actors"/>
    </path>

    <path id="quick.reflect.build.path">
      <path refid="quick.library.build.path"/>
      <pathelement location="${build-quick.dir}/classes/reflect"/>
    </path>

    <path id="quick.compiler.build.path">
      <path refid="quick.reflect.build.path"/>
      <pathelement location="${build-quick.dir}/classes/compiler"/>
      <path refid="asm.classpath"/>
    </path>

    <path id="quick.repl.build.path">
      <path refid="quick.compiler.build.path"/>
      <pathelement location="${build-quick.dir}/classes/repl"/>
      <path refid="repl.deps.classpath"/>
    </path>

    <path id="quick.swing.build.path">
      <path refid="quick.library.build.path"/>
      <pathelement location="${build-quick.dir}/classes/swing"/>
    </path>

    <path id="quick.continuations-plugin.build.path">
      <!-- plugins are run by locker compiler during quick stage,
      so must compile against the same classes the locker was compiled to
      -->
      <path refid="locker.compiler.build.path"/>
      <pathelement location="${build-quick.dir}/classes/continuations-plugin"/>
    </path>

    <path id="quick.scalap.build.path">
      <path refid="quick.compiler.build.path"/>
      <pathelement location="${build-quick.dir}/classes/scalap"/>
    </path>

    <path id="quick.partest-extras.build.path">
      <path refid="asm.classpath"/>
      <path refid="partest.classpath"/>
      <pathelement location="${build-quick.dir}/classes/repl"/>
      <!-- for the java dependency: Profiler.java -->
      <pathelement location="${build-quick.dir}/classes/partest-extras"/>
    </path>

    <path id="quick.partest-javaagent.build.path">
      <path refid="partest.classpath"/>
      <path refid="asm.classpath"/>
    </path>

    <path id="quick.scaladoc.build.path">
      <path refid="quick.compiler.build.path"/>
      <path refid="partest.classpath"/>
      <path refid="external-modules-nocore"/>
      <pathelement location="${build-quick.dir}/classes/scaladoc"/>
    </path>

    <path id="quick.interactive.build.path">
      <path refid="quick.compiler.build.path"/>
      <pathelement location="${build-quick.dir}/classes/scaladoc"/>
      <pathelement location="${build-quick.dir}/classes/interactive"/>
    </path>

    <path id="quick.bin.tool.path">
      <path refid="quick.repl.build.path"/>
      <path refid="quick.actors.build.path"/>
      <pathelement location="${build-quick.dir}/classes/scalap"/>
      <pathelement location="${build-quick.dir}/classes/continuations-library"/>
      <path refid="external-modules-nocore"/>
    </path>

    <!-- PACK -->
    <path id="pack.compiler.path">
      <pathelement location="${library.jar}"/>
      <pathelement location="${reflect.jar}"/>
      <pathelement location="${compiler.jar}"/>
      <pathelement location="${ant.jar}"/>
      <path refid="forkjoin.classpath"/>
      <path refid="aux.libs"/>
    </path>

    <path id="pack.bin.tool.path">
      <pathelement location="${library.jar}"/>
      <pathelement location="${xml.jar}"/>
      <pathelement location="${parser-combinators.jar}"/>
      <pathelement location="${actors.jar}"/>
      <pathelement location="${reflect.jar}"/>
      <pathelement location="${compiler.jar}"/>
      <pathelement location="${scalap.jar}"/>
      <path refid="repl.deps.classpath"/>
      <path refid="aux.libs"/>
    </path>

    <path id="pack.library.files">
      <fileset dir="${build-quick.dir}/classes/library"/>
      <fileset dir="${build-quick.dir}/classes/continuations-library"/>
      <fileset dir="${forkjoin-classes}"/>
    </path>

    <path id="pack.actors.files">
      <fileset dir="${build-quick.dir}/classes/actors"/>
    </path>

    <path id="pack.compiler.files">
      <fileset dir="${build-quick.dir}/classes/compiler"/>
      <fileset dir="${build-quick.dir}/classes/repl"/>
      <fileset dir="${build-quick.dir}/classes/scaladoc"/>
      <fileset dir="${build-quick.dir}/classes/interactive"/>
      <fileset dir="${asm-classes}"/>
    </path>

    <path id="pack.swing.files">      <fileset dir="${build-quick.dir}/classes/swing"/> </path>
    <path id="pack.reflect.files">    <fileset dir="${build-quick.dir}/classes/reflect"/> </path>
    <path id="pack.continuations-plugin.files">    <fileset dir="${build-quick.dir}/classes/continuations-plugin"/> </path>
    <path id="pack.scalap.files">     <fileset dir="${build-quick.dir}/classes/scalap"/>
                                      <fileset file="${src.dir}/scalap/decoder.properties"/> </path>

    <path id="pack.partest-extras.files"> <fileset dir="${build-quick.dir}/classes/partest-extras"/> </path>
    <path id="pack.partest-javaagent.files"> <fileset dir="${build-quick.dir}/classes/partest-javaagent"/> </path>

    <!-- STRAP -->
    <path id="strap.library.build.path">
      <pathelement location="${build-strap.dir}/classes/library"/>
      <path refid="forkjoin.classpath"/>
      <path refid="aux.libs"/>
    </path>

    <path id="strap.reflect.build.path">
      <path refid="strap.library.build.path"/>
      <pathelement location="${build-strap.dir}/classes/reflect"/>
    </path>

    <path id="strap.compiler.build.path">
      <path refid="strap.reflect.build.path"/>
      <pathelement location="${build-strap.dir}/classes/compiler"/>
      <path refid="asm.classpath"/>
    </path>

    <!-- DOCS -->
    <path id="docs.library.build.path">               <path refid="quick.library.build.path"/>  </path>
    <path id="docs.reflect.build.path">               <path refid="quick.reflect.build.path"/>  </path>
    <path id="docs.compiler.build.path">              <path refid="quick.compiler.build.path"/> </path>
    <path id="docs.scalap.build.path">                <path refid="quick.scalap.build.path"/>   </path>
    <path id="docs.continuations-plugin.build.path">  <path refid="quick.continuations-plugin.build.path"/>  </path>
    <path id="docs.continuations-library.build.path"> <path refid="quick.continuations-plugin.build.path"/>  </path>
    <path id="docs.actors.build.path">                <path refid="quick.actors.build.path"/>   </path>
    <path id="docs.swing.build.path">                 <path refid="quick.swing.build.path"/>    </path>

    <!-- run-time classpath for scaladoc: should be resolved through maven once it's an actual module -->
    <path id="scaladoc.classpath">
      <path refid="external-modules-nocore"/>
      <pathelement location="${library.jar}"/>
      <pathelement location="${reflect.jar}"/>
      <pathelement location="${compiler.jar}"/>
      <pathelement location="${ant.jar}"/>
      <path refid="aux.libs"/>
    </path>

    <path id="manual.build.path">
      <path refid="external-modules-nocore"/> <!-- xml -->
      <pathelement location="${library.jar}"/>
      <pathelement location="${build.dir}/manmaker/classes"/>
      <path refid="aux.libs"/>  <!-- for ant -->
    </path>

    <!-- MISC -->
    <path id="sbt.compile.build.path">
      <path refid="quick.compiler.build.path"/>
      <pathelement location="${build-quick.dir}/classes/repl"/>
      <pathelement location="${build-quick.dir}/classes/scaladoc"/>
      <pathelement location="${build-quick.dir}/classes/interactive"/>
      <pathelement location="${sbt.interface.jar}"/>
    </path>


    <!--
       This is the classpath used to run partest, which is what it uses to run the compiler and find other required jars.
       "What's on the compiler's compilation path when compiling partest tests," you ask?
        Why, the compiler we're testing, of course, and partest with all its dependencies.
    -->
    <path id="partest.compilation.path">
      <pathelement location="${library.jar}"/>
      <pathelement location="${reflect.jar}"/>
      <pathelement location="${compiler.jar}"/>

      <!-- to test a quick build without packing, replace the above pathelements with:        (may need a little tweaking)
      <path refid="quick.bin.tool.path">
      <path refid="quick.interactive.build.path">
      -->

      <!-- TODO: move scalap & actors out of repo -->
      <pathelement location="${scalap.jar}"/>
      <pathelement location="${actors.jar}"/>

      <!-- partest dependencies, without the jars we built locally
           TODO: figure out why scalap tests fail if we move this up-->
      <path refid="partest-deps-nocore"/>

      <!-- partest classes specific to the core compiler build -->
      <pathelement location="${partest-extras.jar}"/>
      <pathelement location="${partest-javaagent.jar}"/>

      <!-- sneaky extras used in tests -->
      <fileset dir="${partest.dir}/files/lib" includes="*.jar" />
    </path>

    <path id="test.junit.compiler.build.path">
      <pathelement location="${test.junit.classes}"/>
      <path refid="quick.compiler.build.path"/>
      <path refid="junit.classpath"/>
    </path>

    <path id="test.osgi.compiler.build.path">
      <pathelement location="${test.osgi.classes}"/>
      <pathelement location="${build-osgi.dir}/org.scala-lang.scala-library.jar"/>
      <pathelement location="${build-osgi.dir}/org.scala-lang.scala-reflect.jar"/>
      <pathelement location="${build-osgi.dir}/org.scala-lang.scala-compiler.jar"/>
      <pathelement location="${build-osgi.dir}/org.scala-lang.scala-actors.jar"/>
      <path refid="pax.exam.classpath"/>
      <path refid="forkjoin.classpath"/>
    </path>

    <path id="palo.bin.tool.path">
      <pathelement location="${build-palo.dir}/lib/scala-library.jar"/>
      <pathelement location="${build-palo.dir}/lib/scala-reflect.jar"/>
      <pathelement location="${build-palo.dir}/lib/scala-compiler.jar"/>
      <path refid="repl.deps.classpath"/>
    </path>

    <path id="test.positions.sub.build.path" path="${build-quick.dir}/classes/library"/>

    <!-- TODO: consolidate *.includes -->
    <patternset id="lib.includes">
      <include name="**/*.tmpl"/>
      <include name="**/*.xml"/>
      <include name="**/*.js"/>
      <include name="**/*.css"/>
    </patternset>

    <patternset id="lib.rootdoc.includes">
      <include name="**/*.tmpl"/>
      <include name="**/*.xml"/>
      <include name="**/*.js"/>
      <include name="**/*.css"/>
      <include name="rootdoc.txt"/>
    </patternset>

    <patternset id="comp.includes">
      <include name="**/*.tmpl"/>
      <include name="**/*.xml"/>
      <include name="**/*.js"/>
      <include name="**/*.css"/>
      <include name="**/*.html"/>
      <include name="**/*.properties"/>
      <include name="**/*.swf"/>
      <include name="**/*.png"/>
      <include name="**/*.gif"/>
      <include name="**/*.txt"/>
    </patternset>

    <taskdef resource="scala/tools/ant/sabbus/antlib.xml" classpathref="starr.compiler.path"/>
  </target>

<!-- ===========================================================================
                                  CLEANLINESS
=============================================================================-->
  <target name="libs.clean">                        <clean build="libs"/> <clean build="asm"/>                            </target>
  <target name="quick.clean"  depends="libs.clean">   <clean build="quick"/> <clean build="pack"/> <clean build="strap"/> </target>
  <target name="palo.clean"   depends="quick.clean">    <clean build="palo"/>                                             </target>
  <target name="locker.clean" depends="palo.clean">       <clean build="locker"/>                                         </target>

  <target name="docs.clean"> <clean build="docs"/> <delete dir="${build.dir}/manmaker" includeemptydirs="yes" quiet="yes" failonerror="no"/> </target>
  <target name="dist.clean"> <delete dir="${dists.dir}" includeemptydirs="yes" quiet="yes" failonerror="no"/> </target>

  <target name="junit.clean"> <clean build="junit"/> </target>

  <target name="all.clean" depends="locker.clean, docs.clean, junit.clean">
    <clean build="sbt"/> <clean build="osgi"/>
  </target>

  <!-- Used by the scala-installer script -->
  <target name="allallclean" depends="all.clean, dist.clean"/>

  <macrodef name="clean">
    <attribute name="build"/>
    <sequential>
      <delete dir="${build-@{build}.dir}" includeemptydirs="yes" quiet="yes" failonerror="no"/>
    </sequential>
  </macrodef>
<!-- ===========================================================================
                                  LOCAL DEPENDENCIES
============================================================================ -->
  <macrodef name="simple-javac" >
    <attribute name="project"/>  <!-- project: asm/forkjoin -->
    <attribute name="args" default=""/>
    <attribute name="jar"  default="yes"/>
    <sequential>
      <uptodate property="@{project}.available" targetfile="${build-libs.dir}/@{project}.complete">
        <srcfiles dir="${src.dir}/@{project}"/></uptodate>
      <if><not><isset property="@{project}.available"/></not><then>
        <stopwatch name="@{project}.timer"/>
        <mkdir dir="${@{project}-classes}"/>
        <javac
          debug="true"
          srcdir="${src.dir}/@{project}"
          destdir="${@{project}-classes}"
          classpath="${@{project}-classes}"
          includes="**/*.java"
          target="1.6" source="1.5"
          compiler="javac1.6">
            <compilerarg line="${javac.args} @{args}"/>
        </javac>
        <if><equals arg1="@{jar}" arg2="yes"/><then>
          <jar whenmanifestonly="fail" destfile="${build-libs.dir}/@{project}.jar" basedir="${@{project}-classes}"/></then></if>
        <stopwatch name="@{project}.timer" action="total"/>
        <mkdir dir="${build-libs.dir}"/>
        <touch file="${build-libs.dir}/@{project}.complete" verbose="no"/>
      </then></if>
    </sequential>
  </macrodef>

  <target name="asm.done"      depends="init"> <simple-javac project="asm" jar="no"/> </target>
  <target name="forkjoin.done" depends="init"> <simple-javac project="forkjoin" args="-XDignore.symbol.file"/></target>

<!-- ===========================================================================
                                  STAGED COMPILATION MACROS
============================================================================ -->
  <macrodef name="staged-javac" >
    <attribute name="stage"/>    <!-- current stage (locker, quick, strap) -->
    <attribute name="project"/>  <!-- project: library/reflect/compiler/actors -->
    <attribute name="destproject" default="@{project}"/> <!-- overrides the output directory; used when building multiple projects into the same directory-->
    <attribute name="args" default=""/>
    <attribute name="excludes" default=""/>

    <sequential>
      <javac
        debug="true"
        srcdir="${src.dir}/@{project}"
        destdir="${build-@{stage}.dir}/classes/@{destproject}"
        includes="**/*.java"
        excludes="@{excludes}"
        target="1.6" source="1.5">
          <compilerarg line="${javac.args} @{args}"/>
          <classpath refid="@{stage}.@{destproject}.build.path"/>
      </javac>
    </sequential>
  </macrodef>

  <!-- Zinc assumes a one-to-one correspondence of output folder to set of source files.
   When compiling different sets of source files in multiple compilations to the same output directory,
   Zinc thinks source files that appeared in an earlier compilation but are absent in the current one,
   were deleted and thus deletes the corresponding output files.

   Note that zinc also requires each arg to scalac to be prefixed by -S.
  -->
  <macrodef name="zinc">
    <attribute name="compilerpathref"   />
    <attribute name="destdir"           />
    <attribute name="srcdir"            />
    <attribute name="srcpath" default="NOT SET"/>        <!-- needed to compile the library, "NOT SET" is just a convention to denote an optional attribute -->
    <attribute name="buildpathref"      />
    <attribute name="params" default="" />
    <attribute name="java-excludes" default=""/>

    <sequential>
      <local name="sources"/>
      <pathconvert pathsep=" " property="sources">
        <fileset dir="@{srcdir}">
          <include name="**/*.java"/>
          <include name="**/*.scala"/>
          <exclude name="@{java-excludes}"/>
        </fileset>
      </pathconvert>
      <local name="args"/>
      <local name="sargs"/>
      <if><not><equals arg1="@{srcpath}" arg2="NOT SET"/></not><then>
        <property name="args" value="@{params} -sourcepath @{srcpath}"/>
      </then></if>
      <property name="args" value="@{params}"/> <!-- default -->

      <!-- HACK: prefix scalac args by -S -->
      <script language="javascript">
        project.setProperty("sargs", project.getProperty("args").trim().replaceAll(" ", " -S"));
      </script>

      <exec osfamily="unix" executable="tools/zinc" failifexecutionfails="true" failonerror="true">
        <arg line="-nailed -compile-order JavaThenScala -scala-path ${ant.refid:@{compilerpathref}} -d @{destdir} -classpath ${toString:@{buildpathref}} ${sargs} ${sources}"/>
      </exec>
    </sequential>
  </macrodef>

  <macrodef name="staged-scalac" >
    <attribute name="with"/>           <!-- will use path `@{with}.compiler.path` to locate scalac -->
    <attribute name="stage"/>          <!-- current stage (locker, quick, strap) -->
    <attribute name="project"/>        <!-- project: library/reflect/compiler/actors -->
    <attribute name="srcpath" default="NOT SET"/>        <!-- needed to compile the library -->
    <attribute name="args" default=""/>                  <!-- additional args -->
    <attribute name="destproject" default="@{project}"/> <!-- overrides the output directory; used when building multiple projects into the same directory-->
    <attribute name="srcdir" default="@{project}"/>
    <attribute name="java-excludes" default=""/>

    <sequential>
      <!-- TODO: detect zinc anywhere on PATH
           use zinc for the quick stage if it's available;
           would use it for locker but something is iffy in sbt: get a class cast error on global phase -->
      <if><and> <available file="tools/zinc"/>
                <equals arg1="@{stage}" arg2="quick"/>
                <not><equals arg1="@{project}" arg2="continuations-plugins"/></not> <!-- doesn't work in zinc because it requires the quick compiler, which isn't jarred up-->
          </and><then>
        <zinc taskname="Z.@{stage}.@{project}"
          compilerpathref="@{with}.compiler.path"
          destdir="${build-@{stage}.dir}/classes/@{destproject}"
          srcdir="${src.dir}/@{srcdir}"
          srcpath="@{srcpath}"
          buildpathref="@{stage}.@{project}.build.path"
          params="${scalac.args.@{stage}} @{args}"
          java-excludes="@{java-excludes}"/></then>
      <else>
      <if><equals arg1="@{srcpath}" arg2="NOT SET"/><then>
        <scalacfork taskname="@{stage}.@{project}"
          jvmargs="${scalacfork.jvmargs}"
          compilerpathref="@{with}.compiler.path"
          destdir="${build-@{stage}.dir}/classes/@{destproject}"
          srcdir="${src.dir}/@{srcdir}"
          params="${scalac.args.@{stage}} @{args}">
          <include name="**/*.scala"/>
          <compilationpath refid="@{stage}.@{project}.build.path"/></scalacfork></then>
      <else>
        <scalacfork taskname="@{stage}.@{project}"
          jvmargs="${scalacfork.jvmargs}"
          compilerpathref="@{with}.compiler.path"
          destdir="${build-@{stage}.dir}/classes/@{destproject}"
          srcdir="${src.dir}/@{srcdir}"
          srcpath="@{srcpath}"
          params="${scalac.args.@{stage}} @{args}">
          <include name="**/*.scala"/>
          <compilationpath refid="@{stage}.@{project}.build.path"/></scalacfork></else>
      </if>
      </else></if>
    </sequential>
  </macrodef>

  <macrodef name="staged-uptodate" >
    <attribute name="stage"/>
    <attribute name="project"/>
    <element name="check"/>
    <element name="do"/>

    <sequential>
      <uptodate property="@{stage}.@{project}.available" targetfile="${build-@{stage}.dir}/@{project}.complete">
        <check/>
      </uptodate>
      <if><not><isset property="@{stage}.@{project}.available"/></not><then>
        <do/>
        <touch file="${build-@{stage}.dir}/@{project}.complete" verbose="no"/>
      </then></if>
    </sequential>
  </macrodef>

  <macrodef name="staged-build" >
    <attribute name="with"/>           <!-- will use path `@{with}.compiler.path` to locate scalac -->
    <attribute name="stage"/>          <!-- current stage (locker, quick, strap) -->
    <attribute name="project"/>        <!-- project: library/reflect/compiler/actors -->
    <attribute name="srcpath"       default="NOT SET"/>        <!-- needed to compile the library -->
    <attribute name="args"          default=""/>                  <!-- additional args -->
    <attribute name="includes"      default="comp.includes"/>
    <attribute name="java-excludes" default=""/>
    <attribute name="version"       default=""/> <!-- non-empty for scaladoc: use @{version}.version.number in property file-->

    <sequential>
      <staged-uptodate stage="@{stage}" project="@{project}">
        <check><srcfiles dir="${src.dir}/@{project}"/></check>
        <do>
          <stopwatch name="@{stage}.@{project}.timer"/>
          <mkdir dir="${build-@{stage}.dir}/classes/@{project}"/>
          <staged-javac stage="@{stage}" project="@{project}" excludes="@{java-excludes}"/> <!-- always compile with javac for simplicity and regularity; it's cheap -->
          <staged-scalac with="@{with}" stage="@{stage}" project="@{project}" srcpath="@{srcpath}" args="@{args}" java-excludes="@{java-excludes}"/>
          <if><equals arg1="@{version}" arg2=""/><then>
            <propertyfile file = "${build-@{stage}.dir}/classes/@{project}/@{project}.properties">
              <entry key       = "version.number" value="${version.number}"/>
              <entry key       = "maven.version.number" value="${maven.version.number}"/>
              <entry key       = "osgi.version.number" value="${osgi.version.number}"/>
              <entry key       = "copyright.string" value="${copyright.string}"/>
            </propertyfile>
          </then><else>
            <propertyfile file = "${build-@{stage}.dir}/classes/@{project}/@{project}.properties">
              <entry key       = "version.number" value="${@{version}.version.number}"/>
              <entry key       = "copyright.string" value="${copyright.string}"/>
            </propertyfile>
          </else></if>
          <copy todir="${build-@{stage}.dir}/classes/@{project}">
            <fileset dir="${src.dir}/@{project}">
              <patternset refid="@{includes}"/>
            </fileset>
          </copy>
          <stopwatch name="@{stage}.@{project}.timer" action="total"/>
        </do>
      </staged-uptodate>
    </sequential>
  </macrodef>

  <macrodef name="staged-bin">
    <attribute name="stage"/>
    <attribute name="classpathref" default="NOT SET"/>
    <sequential>
      <staged-uptodate stage="@{stage}" project="bin">
        <check>
          <srcfiles dir="${src.dir}">
            <include name="compiler/scala/tools/ant/templates/**"/>
          </srcfiles>
        </check>
        <do>
          <taskdef name="mk-bin" classname="scala.tools.ant.ScalaTool" classpathref="@{stage}.bin.tool.path"/>
          <mkdir dir="${build-@{stage}.dir}/bin"/>
          <if><equals arg1="@{classpathref}" arg2="NOT SET"/><then>
            <mk-bin file="${build-@{stage}.dir}/bin/scala"    class="scala.tools.nsc.MainGenericRunner" javaFlags="${java.flags}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/scalac"   class="scala.tools.nsc.Main"              javaFlags="${java.flags}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/scaladoc" class="scala.tools.nsc.ScalaDoc"          javaFlags="${java.flags}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/fsc"      class="scala.tools.nsc.CompileClient"     javaFlags="${java.flags}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/scalap"   class="scala.tools.scalap.Main"           javaFlags="${java.flags}"/>
          </then><else>
            <mk-bin file="${build-@{stage}.dir}/bin/scala"    class="scala.tools.nsc.MainGenericRunner" javaFlags="${java.flags}" classpathref="@{classpathref}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/scalac"   class="scala.tools.nsc.Main"              javaFlags="${java.flags}" classpathref="@{classpathref}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/scaladoc" class="scala.tools.nsc.ScalaDoc"          javaFlags="${java.flags}" classpathref="@{classpathref}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/fsc"      class="scala.tools.nsc.CompileClient"     javaFlags="${java.flags}" classpathref="@{classpathref}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/scalap"   class="scala.tools.scalap.Main"           javaFlags="${java.flags}" classpathref="@{classpathref}"/>
          </else></if>
          <chmod perm="ugo+rx" file="${build-@{stage}.dir}/bin/scala"/>
          <chmod perm="ugo+rx" file="${build-@{stage}.dir}/bin/scalac"/>
          <chmod perm="ugo+rx" file="${build-@{stage}.dir}/bin/scaladoc"/>
          <chmod perm="ugo+rx" file="${build-@{stage}.dir}/bin/fsc"/>
          <chmod perm="ugo+rx" file="${build-@{stage}.dir}/bin/scalap"/>
        </do>
      </staged-uptodate>
    </sequential>
  </macrodef>

  <macrodef name="staged-pack">
    <attribute name="project"/>
    <attribute name="manifest"  default=""/>
    <element name="pre"         optional="true"/>
    <element name="jar-opts"    optional="true"/>

    <sequential>
      <local name="destfile"/> <property name="destfile"  value="${build-pack.dir}/${@{project}.targetdir}/${@{project}.targetjar}"/>

      <uptodate property="pack.@{project}.available" targetfile="${destfile}">
        <srcresources>
          <resources refid="pack.@{project}.files"/>
          <!-- <path><pathelement location="${build-quick.dir}/@{project}.complete"/></path> -->
        </srcresources>
      </uptodate>
      <if><not><isset property="pack.@{project}.available"/></not><then>
        <mkdir dir="${build-pack.dir}/${@{project}.targetdir}"/>
        <pre/>

        <if><not><equals arg1="@{manifest}" arg2=""/></not><then>
          <jar whenmanifestonly="fail" destfile="${destfile}" manifest="@{manifest}"> <!-- update="true" makes no difference on my machine, so starting from scratch-->
            <jar-opts/>
            <path refid="pack.@{project}.files"/>
          </jar></then>
        <else>
          <jar whenmanifestonly="fail" destfile="${destfile}">
            <jar-opts/>
            <path refid="pack.@{project}.files"/>
          </jar>
        </else></if>
      </then></if>
    </sequential>
  </macrodef>

  <macrodef name="staged-docs">
    <attribute name="project"/>

    <element name="includes" implicit="true"/>

    <sequential>
      <staged-uptodate stage="docs" project="@{project}">
        <check><srcfiles dir="${src.dir}/${@{project}.srcdir}"/></check>
        <do>
          <stopwatch name="docs.@{project}.timer"/>
          <mkdir dir="${build-docs.dir}/@{project}"/>
          <if><equals arg1="${@{project}.docroot}" arg2="NOT SET"/><then>
            <scaladoc
              destdir="${build-docs.dir}/@{project}"
              doctitle="${@{project}.description}"
              docfooter="epfl"
              docversion="${version.number}"
              sourcepath="${src.dir}"
              classpathref="docs.@{project}.build.path"
              srcdir="${src.dir}/${@{project}.srcdir}"
              addparams="${scalac.args.all}"
              implicits="on"
              diagrams="on"
              groups="on"
              rawOutput="${scaladoc.raw.output}"
              noPrefixes="${scaladoc.no.prefixes}"
              docUncompilable="${src.dir}/library-aux"
              skipPackages="${@{project}.skipPackages}">
              <includes/>
            </scaladoc>
          </then><else>
            <scaladoc
              destdir="${build-docs.dir}/@{project}"
              doctitle="${@{project}.description}"
              docfooter="epfl"
              docversion="${version.number}"
              sourcepath="${src.dir}"
              classpathref="docs.@{project}.build.path"
              srcdir="${src.dir}/${@{project}.srcdir}"
              docRootContent="${src.dir}/@{project}/${@{project}.docroot}"
              addparams="${scalac.args.all}"
              implicits="on"
              diagrams="on"
              groups="on"
              rawOutput="${scaladoc.raw.output}"
              noPrefixes="${scaladoc.no.prefixes}"
              docUncompilable="${src.dir}/library-aux"
              skipPackages="${@{project}.skipPackages}">
              <includes/>
            </scaladoc>
          </else></if>
          <stopwatch name="docs.@{project}.timer" action="total"/>
        </do>
      </staged-uptodate>
    </sequential>
  </macrodef>

<!-- ===========================================================================
                                  LOCAL REFERENCE BUILD (LOCKER)
============================================================================ -->
  <target name="locker.start"  depends="asm.done, forkjoin.done">
    <condition property="locker.locked"><available file="${build-locker.dir}/locker.locked"/></condition></target>

  <target name="locker.lib"    depends="locker.start"     unless="locker.locked">
    <staged-build with="starr" stage="locker" project="library" srcpath="${src.dir}/library" includes="lib.includes"/></target>

  <target name="locker.reflect" depends="locker.lib"      unless="locker.locked">
    <staged-build with="starr" stage="locker" project="reflect"/></target>

  <target name="locker.comp"    depends="locker.reflect" unless="locker.locked">
    <staged-build with="starr" stage="locker" project="compiler"/></target>

  <target name="locker.done"    depends="locker.comp">
    <mkdir dir="${build-locker.dir}"/>
    <touch file="${build-locker.dir}/locker.locked" verbose="no"/>
  </target>
  <target name="locker.unlock"> <delete file="${build-locker.dir}/locker.locked"/>
                                <delete file="${build-locker.dir}/*.complete"/></target>

<!-- ===========================================================================
                                  QUICK BUILD (QUICK)
============================================================================ -->
  <target name="quick.start"      depends="locker.done"/>

  <target name="quick.lib"        depends="quick.start">
    <staged-build with="locker"   stage="quick" project="library" srcpath="${src.dir}/library" includes="lib.rootdoc.includes"/></target>

  <target name="quick.reflect"    depends="quick.lib">
    <staged-build with="locker"   stage="quick" project="reflect"/> </target>

  <target name="quick.comp"       depends="quick.reflect">
    <staged-build with="locker"   stage="quick" project="compiler"/> </target>

  <target name="quick.repl"       depends="quick.comp">
    <staged-build with="locker"   stage="quick" project="repl"/> </target>

  <target name="quick.scaladoc"   depends="quick.comp">
    <staged-build with="locker"   stage="quick" project="scaladoc" version="scaladoc"/> </target>

  <target name="quick.interactive" depends="quick.comp, quick.scaladoc">
    <staged-build with="locker"    stage="quick" project="interactive"/> </target>

  <target name="quick.scalap"     depends="quick.repl">
    <staged-build with="locker"   stage="quick" project="scalap"/> </target>

  <target name="quick.actors"     depends="quick.lib">
    <staged-build with="locker"   stage="quick" project="actors"/> </target>

  <target name="quick.swing"      depends="quick.actors, quick.lib" if="has.java6">
    <staged-build with="locker"   stage="quick" project="swing"/> </target>

  <target name="quick.partest-extras"
                                  depends="quick.comp">
    <!-- compile compiler-specific parts of partest -->
    <staged-build with="starr" stage="quick" project="partest-extras" />
    <staged-build with="starr" stage="quick" project="partest-javaagent" />
  </target>


  <target name="quick.plugins"    depends="quick.comp">
    <staged-uptodate              stage="quick" project="continuations-plugin">
      <check><srcfiles dir="${src.dir}/continuations"/></check>
      <do>
        <stopwatch name="quick.continuations-plugin.timer"/>

        <mkdir dir="${build-quick.dir}/classes/continuations-plugin"/>
        <staged-scalac with="locker" stage="quick" project="continuations-plugin" srcdir="${continuations-plugin.srcdir}"/>
        <copy
           file="${src.dir}/${continuations-plugin.srcdir}/scalac-plugin.xml"
           todir="${build-quick.dir}/classes/continuations-plugin"/>

        <!-- not very nice to create jar here but needed to load plugin -->
        <mkdir dir="${build-quick.dir}/${continuations-plugin.targetdir}"/>
        <jar whenmanifestonly="fail" destfile="${build-quick.dir}/${continuations-plugin.targetdir}/continuations.jar" basedir="${build-quick.dir}/classes/continuations-plugin"/>

        <!-- might split off library part into its own ant target -->
        <mkdir dir="${build-quick.dir}/classes/continuations-library"/>
        <staged-scalac with="locker" stage="quick" project="continuations-plugin"
                       srcdir="continuations/library" destproject="continuations-library"
                       args="-Xplugin-require:continuations -P:continuations:enable -Xpluginsdir ${build-quick.dir}/${continuations-plugin.targetdir}"/>

        <stopwatch name="quick.continuations-plugin.timer" action="total"/>
      </do>
    </staged-uptodate>
  </target>

  <target name="quick.modules" depends="quick.repl, quick.scaladoc, quick.interactive, quick.scalap, quick.swing, quick.plugins"/>

  <target name="quick.bin" depends="quick.lib, quick.reflect, quick.comp, quick.modules">
    <staged-bin stage="quick" classpathref="quick.bin.tool.path"/>
  </target>

  <target name="quick.done" depends="quick.bin"/>
  <target name="quick-opt" description="Optimized version of quick.done."> <optimized name="quick.done"/></target>


<!-- ===========================================================================
                                  PACKED QUICK BUILD (PACK)
============================================================================ -->
  <target name="pack.lib"    depends="quick.lib, quick.plugins, forkjoin.done"> <staged-pack project="library"/></target>

  <target name="pack.reflect" depends="quick.reflect"> <staged-pack project="reflect"/> </target>

  <target name="pack.comp"    depends="quick.comp, quick.scaladoc, quick.interactive, quick.repl, asm.done">
    <staged-pack project="compiler" manifest="${build-pack.dir}/META-INF/MANIFEST.MF">
      <pre> <!-- TODO the files copied here do not influence actuality of this target (nor does the manifest) -->
        <copy todir="${build-pack.dir}/lib">
          <resources refid="repl.fileset"/>
          <mapper classpathref="maven-ant-tasks.classpath" classname="org.apache.maven.artifact.ant.VersionMapper" from="${repl.deps.versions}" to="flatten"/>
        </copy>
        <copy todir="${build-pack.dir}/lib">
          <fileset dir="${lib-extra.dir}">
            <include name="**/*.jar"/>
          </fileset>
        </copy>
        <mkdir dir="${build-pack.dir}/META-INF"/>
        <copy file="${basedir}/META-INF/MANIFEST.MF" toDir="${build-pack.dir}/META-INF"/>
        <manifest file="${build-pack.dir}/META-INF/MANIFEST.MF" mode="update">
          <attribute name="Bundle-Version" value="${version.number}"/>
          <attribute name="Class-Path" value="scala-reflect.jar scala-library.jar"/>
        </manifest>
      </pre>
      <!-- JSR-223 support introduced in 2.11 -->
      <jar-opts>
        <service type="javax.script.ScriptEngineFactory" provider="scala.tools.nsc.interpreter.IMain$Factory"/>
      </jar-opts>
    </staged-pack>
  </target>

  <target name="pack.actors" depends="quick.actors"> <staged-pack project="actors"/> </target>
  <target name="pack.swing" if="has.java6" depends="quick.swing"> <staged-pack project="swing"/> </target>

  <target name="pack.plugins"    depends="quick.plugins">    <staged-pack project="continuations-plugin"/> </target>

  <target name="pack.scalap"     depends="quick.scalap">     <staged-pack project="scalap"/> </target>

  <target name="pack.core" depends="pack.reflect, pack.comp, pack.lib"/>

  <target name="pack.modules" depends="pack.core, pack.actors, pack.swing, pack.plugins, pack.scalap">
    <copy todir="${build-pack.dir}/lib">
      <path refid="external-modules-nocore" />
      <mapper type="flatten" />
    </copy>
  </target>

  <target name="scaladoc.task" depends="pack.modules" unless="docs.skip">
    <taskdef resource="scala/tools/ant/antlib.xml" classpathref="scaladoc.classpath"/>
  </target>

  <target name="pack.partest-extras" depends="quick.partest-extras">
     <staged-pack project="partest-extras"/>
     <staged-pack project="partest-javaagent"
                  manifest="${src.dir}/partest-javaagent/scala/tools/partest/javaagent/MANIFEST.MF"/>
  </target>

  <target name="pack.bin" depends="pack.core, pack.modules, pack.partest-extras">
    <staged-bin stage="pack"/>
  </target>

  <!-- depend on quick.done so quick.bin is run when pack.done is -->
  <target name="pack.done" depends="quick.done, pack.bin"/>


<!-- ===========================================================================
                                  BOOTSTRAPPING BUILD (STRAP)
============================================================================ -->
  <target name="strap.done" depends="pack.done">
    <staged-build with="pack" stage="strap" project="library" srcpath="${src.dir}/library" includes="lib.rootdoc.includes"/>
    <staged-build with="pack" stage="strap" project="reflect"/>
    <staged-build with="pack" stage="strap" project="compiler"/>
  </target>

  <target name="strap-opt" description="Optimized version of strap.done."> <optimized name="strap.done"/></target>


<!-- ===========================================================================
                                  PACKED LOCKER BUILD (PALO)
============================================================================ -->
  <target name="palo.done" depends="locker.done">
    <mkdir dir="${build-palo.dir}/lib"/>
    <jar whenmanifestonly="fail" destfile="${build-palo.dir}/lib/scala-library.jar">
      <fileset dir="${build-locker.dir}/classes/library"/>
      <fileset dir="${forkjoin-classes}"/>
    </jar>
    <jar whenmanifestonly="fail" destfile="${build-palo.dir}/lib/scala-reflect.jar" manifest="${basedir}/META-INF/MANIFEST.MF"
      basedir="${build-locker.dir}/classes/reflect"/>
    <jar whenmanifestonly="fail" destfile="${build-palo.dir}/lib/scala-compiler.jar" manifest="${basedir}/META-INF/MANIFEST.MF">
      <fileset dir="${build-locker.dir}/classes/compiler"/>
      <fileset dir="${asm-classes}"/>
    </jar>
    <copy todir="${build-palo.dir}/lib">
      <resources refid="repl.fileset"/>
      <mapper classpathref="maven-ant-tasks.classpath" classname="org.apache.maven.artifact.ant.VersionMapper" from="${repl.deps.versions}" to="flatten"/>
    </copy>
  </target>

  <target name="palo.bin" depends="palo.done"> <staged-bin stage="palo"/></target>


<!-- ===========================================================================
                                  OSGi Artifacts
============================================================================ -->
  <macrodef name="make-bundle">
    <attribute name="project" />
    <element   name="srcs"        description="Sources for this bundle" optional="true" implicit="true"/>

    <sequential>
      <copy file="${src.dir}/build/bnd/${@{project}.name}.bnd" tofile="${build-osgi.dir}/${@{project}.name}.bnd" overwrite="true">
        <filterset>
          <filter token="VERSION" value="${osgi.version.number}" />
          <filter token="SCALA_BINARY_VERSION" value="${scala.binary.version}" />
          <filter token="SCALA_COMPILER_DOC_VERSION" value="${scala-compiler-doc.version.number}" />
          <filter token="SCALA_COMPILER_INTERACTIVE_VERSION" value="${scala-compiler-interactive.version.number}" />
        </filterset>
      </copy>
      <bnd classpath="${@{project}.jar}"
           eclipse="false"
           failok="false"
           exceptions="true"
           files="${build-osgi.dir}/${@{project}.name}.bnd"
           output="${build-osgi.dir}"/>
      <if><equals arg1="${@{project}.src}" arg2="true"/><then>
        <!--
             A jar-like task that creates an OSGi source bundle. It adds the required MANIFEST.MF headers that allow
             Eclipse to match sources with the corresponding binaries.
        -->
          <jar whenmanifestonly="fail" destfile="${build-osgi.dir}/${@{project}.name}-src.jar">
            <srcs/>
            <manifest>
              <attribute name="Manifest-Version" value="1.0"/>
              <attribute name="Bundle-Name" value="${@{project}.description} Sources"/>
              <attribute name="Bundle-SymbolicName" value="org.scala-lang.${@{project}.package}${@{project}.name}${@{project}.namesuffix}.source"/>
              <attribute name="Bundle-Version" value="${@{project}.version}"/>
              <attribute name="Eclipse-SourceBundle" value="org.scala-lang.${@{project}.package}${@{project}.name}${@{project}.namesuffix};version=&quot;${@{project}.version}&quot;;roots:=&quot;.&quot;" />
            </manifest>
          </jar>
      </then></if>
    </sequential>
  </macrodef>

  <target name="osgi.core" depends="pack.core">
    <mkdir dir="${build-osgi.dir}"/>

    <uptodate property="osgi.bundles.available" targetfile="${build-osgi.dir}/bundles.core.complete">
      <srcfiles dir="${basedir}">
        <include name="build.xml"/>
        <include name="src/build/bnd/*.bnd"/>
        <include name="${library.jar}"/>
        <include name="${reflect.jar}"/>
        <include name="${compiler.jar}"/>
      </srcfiles>
    </uptodate>

    <if><not><isset property="osgi.bundles.available"/></not><then>
      <stopwatch name="osgi.core.timer"/>
      <make-bundle project="library">
        <fileset dir="${src.dir}/library"/>
        <fileset dir="${src.dir}/continuations/library"/>
      </make-bundle>

      <make-bundle project="reflect">
        <fileset dir="${src.dir}/reflect"/>
      </make-bundle>

      <make-bundle project="compiler">
        <fileset dir="${src.dir}/compiler"/>
        <fileset dir="${src.dir}/repl"/>
        <fileset dir="${src.dir}/scaladoc"/>
        <fileset dir="${src.dir}/interactive"/>
      </make-bundle>

      <touch file="${build-osgi.dir}/bundles.core.complete" verbose="no"/>
      <stopwatch name="osgi.core.timer" action="total"/>
    </then></if>
  </target>

  <target name="osgi.done" depends="pack.done, osgi.core">
    <uptodate property="osgi.bundles.available" targetfile="${build-osgi.dir}/bundles.all.complete">
      <srcfiles dir="${basedir}">
        <include name="build.xml"/>
        <include name="src/build/bnd/*.bnd"/>
        <include name="${actors.jar}"/>
        <include name="${continuations-plugin.jar}"/>
        <include name="${swing.jar}"/>
        <include name="${parser-combinators.jar}"/>
        <include name="${xml.jar}"/>
      </srcfiles>
    </uptodate>

    <if><not><isset property="osgi.bundles.available"/></not><then>
      <stopwatch name="osgi.all.timer"/>


      <make-bundle project="actors">
        <fileset dir="${src.dir}/actors"/>
      </make-bundle>

      <make-bundle project="continuations-plugin">
        <fileset dir="${src.dir}/${continuations-plugin.srcdir}"/>
      </make-bundle>

      <if><isset property="has.java6"/><then>
        <make-bundle project="swing">
          <fileset dir="${src.dir}/swing"/>
        </make-bundle>
      </then></if>

      <make-bundle project="parser-combinators"/>
      <make-bundle project="xml"/>

      <touch file="${build-osgi.dir}/bundles.all.complete" verbose="no"/>
      <stopwatch name="osgi.all.timer" action="total"/>
    </then></if>
  </target>


<!-- ===========================================================================
                                  TEST SUITE
============================================================================ -->
  <!-- bootstrapping stability: compare {quick,strap}/(lib|reflect|comp) -->
  <target name="test.stability" depends="strap.done">
    <exec osfamily="unix" vmlauncher="false" executable="${basedir}/tools/stability-test.sh" failonerror="true" />
    <!-- I think doing it this way means it will auto-pass on windows... that's the idea. If not, something like this. -->
    <!-- <exec osfamily="windows" executable="foo" failonerror="false" failifexecutionfails="false" /> -->
  </target>

  <target name="test.stability-opt" description="Optimized version of test.stability."> <optimized name="test.stability"/></target>

  <target name="test.osgi.init" depends="osgi.done">
    <uptodate property="test.osgi.available" targetfile="${build-osgi.dir}/test-compile.complete">
      <srcfiles dir="${test.osgi.src}">
        <include name="**/*.scala"/>
      </srcfiles>
    </uptodate>
  </target>

  <target name="test.osgi.comp" depends="test.osgi.init, quick.done" unless="test.osgi.available">
    <stopwatch name="test.osgi.compiler.timer"/>
    <mkdir dir="${test.osgi.classes}"/>
    <scalacfork
      destdir="${test.osgi.classes}"
      compilerpathref="quick.compiler.path"
      params="${scalac.args.quick}"
      srcdir="${test.osgi.src}"
      jvmargs="${scalacfork.jvmargs}">
      <include name="**/*.scala"/>
      <compilationpath refid="test.osgi.compiler.build.path"/>
    </scalacfork>
    <touch file="${build-osgi.dir}/test-compile.complete" verbose="no"/>
    <stopwatch name="test.osgi.compiler.timer" action="total"/>
  </target>

  <target name="test.osgi" depends="test.osgi.comp">
    <stopwatch name="test.osgi.timer"/>
    <mkdir dir="${test.osgi.classes}"/>

    <echo message="Running OSGi JUnit tests. Output in ${build-osgi.dir}"/>
    <junit fork="yes" haltonfailure="yes">
      <classpath refid="test.osgi.compiler.build.path"/>
      <batchtest fork="yes" todir="${build-osgi.dir}">
        <fileset dir="${test.osgi.classes}">
          <include name="**/*Test.class"/>
        </fileset>
      </batchtest>
      <formatter type="xml" /> <!-- silenced by having it use a file; I tried for an hour to use other formatters but classpath issues drove me to this usefile="false" -->
    </junit>
    <stopwatch name="test.osgi.timer" action="total"/>
  </target>


<!-- ===========================================================================
                                  SBT Compiler Interface
============================================================================ -->
  <target name="test.sbt" depends="quick.done">
    <if><not><and>
        <available file="${sbt.interface.jar}"/>
        <available file="${sbt.interface.src.jar}"/></and></not>
    <then>
      <!-- Ensure directories exist -->
      <mkdir dir="${sbt.src.dir}"/>
      <mkdir dir="${sbt.lib.dir}"/>

      <get src="${sbt.interface.url}" dest="${sbt.interface.jar}"/>
      <get src="${sbt.interface.src.url}" dest="${sbt.interface.src.jar}"/>

      <!-- Explode sources -->
      <unzip src="${sbt.interface.src.jar}" dest="${sbt.src.dir}"/>
    </then></if>

    <stopwatch name="quick.sbt-interface.timer"/>
    <mkdir dir="${build-sbt.dir}/classes"/>
    <scalacfork
      destdir="${build-sbt.dir}/classes"
      compilerpathref="quick.compiler.path"
      params="${scalac.args.quick}"
      srcdir="${sbt.src.dir}"
      jvmargs="${scalacfork.jvmargs}">
      <include name="**/*.scala"/>
      <compilationpath refid="sbt.compile.build.path"/>
    </scalacfork>
    <touch file="${build-sbt.dir}/sbt-interface.complete" verbose="no"/>
    <stopwatch name="quick.sbt-interface.timer" action="total"/>
  </target>

  <target name="test.junit.init" depends="quick.done">
    <uptodate property="test.junit.available" targetfile="${build-junit.dir}/test-compile.complete">
      <srcfiles dir="${test.junit.src}">
        <include name="**/*.scala"/>
      </srcfiles>
    </uptodate>
  </target>

  <target name="test.junit.comp" depends="test.junit.init, quick.done" unless="test.junit.available">
    <stopwatch name="test.junit.compiler.timer"/>
    <mkdir dir="${test.junit.classes}"/>
    <scalacfork
      destdir="${test.junit.classes}"
      compilerpathref="quick.compiler.path"
      params="${scalac.args.quick}"
      srcdir="${test.junit.src}"
      jvmargs="${scalacfork.jvmargs}">
      <include name="**/*.scala"/>
      <compilationpath refid="test.junit.compiler.build.path"/>
    </scalacfork>
    <touch file="${build-junit.dir}/test-compile.complete" verbose="no"/>
    <stopwatch name="test.junit.compiler.timer" action="total"/>
  </target>

  <target name="test.junit" depends="test.junit.comp">
    <stopwatch name="test.junit.timer"/>
    <mkdir dir="${test.junit.classes}"/>
    <echo message="Note: details of failed tests will be output to ${build-junit.dir}"/>
    <junit fork="yes" haltonfailure="yes" printsummary="on">
      <classpath refid="test.junit.compiler.build.path"/>
      <batchtest fork="yes" todir="${build-junit.dir}">
        <fileset dir="${test.junit.classes}">
          <include name="**/*Test.class"/>
        </fileset>
      </batchtest>
      <formatter type="plain"/>
    </junit>
    <stopwatch name="test.junit.timer" action="total"/>
  </target>

  <!-- See test/build-partest.xml for the macro(s) being used here. -->
  <target name="partest.task" depends="pack.done">
    <!-- note the classpathref! this is the classpath used to run partest,
    so it must have the new compiler.... -->
    <taskdef
       classpathref="partest.compilation.path"
       resource="scala/tools/partest/antlib.xml"/>
  </target>

  <target name="test.suite.init" depends="partest.task">
    <!-- read by test/partest to determine classpath used to run partest -->
    <propertyfile file = "build/pack/partest.properties">
      <entry key       = "partest.classpath" value="${toString:partest.compilation.path}"/>
    </propertyfile>
  </target>

  <target name="test.suite" depends="test.suite.init">
    <testSuite kinds="pos neg run jvm res scalap scalacheck specialized instrumented"/>
  </target>

  <target name="test.suite.color" depends="test.suite.init">
    <testSuite colors="8" kinds="pos neg run jvm res scalap scalacheck specialized instrumented"/>
  </target>

  <target name="test.run" depends="test.suite.init">
    <testSuite kinds="run jvm"/>
  </target>

  <target name="test.continuations.suite" depends="test.suite.init">
    <testSuite kinds="continuations-neg continuations-run"
          scalacOpts="${scalac.args.optimise} -Xpluginsdir ${build-quick.dir}/${continuations-plugin.targetdir} -Xplugin-require:continuations -P:continuations:enable"
    />
  </target>

  <target name="test.scaladoc" depends="test.suite.init">
    <testSuite kinds="run scalacheck" srcdir="scaladoc"/>
  </target>

  <target name="test.interactive" depends="test.suite.init">
    <testSuite kinds="presentation"/>
  </target>

  <!-- for use in PR validation, where stability is rarely broken, so we're going to use starr for locker,
       and skip test.stability (which requires locker == quick) -->
  <target name="test.core" depends="test.osgi, test.sbt, test.bc, test.junit, test.interactive, test.continuations.suite, test.scaladoc, test.suite"/>
  <target name="test.done" depends="test.core, test.stability"/>

<!-- ===========================================================================
                                  BINARY COMPATIBILITY TESTING
============================================================================ -->
  <target name="bc.init" depends="init" unless="maven-deps-done-mima">
    <property name="bc-reference-version" value="2.11.0"/>

    <property name="bc-build.dir" value="${build.dir}/bc"/>
    <!-- Obtain mima -->
    <mkdir dir="${bc-build.dir}"/>
    <!-- Pull down MIMA -->
    <artifact:dependencies pathId="mima.classpath">
      <dependency groupId="com.typesafe" artifactId="mima-reporter_2.9.2" version="0.1.5"/>
    </artifact:dependencies>
    <artifact:dependencies pathId="old.bc.classpath">
      <dependency groupId="org.scala-lang" artifactId="scala-swing" version="${bc-reference-version}"/>
      <dependency groupId="org.scala-lang" artifactId="scala-library" version="${bc-reference-version}"/>
      <dependency groupId="org.scala-lang" artifactId="scala-reflect" version="${bc-reference-version}"/>
    </artifact:dependencies>
    <property name="maven-deps-done-mima" value="true"/>
  </target>

  <macrodef name="bc.run-mima">
    <attribute name="jar-name"/>
    <attribute name="prev"/>
    <attribute name="curr"/>
    <attribute name="direction"/>
    <sequential>
      <echo message="Checking @{direction} binary compatibility for @{jar-name} (against ${bc-reference-version})"/>
      <java taskname="mima"
         fork="true"
         failonerror="true"
         classname="com.typesafe.tools.mima.cli.Main">
           <arg value="--prev"/>
           <arg value="@{prev}"/>
           <arg value="--curr"/>
           <arg value="@{curr}"/>
           <arg value="--filters"/>
           <arg value="${basedir}/bincompat-@{direction}.whitelist.conf"/>
           <arg value="--generate-filters"/>
           <classpath>
             <path refid="mima.classpath"/>
           </classpath>
      </java>
    </sequential>
  </macrodef>

  <macrodef name="bc.check">
    <attribute name="project"/>
    <sequential>
        <bc.run-mima
                jar-name="scala-@{project}"
                prev="${org.scala-lang:scala-@{project}:jar}"
                curr="${@{name}.jar}"
                direction="backward"/>
        <bc.run-mima
                jar-name="scala-@{project}"
                prev="${@{name}.jar}"
                curr="${org.scala-lang:scala-@{project}:jar}"
                direction="forward"/>
    </sequential>
  </macrodef>

  <target name="test.bc-opt" description="Optimized version of test.bc."> <optimized name="test.bc"/></target>

  <!-- Enable after the release of the 2.11.0 or a prior RC that estabilishes the new baseline. -->
  <target name="test.bc"></target>
  <target name="test.bc.disabled" depends="bc.init, pack.lib, pack.reflect, pack.swing">
    <bc.check project="library"/>
    <bc.check project="reflect"/>
    <bc.check project="swing"/>
  </target>

<!-- ===========================================================================
                                  DOCUMENTATION
============================================================================ -->
  <target name="docs.start" depends="scaladoc.task" unless="docs.skip">
    <!-- Set the github commit scaladoc sources point to -->
    <!-- For releases, look for the tag with the same name as the maven version -->
    <condition property="scaladoc.git.commit" value="v${maven.version.number}">
      <isset property="build.release"/>
    </condition>
    <!-- For snapshots, if we know the commit, point scaladoc to that particular commit instead of master -->
    <condition property="scaladoc.git.commit" value="${git.commit.sha}">
      <not><equals arg1="${git.commit.sha}" arg2="unknown"/></not>
    </condition>
    <!-- Fallback: point scaladoc to master -->
    <property name="scaladoc.git.commit" value="master"/>
    <!-- Compute the URL and show it -->
    <property name="scaladoc.url" value="https://github.com/scala/scala/tree/${scaladoc.git.commit}/src"/>
    <echo message="Scaladoc will point to ${scaladoc.url} for source files."/>

    <!-- Unless set with -Dscaladoc.<...>, these won't be activated -->
    <property name="scaladoc.raw.output" value="no"/>
    <property name="scaladoc.no.prefixes" value="no"/>
  </target>

  <target name="docs.lib" depends="docs.start" unless="docs.skip">
    <staged-docs project="library">
      <include name="**/*.scala"/>
      <exclude name="runtime/*$.scala"/>
      <exclude name="runtime/ScalaRunTime.scala"/>
      <exclude name="runtime/StringAdd.scala"/>
    </staged-docs>
  </target>

  <target name="docs.reflect" depends="docs.start" unless="docs.skip">
    <staged-docs project="reflect">
      <include name="**/*.scala"/>
      <exclude name="reflect/Code.scala"/>
      <exclude name="reflect/Print.scala"/>
      <exclude name="reflect/Symbol.scala"/>
      <exclude name="reflect/Tree.scala"/>
      <exclude name="reflect/Type.scala"/>
    </staged-docs>
  </target>

  <target name="docs.comp" depends="docs.start" unless="docs.skip">
    <staged-docs project="compiler">
      <include name="**/*.scala"/>
    </staged-docs>
  </target>

  <target name="docs.actors" depends="docs.start" unless="docs.skip">
    <staged-docs project="actors">
      <include name="**/*.scala"/>
    </staged-docs>
  </target>

  <target name="docs.swing" depends="docs.start" unless="docs.skip">
    <staged-docs project="swing">
      <include name="**/*.scala"/>
    </staged-docs>
  </target>

  <target name="docs.scalap" depends="docs.start" unless="docs.skip">
    <staged-docs project="scalap">
      <include name="**/*.scala"/>
    </staged-docs>
  </target>

  <target name="docs.continuations-plugin" depends="docs.start" unless="docs.skip">
    <staged-docs project="continuations-plugin">
      <include name="**/*.scala"/>
    </staged-docs>
  </target>

  <target name="docs.continuations-library" depends="docs.start" unless="docs.skip">
    <staged-docs project="continuations-library">
      <include name="**/*.scala"/>
    </staged-docs>
  </target>

  <target name="docs.man" depends="docs.start">
    <staged-uptodate stage="docs" project="manual">
      <check><srcfiles dir="${src.dir}/manual"/></check>
      <do>
        <mkdir dir="${build.dir}/manmaker/classes"/>
        <scalac
          destdir="${build.dir}/manmaker/classes"
          classpathref="manual.build.path"
          srcdir="${src.dir}/manual"
          includes="**/*.scala"
          addparams="${scalac.args.all} -language:implicitConversions"/>
        <mkdir dir="${build-docs.dir}/manual/man/man1"/>
        <mkdir dir="${build-docs.dir}/manual/html"/>
        <mkdir dir="${build-docs.dir}/manual/genman/man1"/>
        <taskdef name="genman"
                 classname="scala.tools.docutil.ManMaker"
                 classpathref="manual.build.path"/>
        <genman command="fsc, scala, scalac, scaladoc, scalap"
                htmlout="${build-docs.dir}/manual/html"
                manout="${build-docs.dir}/manual/genman"/>
        <!-- On Windows source and target files can't be the same ! -->
        <fixcrlf
          srcdir="${build-docs.dir}/manual/genman"
          destdir="${build-docs.dir}/manual/man"
          eol="unix" includes="**/*.1"/>
        <copy todir="${build-docs.dir}/manual/html" overwrite="true">
          <fileset dir="${src.dir}/manual/scala/tools/docutil/resources">
            <include name="**/*.html"/>
            <include name="**/*.css"/>
            <include name="**/*.gif"/>
            <include name="**/*.png"/>
          </fileset>
        </copy>
      </do>
    </staged-uptodate>
  </target>

  <target name="docs.core" depends="docs.lib, docs.reflect, docs.comp" unless="docs.skip"/>
  <target name="docs.done" depends="docs.core, docs.actors, docs.swing, docs.scalap, docs.continuations-plugin, docs.continuations-library" unless="docs.skip"/>

<!-- ===========================================================================
                                  DISTRIBUTION
============================================================================ -->
  <target name="dist.base" depends="osgi.done">
    <property name="dist.name" value="scala-${version.number}"/>
    <property name="dist.dir" value="${dists.dir}/${dist.name}"/>

    <macrodef name="copy-bundle">
      <attribute name="project" />

      <sequential>
        <copy tofile="${dist.dir}/${@{project}.targetdir}/${@{project}.name}.jar"   file="${build-osgi.dir}/org.scala-lang.${@{project}.package}${@{project}.name}.jar" overwrite="true"/>
        <copy tofile="${dist.dir}/src/${@{project}.name}-src.jar" file="${@{project}.srcjar}" overwrite="true"/>
      </sequential>
    </macrodef>

    <mkdir dir="${dist.dir}/lib"/>
    <mkdir dir="${dist.dir}/${continuations-plugin.targetdir}"/>
    <mkdir dir="${dist.dir}/src"/>

    <copy todir="${dist.dir}/lib" overwrite="true">
      <resources refid="repl.fileset"/>
      <mapper classpathref="maven-ant-tasks.classpath" classname="org.apache.maven.artifact.ant.VersionMapper"
              from="${repl.deps.versions}" to="flatten"/>
    </copy>

    <!-- copy classfile jars and source jars from osgi build to dist -->
    <copy-bundle project="library"/>
    <copy-bundle project="reflect"/>
    <copy-bundle project="compiler"/>

    <copy-bundle project="swing"/>
    <copy-bundle project="actors"/>

    <copy-bundle project="xml"/>
    <copy-bundle project="parser-combinators"/>
    <copy-bundle project="continuations-plugin"/>

    <!-- scalap -->
    <copy toDir="${dist.dir}/lib" overwrite="true">
      <fileset dir="${build-pack.dir}/lib">
        <include name="scalap.jar"/>
      </fileset>
    </copy>
    <jar whenmanifestonly="fail" destfile="${dist.dir}/src/scalap-src.jar" basedir="${src.dir}/scalap"/>

    <mkdir dir="${dist.dir}/bin"/>
    <copy toDir="${dist.dir}/bin" overwrite="true">
      <fileset dir="${build-pack.dir}/bin"/>
    </copy>
    <chmod perm="ugo+rx" file="${dist.dir}/bin/scala"/>
    <chmod perm="ugo+rx" file="${dist.dir}/bin/scalac"/>
    <chmod perm="ugo+rx" file="${dist.dir}/bin/scaladoc"/>
    <chmod perm="ugo+rx" file="${dist.dir}/bin/fsc"/>
    <chmod perm="ugo+rx" file="${dist.dir}/bin/scalap"/>
  </target>

  <target name="dist.doc" depends="dist.base, docs.done">
    <mkdir dir="${dist.dir}/doc/scala-devel-docs"/>
    <copy toDir="${dist.dir}/doc/scala-devel-docs" overwrite="true" flatten="true">
      <file file="${scala-xml-javadoc}"/>
      <file file="${scala-parser-combinators-javadoc}"/>
    </copy>

    <copy file="${docs.dir}/LICENSE" toDir="${dist.dir}/doc" overwrite="true"/>
    <copy file="${docs.dir}/README" toDir="${dist.dir}/doc" overwrite="true"/>
    <mkdir dir="${dist.dir}/doc/scala-devel-docs/api"/>
    <copy toDir="${dist.dir}/doc/scala-devel-docs/api" overwrite="true">
      <fileset dir="${build-docs.dir}/library"/>
    </copy>
    <mkdir dir="${dist.dir}/doc/scala-devel-docs/examples"/>
    <copy toDir="${dist.dir}/doc/scala-devel-docs/examples" overwrite="true">
      <fileset dir="${docs.dir}/examples">
        <exclude name="**/*.desired.sha1"/>
      </fileset>
    </copy>
    <copy file="${src.dir}/swing/doc/README"
          toFile="${dist.dir}/doc/scala-devel-docs/README.scala-swing"
          overwrite="true"/>
  </target>

  <target name="dist.man" depends="dist.base, docs.man">
    <mkdir dir="${dist.dir}/man"/>
    <copy toDir="${dist.dir}/man" overwrite="true">
      <fileset dir="${build-docs.dir}/manual/man"/>
    </copy>
    <mkdir dir="${dist.dir}/doc/scala-devel-docs/tools"/>
    <copy toDir="${dist.dir}/doc/scala-devel-docs/tools" overwrite="true">
      <fileset dir="${build-docs.dir}/manual/html"/>
    </copy>
  </target>


  <target name="dist.partial" depends="dist.base">
    <if><not><os family="windows"/></not><then>
      <symlink link="${dists.dir}/latest" resource="${dist.name}" overwrite="true"/>
    </then><else> <!-- XXX THIS PROBABLY DOES NOT WORK: copying must happen last during dist.done! is this guaranteed? -->
      <copydir dest="${dists.dir}/latest" src="${dist.dir}"/>
    </else></if>
  </target>

  <target name="dist.done" depends="dist.doc, dist.man, dist.partial"/>

<!-- ===========================================================================
MAIN DISTRIBUTION PACKAGING
============================================================================ -->

  <target name="pack-archives.done" depends="dist.done, docs.done">
    <macrodef name="tarz">
      <attribute name="name"     description="The tar file name (without extension)."/>
      <element   name="file-sets"    description="A sequence of fileset elements to be included in the tar balls." optional="false" implicit="true"/>

      <sequential>
        <tar destfile="@{name}.tar" compression="none" longfile="gnu">
          <file-sets/>
        </tar>
        <gzip src="@{name}.tar" destfile="@{name}.tgz"/>
        <if>
          <not><equals arg1="${archives.skipxz}" arg2="true" /></not>
          <then>
            <exec executable="xz" failifexecutionfails="false">
              <arg line="-k -9e -S .xz @{name}.tar"/>
            </exec>
            <move file="@{name}.tar.xz" tofile="@{name}.txz" failonerror="false"/>
          </then>
        </if>
        <delete file="@{name}.tar" />
      </sequential>
    </macrodef>

    <mkdir dir="${dists.dir}/archives"/>
    <property name="archive-base" value="${dists.dir}/archives/${dist.name}"/>

    <tarz name="${archive-base}">
      <tarfileset dir="${dist.dir}" prefix="${dist.name}" includes="bin/**" mode="755"/>
      <tarfileset dir="${dist.dir}" prefix="${dist.name}" excludes="bin/**"/>
    </tarz>

    <zip destfile="${archive-base}.zip">
      <zipfileset prefix="${dist.name}" dir="${dist.dir}"/>
    </zip>

    <if><not><isset property="docs.skip"/></not><then>
      <tarz name="${archive-base}-devel-docs">
        <tarfileset dir="${dist.dir}/doc/scala-devel-docs" prefix="${dist.name}-devel-docs"/>
      </tarz>
    </then></if>

    <tarz name="${archive-base}-sources">
      <tarfileset dir="${basedir}" prefix="${dist.name}-sources">
        <exclude name="bin/**"/>
        <exclude name="build/**"/>
        <exclude name="debian/**"/>
        <exclude name="dists/**"/>
        <exclude name="logs/**"/>
        <exclude name="sandbox/**"/>
        <exclude name="test/partest"/>
        <exclude name=".git"/>
      </tarfileset>
      <tarfileset dir="${basedir}" prefix="${dist.name}-sources" filemode="755">
        <include name="test/partest"/>
      </tarfileset>
    </tarz>

    <!-- checksum everything -->
    <checksum fileext=".md5">
      <fileset dir="${dists.dir}/archives">
        <include name="${dist.name}*"/>
      </fileset>
    </checksum>

    <!-- UNUSED: create 'scala-latest-sources.tgz' alias (or copy, on windows)
         we use github's source download feature
    <if><isset property="os.win"/><then>
      <copy tofile="${dists.dir}/archives/scala-latest-sources.tgz" overwrite="true">
        <fileset dir="${dists.dir}/archives">
           <include name="scala-${version.number}-sources.tgz"/>
        </fileset>
      </copy>
    </then><else>
      (be sure to use a relative symlink to make the distribution portable,
          `resource` is relative to directory of `link`)
      <symlink link="${dists.dir}/archives/scala-latest-sources.tgz"
               resource="scala-${version.number}-sources.tgz"
               overwrite="true"/>
    </else></if> -->
  </target>

  <macrodef name="mvn-package">
    <attribute name="project"/>

    <sequential>
      <local name="artifact-base"/> <property name="artifact-base" value="${maven-base}/${@{project}.dir}${@{project}.name}/${@{project}.name}"/>

      <mkdir dir="${maven-base}/${@{project}.dir}${@{project}.name}"/>
      <copy tofile="${artifact-base}.jar" file="${build-osgi.dir}/org.scala-lang.${@{project}.package}${@{project}.name}${@{project}.namesuffix}.jar" overwrite="true"/>
      <copy tofile="${artifact-base}-src.jar" file="${build-osgi.dir}/${@{project}.name}-src.jar" overwrite="true"/>
      <copy tofile="${artifact-base}-pom.xml" file="${src.dir}/build/maven/${@{project}.dir}/${@{project}.name}-pom.xml" overwrite="true"/>

      <if><not><isset property="docs.skip"/></not><then>
        <jar destfile="${artifact-base}-docs.jar" basedir="${build-docs.dir}/@{project}" whenmanifestonly="fail">
          <include name="**/*"/>
        </jar>
      </then></if>
    </sequential>
  </macrodef>

  <target name="pack-maven.core" depends="osgi.core, docs.core">
    <property name="maven-base" value="${dists.dir}/maven/${version.number}"/>
    <mkdir dir="${maven-base}"/>

    <mvn-package project="library"/>
    <mvn-package project="reflect"/>
    <mvn-package project="compiler"/>
  </target>

  <target name="pack-maven.base" depends="pack-maven.core, osgi.done, docs.done">
    <mvn-package project="swing"/>
    <mvn-package project="actors"/>
    <mvn-package project="continuations-plugin"/>

    <!-- don't bother fitting scalap into the mould: it will move out soon -->
    <copy tofile="${maven-base}/scalap/scalap-pom.xml" file="${src.dir}/build/maven/scalap-pom.xml" overwrite="true"/>
    <copy tofile="${maven-base}/scalap/scalap.jar" file="${scalap.jar}" overwrite="true"/>
    <jar destfile="${maven-base}/scalap/scalap-src.jar" basedir="${src.dir}/scalap" whenmanifestonly="fail"/>
    <if><not><isset property="docs.skip"/></not><then>
      <jar destfile="${maven-base}/scalap/scalap-docs.jar" basedir="${build-docs.dir}/scalap"/>
    </then></if>
  </target>

  <target name="pack-maven.done" depends="pack-maven.base">
    <!-- Create dists/maven/latest alias and copy maven-deploy ant build there. -->
    <if><isset property="os.win"/><then>
      <copy todir="${dists.dir}/maven/latest" overwrite="true">
        <fileset dir="${maven-base}"/>
      </copy>
    </then><else>
      <symlink link="${dists.dir}/maven/latest"
               resource="${version.number}"
               overwrite="true"/>
    </else></if>
    <!-- copy build file and its dependencies -->
    <copy todir="${maven-base}"
          file="${lib-ant.dir}/ant-contrib.jar" overwrite="true"/>
    <copy todir="${maven-base}"
          file="${lib-ant.dir}/maven-ant-tasks-2.1.1.jar" overwrite="true"/>
    <copy tofile="${maven-base}/build.xml"
          file="${src.dir}/build/maven/maven-deploy.xml"/>
    <!-- export properties for use when deploying -->
    <echoproperties destfile="${maven-base}/build.properties"/>
  </target>

  <!-- keep these properties out of ${maven-base}/build.properties, dumped in pack-maven.done -->
  <target name="init.maven" depends="init">
    <property name="remote.snapshot.repository" value="https://oss.sonatype.org/content/repositories/snapshots" />
    <property name="remote.release.repository"  value="https://oss.sonatype.org/service/local/staging/deploy/maven2" />

    <property name="local.snapshot.repository" value="${user.home}/.m2/repository" />
    <property name="local.release.repository"  value="${user.home}/.m2/repository" />

    <property name="repository.credentials.id" value="sonatype-nexus" />
    <property name="settings.file" value="${user.home}/.m2/settings.xml" />

    <if><contains string="${maven.version.number}" substring="-SNAPSHOT"/><then>
      <property name="remote.repository" value="${remote.snapshot.repository}"/>
      <property name="local.repository"  value="${local.snapshot.repository}"/>
    </then><else>
      <property name="remote.repository" value="${remote.release.repository}"/>
      <property name="local.repository"  value="${local.release.repository}"/>
    </else></if>
  </target>


<!-- ===========================================================================
                                  MAVEN PUBLISHING
============================================================================ -->
  <!-- TODO: inline maven-deploy.xml here and remove it, once jenkins jobs no longer rely on it -->
  <target name="publish"        depends="pack-maven.base, init.maven" description="Publishes unsigned artifacts to the maven repo.">       <deploy dir="${maven-base}/"/> </target>
  <target name="publish.local"  depends="pack-maven.base, init.maven" description="Publishes unsigned artifacts to the local maven repo."> <deploy dir="${maven-base}/" local="true"/> </target>
  <target name="publish.signed" depends="pack-maven.base, init.maven" description="Publishes signed artifacts to the remote maven repo.">  <deploy dir="${maven-base}/" signed="true"/> </target>

  <target name="publish-core"   depends="pack-maven.core, init.maven">
    <deploy-one dir="${maven-base}/" name="scala-compiler" />
    <deploy-one dir="${maven-base}/" name="scala-library"  />
    <deploy-one dir="${maven-base}/" name="scala-reflect"  />
  </target>
  <target name="publish-core-local" depends="pack-maven.core, init.maven">
    <deploy-one dir="${maven-base}/" name="scala-compiler" local="true"/>
    <deploy-one dir="${maven-base}/" name="scala-library"  local="true"/>
    <deploy-one dir="${maven-base}/" name="scala-reflect"  local="true"/>
  </target>

  <target name="publish-core-opt" description="Builds an untested optimised core (library/reflect/compiler) and publishes to maven.">
    <optimized name="publish-core"/>
  </target>

<!-- ===========================================================================
                                  STABLE REFERENCE (STARR)
============================================================================ -->
<!-- Does not use any properties other than ${basedir}, so that it can
     run without 'init' (when using 'replacestarrwin') -->

  <target name="starr.start">
    <fail message="Library in build/pack not available">
      <condition><not><and>
        <available file="${library.jar}"/>
      </and></not></condition>
    </fail>
    <fail message="Compiler in build/quick not available">
      <condition><not><and>
        <available file="${build-quick.dir}/classes/compiler"/>
        <available file="${build-quick.dir}/compiler.complete"/>
      </and></not></condition>
    </fail>
  </target>

  <target name="starr.jars" depends="starr.start">
    <copy toDir="${lib.dir}" overwrite="true">
      <fileset dir="${build-pack.dir}/lib">
        <include name="scala-library.jar"/>
        <include name="scala-reflect.jar"/>
        <include name="scala-compiler.jar"/>
      </fileset>
    </copy>
  </target>

  <target name="starr.src" depends="starr.jars">
    <jar whenmanifestonly="fail" destfile="${lib.dir}/scala-library-src.jar">
      <fileset dir="${src.dir}/library"/>
      <fileset dir="${src.dir}/swing"/>
      <fileset dir="${src.dir}/actors"/>
      <fileset dir="${src.dir}/forkjoin"/>
    </jar>
    <jar whenmanifestonly="fail" destfile="${lib.dir}/scala-reflect-src.jar" basedir="${src.dir}/reflect"/>
    <jar whenmanifestonly="fail" destfile="${lib.dir}/scala-compiler-src.jar">
      <fileset dir="${src.dir}/compiler"/>
      <fileset dir="${src.dir}/asm"/>
    </jar>
  </target>

  <target name="starr.removesha1" depends="starr.src">
    <!-- remove SHA1 files for no starr, so we don't loose artifacts. -->
    <delete>
      <fileset dir="${lib.dir}">
        <include name="scala-compiler.jar.desired.sha1"/>
        <include name="scala-reflect.jar.desired.sha1"/>
        <include name="scala-library.jar.desired.sha1"/>
        <include name="scala-library-src.jar.desired.sha1"/>
        <include name="scala-reflect-src.jar.desired.sha1"/>
        <include name="scala-compiler-src.jar.desired.sha1"/>
      </fileset>
    </delete>
  </target>

  <target name="starr.done" depends="starr.jars, starr.removesha1"/>

  <target name="replacestarr" description="Replaces the Starr compiler and library by fresh ones built from current sources and tests them.">
    <fail message="This target is not available on Windows. Use 'ant replacestarrwin' instead.">
      <condition>
        <os family="windows"/>
      </condition>
    </fail>
    <!-- needs antcall to enforce ordering -->
    <antcall target="locker.clean"/>
    <antcall target="pack.done"/>
    <antcall target="starr.done"/>
    <antcall target="locker.clean"/>
    <antcall target="test.done"/>
  </target>

  <target name="replacestarr-opt" description="Replaces the Starr compiler and library by fresh, optimised ones built from current sources and tests them.">
    <optimized name="replacestarr"/></target>

  <!-- Ant on Windows is not able to delete jar files that are referenced in any <path>.
       See ticket 1290 on trac. -->
  <target name="replacestarrwin" description="Creates a new Starr on Windows. Manually execute 'ant locker.clean build' first!">
    <fail message="This target is only available on Windows. Use 'ant replacestarr' instead.">
      <condition>
        <not><os family="windows"/></not>
      </condition>
    </fail>
    <echo message="CAUTION: Make sure to execute 'ant locker.clean build' prior to calling 'replacestarrwin'."/>
    <antcall target="starr.done"/>
    <antcall target="locker.clean"/>
    <antcall target="test.done"/>
  </target>

  <target name="replacestarrwin-opt" description="Creates a new Starr on Windows. Manually execute 'ant locker.clean build' first!">
    <optimized name="replacestarrwin"/></target>

  <target name="replacelocker" description="Replaces the Locker compiler and library by fresh ones built from current sources."
    depends="palo.clean, locker.unlock, palo.done"/>

  <target name="replacelocker-opt" description="Replaces the Locker compiler and library by fresh, optimised ones built from current sources.">
    <optimized name="replacelocker"/></target>

  <target name="buildlocker" description="Does the same for locker as build does for quick." depends="locker.unlock, palo.bin"/>
  <target name="unlocklocker" description="Same as buildlocker." depends="buildlocker"/> <!-- REMOVE -->

  <target name="fastlocker.lib" description="Buildlocker without extra fuss" depends="locker.unlock, locker.lib">
    <property name="fastlocker" value="true"/>
  </target>

  <target name="fastlocker.reflect" description="Buildlocker without extra fuss" depends="locker.unlock, locker.reflect">
    <property name="fastlocker" value="true"/>
  </target>

  <target name="fastlocker.comp" description="Buildlocker without extra fuss" depends="locker.unlock, locker.comp">
    <property name="fastlocker" value="true"/>
  </target>

  <target name="fastlocker" description="Buildlocker without extra fuss" depends="fastlocker.comp"/>

<!-- ===========================================================================
                                  VISUALIZATION
============================================================================ -->

  <target name="graph.init">
    <taskdef name="vizant" classname="vizant.Vizant" classpath="${lib-ant.dir}/vizant.jar"/>
  </target>

  <target name="graph.all" depends="graph.init">
    <vizant antfile="${ant.file}" outfile="${ant.project.name}.dot" from="all.done"/>
  </target>

  <target name="graph.sabbus" depends="graph.init">
    <vizant antfile="${ant.file}" outfile="${ant.project.name}.dot"/>
  </target>
</project>
