<?xml version="1.0" encoding="UTF-8"?>

<project name="sabbus" default="build" xmlns:artifact="urn:maven-artifact-ant">
  <description>
SuperSabbus for Scala core, builds the scala library and compiler. It can also package it as a simple distribution, tests it for stable bootstrapping and against the Scala test suite.
  </description>

<!-- USAGE FROM JENKINS SCRIPTS IS (CURRENTLY) AS FOLLOWS:
ant $antArgs $scalacArgs $targets

antArgs tend to be:
 -Darchives.skipxz=true
 -Dscalac.args.optimise=-optimise

scalacArgs examples:
  "-Dscalac.args=\"-Yrangepos\" -Dpartest.scalac_opts=\"-Yrangepos\""

targets exercised:
  build-opt nightly test.suite test.continuations.suite test.scaladoc locker.done
-->


<!-- ===========================================================================
                                  END-USER TARGETS
============================================================================ -->
  <target name="build"     depends="pack.done"      description="Builds the Scala compiler and library. Executables are in 'build/pack/bin'."/>
  <target name="test"      depends="test.done"      description="Runs test suite and bootstrapping test on Scala compiler and library."/>
  <target name="docs"      depends="docs.done"      description="Builds documentation for the Scala library. Scaladoc is in 'build/scaladoc/library'."/>
  <target name="docscomp"  depends="docs.comp"      description="Builds documentation for the Scala compiler and library. Scaladoc is in 'build/scaladoc'."/>
  <target name="dist" depends="all.clean, all.done" description="Cleans all and builds and tests a new distribution."/>
  <target name="partialdist" depends="dist.partial" description="Makes a new distribution without documentation, so just for testing."/>
  <target name="fastdist"    depends="dist.done"    description="Makes a new distribution without testing it or removing partially build elements."/>

  <target name="build-opt"       description="Optimized version of build.">       <optimized name="build"/></target>
  <target name="test-opt"        description="Optimized version of test.">        <optimized name="test"/></target>
  <target name="dist-opt"        description="Optimized version of dist.">        <optimized name="dist"/></target>
  <target name="partialdist-opt" description="Optimized version of partialdist."> <optimized name="partialdist"/></target>
  <target name="fastdist-opt"    description="Optimized version of fastdist.">    <optimized name="fastdist"/></target>

  <!-- packaging -->
  <target name="distpack" depends="dist.done, docs.done">
    <ant antfile="${src.dir}/build/pack.xml" target="pack-all.done" inheritall="yes" inheritrefs="yes"/></target>

  <target name="distpack-maven" depends="dist.done, docs.done">
    <ant antfile="${src.dir}/build/pack.xml" target="pack-maven.done" inheritall="yes" inheritrefs="yes"/></target>

  <target name="distpack-opt" description="Builds an optimised distribution."> <optimize name="distpack"/></target>
  <target name="distpack-maven-opt" description="Builds an optimised maven distribution."><optimize name="distpack-maven"/></target>

  <target name="all.done" depends="dist.done, test.done"/>

  <!-- must use depends for all.done, not antcall: need the properties defined in there (dist.dir) -->
  <target name="nightly-nopt" depends="all.done, docs.done">
    <ant antfile="${src.dir}/build/pack.xml" target="pack-all.done" inheritall="yes" inheritrefs="yes"/></target>
  <target name="nightly"><optimized name="nightly-nopt"/></target>

  <target name="nightly.checkall">
    <antcall target="nightly-nopt"> <param name="partest.scalac_opts" value="-Ycheck:all"/></antcall></target>

  <target name="clean"     depends="locker.clean"   description="Removes binaries of compiler and library. Distributions are untouched."/>
  <target name="docsclean" depends="docs.clean"     description="Removes generated documentation. Distributions are untouched."/>
  <target name="distclean"   depends="dist.clean"   description="Removes all distributions. Binaries and documentation are untouched."/>

  <macrodef name="optimized" >
    <attribute name="name"/>
    <sequential>
      <antcall target="@{name}"><param name="scalac.args.optimise" value="-optimise"/></antcall>
    </sequential>
  </macrodef>

<!-- ===========================================================================
                                  PROPERTIES
============================================================================ -->

  <property environment="env"/>
  <!-- Prevents system classpath from being used -->
  <property name="build.sysclasspath" value="ignore"/>

  <!-- Defines the repository layout -->
  <property name="docs.dir" value="${basedir}/docs"/>
  <property name="lib.dir" value="${basedir}/lib"/>
  <property name="src.dir" value="${basedir}/src"/>
  <property name="partest.dir" value="${basedir}/test"/>

  <property name="lib-ant.dir" value="${lib.dir}/ant"/>
  <!-- For developers: any jars placed in this dir will be added to the classpath
       of all targets and copied into quick/pack/etc builds. -->
  <property name="lib-extra.dir" value="${lib.dir}/extra"/>

  <!-- Loads custom properties definitions -->
  <property file="${basedir}/build.properties"/>
  <!-- Generating version number -->
  <property file="${basedir}/build.number"/>

  <!-- Sets location of pre-compiled libraries -->
  <property name="library.starr.jar" value="${lib.dir}/scala-library.jar"/>
  <property name="reflect.starr.jar" value="${lib.dir}/scala-reflect.jar"/>
  <property name="compiler.starr.jar" value="${lib.dir}/scala-compiler.jar"/>
  <property name="msil.starr.jar" value="${lib.dir}/msil.jar"/>
  <property name="jline.jar" value="${lib.dir}/jline.jar"/>
  <property name="ant.jar" value="${ant.home}/lib/ant.jar"/>
  <property name="scalacheck.jar" value="${lib.dir}/scalacheck.jar"/>

  <!-- Sets location of build folders -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build-asm.dir" value="${build.dir}/asm"/>
  <property name="build-locker.dir" value="${build.dir}/locker"/>
  <property name="build-palo.dir" value="${build.dir}/palo"/>
  <property name="build-quick.dir" value="${build.dir}/quick"/>
  <property name="build-pack.dir" value="${build.dir}/pack"/>
  <property name="build-osgi.dir" value="${build.dir}/osgi"/>
  <property name="build-strap.dir" value="${build.dir}/strap"/>
  <property name="build-docs.dir" value="${build.dir}/scaladoc"/>
  <property name="build-libs.dir" value="${build.dir}/libs"/>
  <property name="build-sbt.dir" value="${build.dir}/sbt-interface"/>

  <property name="test.osgi.src" value="${partest.dir}/osgi/src"/>
  <property name="test.osgi.classes" value="${build-osgi.dir}/classes"/>

  <property name="dists.dir" value="${basedir}/dists"/>

  <property name="copyright.string" value="Copyright 2002-2013, LAMP/EPFL"/>
  <property name="partest.version.number" value="0.9.2"/>

  <!-- These are NOT the flags used to run SuperSabbus, but the ones written
       into the script runners created with scala.tools.ant.ScalaTool -->
  <property name="java.flags" value="-Xmx256M -Xms32M"/>
  <property name="jvm.opts" value=""/>

  <!-- if ANT_OPTS is already set by the environment, it will be unaltered,
       but if it is unset it will take this default value. -->
  <property name="env.ANT_OPTS" value="-Xms1536M -Xmx1536M -Xss1M -XX:MaxPermSize=192M -XX:+UseParallelGC" />

  <property name="scalacfork.jvmargs" value="${env.ANT_OPTS} ${jvm.opts}"/>

<!-- ===========================================================================
                                  INITIALIZATION
============================================================================ -->
  <target name="desired.jars.uptodate">
    <patternset id="desired.jars">
      <include name="lib/**/*.desired.sha1"/>
      <include name="test/files/**/*.desired.sha1"/>
      <include name="tools/**/*.desired.sha1"/>
    </patternset>

    <uptodate property="lib.jars.uptodate">
      <srcfiles dir="${basedir}"><patternset refid="desired.jars"/></srcfiles>
      <mapper type="glob" from="*.desired.sha1" to="*"/>
    </uptodate>
  </target>

  <target name="boot" depends="desired.jars.uptodate" unless="lib.jars.uptodate">
    <echo level="warn" message="Updating bootstrap libs.  (To do this by hand, run ./pull-binary-libs.sh)"/>
    <exec osfamily="unix" vmlauncher="false" executable="./pull-binary-libs.sh" failifexecutionfails="true" />
    <exec osfamily="windows" vmlauncher="false" executable="pull-binary-libs.sh" failifexecutionfails="true" />
    <!-- uptodate task needs to know these are what's in the sha. -->
    <touch>
      <fileset dir="${basedir}"><patternset refid="desired.jars"/></fileset>
      <mapper type="glob" from="*.desired.sha1" to="*"/>
    </touch>
  </target>

  <target name="init" depends="boot">
    <!-- Set up Ant contrib tasks so we can use <if><then><else> instead of the clunky `unless` attribute -->
    <taskdef resource="net/sf/antcontrib/antlib.xml" classpath="${lib-ant.dir}/ant-contrib.jar"/>

    <!-- Add our maven ant tasks -->
    <path id="maven-ant-tasks.classpath" path="${lib-ant.dir}/maven-ant-tasks-2.1.1.jar" />
    <typedef resource="org/apache/maven/artifact/ant/antlib.xml" uri="urn:maven-artifact-ant" classpathref="maven-ant-tasks.classpath" />

    <!-- work around http://jira.codehaus.org/browse/MANTTASKS-203:
         java.lang.ClassCastException: org.codehaus.plexus.DefaultPlexusContainer cannot be cast to org.codehaus.plexus.PlexusContainer
         on repeated use of artifact:dependencies
    -->
    <if><not><isset property="maven-deps-done"></isset></not><then>
      <artifact:dependencies pathId="extra.tasks.classpath" filesetId="extra.tasks.fileset">
        <dependency groupId="biz.aQute" artifactId="bnd" version="1.50.0"/>
      </artifact:dependencies>

      <!-- Pax runner -->
      <property name="pax.exam.version" value="2.5.0"/>
      <artifact:dependencies pathId="pax.exam.classpath" filesetId="pax.exam.fileset">
        <dependency groupId="org.ops4j.pax.exam" artifactId="pax-exam-container-native" version="${pax.exam.version}"/>
        <dependency groupId="org.ops4j.pax.exam" artifactId="pax-exam-junit4" version="${pax.exam.version}"/>
        <dependency groupId="org.ops4j.pax.exam" artifactId="pax-exam-link-assembly" version="${pax.exam.version}"/>
        <dependency groupId="org.ops4j.pax.url" artifactId="pax-url-aether" version="1.4.0"/>
        <dependency groupId="org.ops4j.pax.swissbox" artifactId="pax-swissbox-framework" version="1.5.1"/>
        <dependency groupId="ch.qos.logback" artifactId="logback-core" version="0.9.20"/>
        <dependency groupId="ch.qos.logback" artifactId="logback-classic" version="0.9.20"/>
        <dependency groupId="junit" artifactId="junit" version="4.10"/>
        <dependency groupId="org.apache.felix" artifactId="org.apache.felix.framework" version="3.2.2"/>
      </artifact:dependencies>

      <!-- BND support -->
      <typedef resource="aQute/bnd/ant/taskdef.properties" classpathref="extra.tasks.classpath" />

      <!-- Resolve maven dependencies -->
      <mkdir dir="${user.home}/.m2/repository"/>
      <!-- This task has an issue where if the user directory does not exist, so we create it above. UGH. -->
      <artifact:dependencies pathId="dependency.classpath" filesetId="dependency.fileset">
        <!--<dependency groupId="com.typesafe" artifactId="config" version="0.4.0"/>-->
      </artifact:dependencies>

      <!-- Download STARR via maven if `starr.version` is specified.
           Want to slow down STARR changes, using only released versions. -->
      <if><isset property="starr.version"/><then>
        <artifact:dependencies pathId="starr.core.path">
          <dependency groupId="org.scala-lang" artifactId="scala-library" version="${starr.version}"/>
          <dependency groupId="org.scala-lang" artifactId="scala-reflect" version="${starr.version}"/>
          <dependency groupId="org.scala-lang" artifactId="scala-compiler" version="${starr.version}"/>
        </artifact:dependencies>
      </then></if>

      <property name="maven-deps-done" value="yep!"/>
    </then></if>

    <!-- NOTE: ant properties are write-once: second writes are silently discarded; the logic below relies on this -->

    <!-- Compute defaults (i.e., if not specified on command-line) for OSGi/maven version suffixes.
      Try to establish the invariant (verified below):
      `version.suffix == maven.version.suffix == osgi.version.suffix`,
      except for:
        - snapshot builds, where:
          - `maven.suffix == "-SNAPSHOT"`
          - `version.suffix == osgi.version.suffix == ""`
        - final builds, where:
          - `osgi.suffix == "-VFINAL"`
          - `version.suffix == maven.version.suffix == ""`
    -->
    <if><not><equals arg1="${version.bnum}" arg2="0"/></not><then>
      <property name="version.suffix" value="-${version.bnum}"/>
    </then></if>

    <if><or><not><isset property="version.suffix"/></not><equals arg1="${version.suffix}" arg2=""/></or><then>
      <if><isset property="build.release"/><then>
        <property name="maven.version.suffix" value=""/>
        <property name="version.suffix" value="${maven.version.suffix}"/>
        <if><equals arg1="${maven.version.suffix}" arg2=""/><then>
          <property name="osgi.version.suffix" value="-VFINAL"/></then>
        <else>
          <property name="osgi.version.suffix" value="${maven.version.suffix}"/></else></if></then></if></then>
    <else> <!-- version.suffix set and not empty -->
      <property name="maven.version.suffix" value="${version.suffix}"/>
      <property name="osgi.version.suffix"  value="${version.suffix}"/></else></if>

    <!-- not building a release and no version.suffix specified -->
    <property name="maven.version.suffix" value="-SNAPSHOT"/>

    <if><equals arg1="${maven.version.suffix}" arg2="-SNAPSHOT"/><then>
      <property name="osgi.version.suffix" value=""/>
      <property name="version.suffix" value=""/></then>
    <else>
      <property name="osgi.version.suffix" value="${maven.version.suffix}"/>
      <property name="version.suffix" value="${maven.version.suffix}"/></else></if>


    <exec osfamily="unix" executable="tools/get-scala-commit-sha" outputproperty="git.commit.sha" failifexecutionfails="false" />
    <exec osfamily="windows" executable="cmd.exe" outputproperty="git.commit.sha" failifexecutionfails="false">
      <arg value="/c"/>
      <arg value="tools\get-scala-commit-sha.bat"/>
      <arg value="-p"/>
    </exec>
    <exec osfamily="unix" executable="tools/get-scala-commit-date" outputproperty="git.commit.date" failifexecutionfails="false" />
    <exec osfamily="windows" executable="cmd.exe" outputproperty="git.commit.date" failifexecutionfails="false">
      <arg value="/c"/>
      <arg value="tools\get-scala-commit-date.bat"/>
      <arg value="-p"/>
    </exec>

    <!-- some default in case something went wrong getting the revision -->
    <property name="git.commit.sha" value="unknown"/>
    <property name="git.commit.date" value="unknown"/>

    <!-- We use the git describe to determine the OSGi modifier for our build. -->
    <property name="maven.version.number"
      value="${version.major}.${version.minor}.${version.patch}${maven.version.suffix}"/>
    <property name="osgi.version.number"
      value="${version.major}.${version.minor}.${version.patch}.v${git.commit.date}${osgi.version.suffix}-${git.commit.sha}"/>

    <if><isset property="build.release"/><then>
      <property name="version.number" value="${maven.version.number}"/>
    </then><else>
      <property name="version.number" value="${version.major}.${version.minor}.${version.patch}${version.suffix}-${git.commit.date}-${git.commit.sha}"/>
    </else></if>

    <condition property="has.java6">
        <equals arg1="${ant.java.version}" arg2="1.6"/>
    </condition>
    <condition property="has.java7">
        <equals arg1="${ant.java.version}" arg2="1.7"/>
    </condition>
    <condition property="has.unsupported.jdk">
       <not><or>
         <isset property="has.java7" />
         <isset property="has.java6" />
       </or></not>
    </condition>

    <fail if="has.unsupported.jdk" message="JDK ${ant.java.version} is not supported by this build!"/>

    <if><isset property="has.java7"/><then>
      <echo level="warning"> You are using JDK7 for this build.
        While this will be able to build most of Scala, it will not build the Swing project.
        You will be unable to create a distribution.
      </echo>
    </then></if>

    <!-- Allow this to be overridden simply -->
    <property name="sbt.latest.version" value="0.12.2"/>

    <property name="sbt.src.dir" value="${build-sbt.dir}/${sbt.latest.version}/src"/>
    <property name="sbt.lib.dir" value="${build-sbt.dir}/${sbt.latest.version}/lib"/>

    <property name="sbt.interface.jar" value="${sbt.lib.dir}/interface.jar"/>
    <property name="sbt.interface.url" value="http://typesafe.artifactoryonline.com/typesafe/ivy-releases/org.scala-sbt/interface/${sbt.latest.version}/jars/interface.jar"/>
    <property name="sbt.interface.src.jar" value="${sbt.src.dir}/compiler-interface-src.jar"/>
    <property name="sbt.interface.src.url" value="http://typesafe.artifactoryonline.com/typesafe/ivy-releases/org.scala-sbt/compiler-interface/${sbt.latest.version}/jars/compiler-interface-src.jar"/>


    <!-- Additional command line arguments for scalac. They are added to all build targets -->
    <property name="scalac.args" value=""/>
    <property name="javac.args" value=""/>

    <property name="scalac.args.always" value="" />
    <property name="scalac.args.optimise" value=""/> <!-- scalac.args.optimise is selectively overridden in certain antcall tasks. -->
    <property name="scalac.args.all" value="${scalac.args.always} ${scalac.args} ${scalac.args.optimise}"/>
    <property name="scalac.args.locker" value="${scalac.args.all}"/>
    <property name="scalac.args.quick" value="${scalac.args.all}"/>
    <property name="scalac.args.strap" value="${scalac.args.quick}"/>

    <!-- This is the start time for the distribution -->
    <tstamp prefix="time">
      <format property="human" pattern="d MMMM yyyy, HH:mm:ss" locale="en,US"/>
      <format property="short" pattern="yyyyMMddHHmmss"/>
    </tstamp>

    <!-- some default in case something went wrong getting the revision -->
    <property name="version.number" value="-unknown-"/>
    <property name="init.avail" value="yes"/>

    <!-- Local libs (developer use.) -->
    <mkdir dir="${lib-extra.dir}"/>

    <!-- Auxiliary libs placed on every classpath. -->
    <path id="aux.libs">
      <pathelement location="${ant.jar}"/>
      <!-- needs ant 1.7.1 -->
      <!-- <fileset dir="${lib-extra.dir}" erroronmissingdir="false"> -->
      <fileset dir="${lib-extra.dir}">
        <include name="**/*.jar"/>
      </fileset>
      <path refid="dependency.classpath"/>
    </path>

    <!-- And print-out what we are building -->
    <echo message="       build time: ${time.human}" />
    <echo message="     java version: ${java.vm.name} ${java.version} (${ant.java.version})" />
    <echo message="        java args: ${env.ANT_OPTS} ${jvm.opts}" />
    <echo message="       javac args: ${javac.args}" />
    <echo message="      scalac args: ${scalac.args.all}" />
    <echo message="scalac quick args: ${scalac.args.quick}" />
    <echo message="         git date: ${git.commit.date}" />
    <echo message="         git hash: ${git.commit.sha}" />
    <echo message="    maven version: ${maven.version.number}"/>
    <echo message="     OSGi version: ${osgi.version.number}" />
    <echo message="canonical version: ${version.number}" />

    <!-- validate version suffixes -->
    <if><equals arg1="${maven.version.suffix}" arg2="-SNAPSHOT"/><then>
      <condition property="version.suffixes.consistent"><and>
        <equals arg1="${osgi.version.suffix}" arg2=""/>
        <equals arg1="${version.suffix}" arg2=""/>
      </and></condition></then>
    <else>
      <if><equals arg1="${osgi.version.suffix}" arg2="-VFINAL"/><then>
        <condition property="version.suffixes.consistent"><and>
          <equals arg1="${maven.version.suffix}" arg2=""/>
          <equals arg1="${version.suffix}" arg2=""/>
        </and></condition></then>
      <else>
        <condition property="version.suffixes.consistent"><and>
          <equals arg1="${osgi.version.suffix}" arg2="${maven.version.suffix}"/>
          <equals arg1="${version.suffix}" arg2="${maven.version.suffix}"/>
        </and></condition></else></if></else></if>

    <!-- <echo message="    maven suffix: ${maven.version.suffix}"/>
    <echo message="     OSGi suffix: ${osgi.version.suffix}" />
    <echo message="canonical suffix: ${version.suffix}" /> -->
    <fail unless="version.suffixes.consistent" message="Version suffixes inconsistent!"/>

    <path id="forkjoin.classpath" path="${build-libs.dir}/classes/forkjoin"/>
    <path id="fjbg.classpath"     path="${build-libs.dir}/classes/fjbg"/>
    <path id="asm.classpath"      path="${build-asm.dir}/classes/"/>

    <!-- Compilers to use for the various stages.

      There must be a variable of the shape @{stage}.compiler.path  for all @{stage} in starr, locker, quick, strap.
    -->
    <path id="starr.compiler.path">
      <path refid="starr.core.path"/>
      <pathelement location="${lib.dir}/forkjoin.jar"/>
      <path refid="aux.libs"/>
    </path>

    <!-- Download STARR (see above) via maven if `starr.version` is specified.
         Want to slow down STARR changes, using only released versions. -->
    <if><isset property="starr.version"/><then>
      <property name="strr" refid="starr.compiler.path"/>
      <echo message="Using Scala ${starr.version} for STARR."/>
      <!-- <echo message="STARR classpath: ${strr}"/> -->
    </then><else>
      <path id="starr.core.path">
        <pathelement location="${library.starr.jar}"/>
        <pathelement location="${reflect.starr.jar}"/>
        <pathelement location="${compiler.starr.jar}"/>
        <pathelement location="${msil.starr.jar}"/>
      </path>
    </else></if>

    <!-- Skip locker with -Dlocker.skip=YESSIR. Uses STARR instead. -->
    <if><isset property="locker.skip"/><then>
      <echo message="Skipping locker! Using STARR instead."/>
      <path id="locker.compiler.path"><path refid="starr.compiler.path"/></path>
      <property name="locker.locked" value="locker skipped"/></then>
    <else>
      <path id="locker.compiler.path"><path refid="locker.compiler.build.path"/></path></else></if>

    <!-- compilerpathref for compiling with quick -->
    <path id="quick.compiler.path"> <path refid="quick.compiler.build.path"/></path>


    <!-- What to have on the compilation path when compiling during certain phases.

      There must be a variable of the shape @{stage}.@{project}.build.path
      for all @{stage} in locker, quick, strap
      and all @{project} in library, reflect, compiler
        when stage is quick, @{project} also includes: actors, swing, plugins, scalacheck, partest, scalap
    -->

    <!-- LOCKER -->
    <path id="locker.library.build.path">
      <pathelement location="${build-locker.dir}/classes/library"/>
      <path refid="forkjoin.classpath"/>
      <path refid="aux.libs"/>
    </path>

    <path id="locker.reflect.build.path">
      <path refid="locker.library.build.path"/>
      <pathelement location="${build-locker.dir}/classes/reflect"/>
    </path>

    <path id="locker.compiler.build.path">
      <path refid="locker.reflect.build.path"/>
      <pathelement location="${build-locker.dir}/classes/compiler"/>
      <path refid="asm.classpath"/>
      <path refid="fjbg.classpath"/>
      <pathelement location="${jline.jar}"/>
    </path>

    <path id="locker.msil.build.path" refid="locker.compiler.build.path"/>

    <!-- QUICK -->
    <path id="quick.library.build.path">
      <pathelement location="${build-quick.dir}/classes/library"/>
      <path refid="forkjoin.classpath"/>
      <path refid="aux.libs"/>
    </path>

    <path id="quick.actors.build.path"><path refid="quick.library.build.path"/></path>

    <path id="quick.reflect.build.path">
      <path refid="quick.library.build.path"/>
      <pathelement location="${build-quick.dir}/classes/reflect"/>
    </path>

    <path id="quick.compiler.build.path">
      <path refid="quick.reflect.build.path"/>
      <pathelement location="${build-quick.dir}/classes/compiler"/>
      <path refid="asm.classpath"/>
      <path refid="fjbg.classpath"/>
      <pathelement location="${jline.jar}"/>
    </path>

    <path id="quick.swing.build.path" refid="quick.library.build.path"/>
    <path id="quick.msil.build.path" refid="quick.compiler.build.path"/>

    <path id="quick.plugins.build.path">
      <path refid="quick.compiler.build.path"/>
      <pathelement location="${build-quick.dir}/classes/continuations-plugin"/>
    </path>

    <path id="quick.scalacheck.build.path">
      <pathelement location="${build-quick.dir}/classes/library"/>
      <pathelement location="${build-quick.dir}/classes/scalacheck"/>
    </path>

    <path id="quick.scalap.build.path">
      <path refid="quick.compiler.build.path"/>
      <pathelement location="${build-quick.dir}/classes/scalap"/>
      <pathelement location="${build-quick.dir}/classes/partest"/>
    </path>

    <path id="quick.partest.build.path">
      <path refid="quick.scalap.build.path"/>
      <pathelement location="${scalacheck.jar}"/>
    </path>

    <path id="quick.bin.tool.path">
      <pathelement location="${build-quick.dir}/classes/library"/>
      <pathelement location="${build-quick.dir}/classes/reflect"/>
      <pathelement location="${build-quick.dir}/classes/compiler"/>
      <pathelement location="${build-quick.dir}/classes/scalap"/>
      <pathelement location="${build-quick.dir}/classes/continuations-library"/>
      <pathelement location="${jline.jar}"/>
      <path refid="asm.classpath"/>
      <path refid="forkjoin.classpath"/>
      <path refid="aux.libs"/>
     </path>

    <!-- PACK -->
    <path id="pack.compiler.path">
      <pathelement location="${build-pack.dir}/lib/scala-library.jar"/>
      <pathelement location="${build-pack.dir}/lib/scala-reflect.jar"/>
      <pathelement location="${build-pack.dir}/lib/scala-compiler.jar"/>
      <pathelement location="${build-pack.dir}/lib/scala-partest.jar"/>
      <pathelement location="${build-pack.dir}/lib/scalap.jar"/>
      <pathelement location="${build-pack.dir}/lib/scala-actors.jar"/>
      <pathelement location="${ant.jar}"/>
      <pathelement location="${jline.jar}"/>
      <path refid="aux.libs"/>
    </path>

    <path id="pack.bin.tool.path">
      <pathelement location="${build-pack.dir}/lib/scala-library.jar"/>
      <pathelement location="${build-pack.dir}/lib/scala-reflect.jar"/>
      <pathelement location="${build-pack.dir}/lib/scala-compiler.jar"/>
      <pathelement location="${build-pack.dir}/lib/scalap.jar"/>
      <pathelement location="${build-pack.dir}/lib/jline.jar"/>
      <path refid="aux.libs"/>
    </path>


    <!-- STRAP -->
    <path id="strap.library.build.path">
      <pathelement location="${build-strap.dir}/classes/library"/>
      <path refid="forkjoin.classpath"/>
      <path refid="aux.libs"/>
    </path>
    <path id="strap.actors.build.path" refid="strap.library.build.path"/>
    <path id="strap.msil.build.path" refid="strap.compiler.build.path"/>

    <path id="strap.reflect.build.path">
      <path refid="strap.library.build.path"/>
      <pathelement location="${build-strap.dir}/classes/reflect"/>
    </path>

    <path id="strap.compiler.build.path">
      <path refid="strap.reflect.build.path"/>
      <pathelement location="${build-strap.dir}/classes/compiler"/>
      <path refid="asm.classpath"/>
      <path refid="fjbg.classpath"/>
      <pathelement location="${jline.jar}"/>
    </path>

    <!-- MISC -->
    <path id="sbt.compile.build.path">
      <path refid="quick.compiler.build.path"/>
      <pathelement location="${sbt.interface.jar}"/>
    </path>

    <path id="manual.classpath">
      <pathelement location="${build-pack.dir}/lib/scala-library.jar"/>
      <pathelement location="${build.dir}/manmaker/classes"/>
    </path>

    <path id="partest.classpath">
      <path refid="pack.compiler.path"/>
      <fileset dir="${partest.dir}/files/lib" includes="*.jar" />
      <pathelement location="${pack.dir}/lib/scala-swing.jar"/> <!-- TODO - segregate swing tests (there can't be many) -->
    </path>

    <path id="test.osgi.compiler.build.path">
      <pathelement location="${test.osgi.classes}"/>
      <pathelement location="${build-osgi.dir}/org.scala-lang.scala-library.jar"/>
      <pathelement location="${build-osgi.dir}/org.scala-lang.scala-reflect.jar"/>
      <pathelement location="${build-osgi.dir}/org.scala-lang.scala-compiler.jar"/>
      <pathelement location="${build-osgi.dir}/org.scala-lang.scala-actors.jar"/>
      <path refid="pax.exam.classpath"/>
      <path refid="forkjoin.classpath"/>
    </path>

    <path id="palo.bin.tool.path">
      <pathelement location="${build-palo.dir}/lib/scala-library.jar"/>
      <pathelement location="${build-palo.dir}/lib/scala-reflect.jar"/>
      <pathelement location="${build-palo.dir}/lib/scala-compiler.jar"/>
      <pathelement location="${build-palo.dir}/lib/jline.jar"/>
    </path>

    <path id="test.positions.sub.build.path" path="${build-quick.dir}/classes/library"/>

    <!-- TODO: consolidate *.includes -->
    <patternset id="partest.includes">
      <include name="**/*.xml"/>
    </patternset>

    <patternset id="lib.includes">
      <include name="**/*.tmpl"/>
      <include name="**/*.xml"/>
      <include name="**/*.js"/>
      <include name="**/*.css"/>
    </patternset>

    <patternset id="lib.rootdoc.includes">
      <include name="**/*.tmpl"/>
      <include name="**/*.xml"/>
      <include name="**/*.js"/>
      <include name="**/*.css"/>
      <include name="rootdoc.txt"/>
    </patternset>

    <patternset id="comp.includes">
      <include name="**/*.tmpl"/>
      <include name="**/*.xml"/>
      <include name="**/*.js"/>
      <include name="**/*.css"/>
      <include name="**/*.html"/>
      <include name="**/*.properties"/>
      <include name="**/*.swf"/>
      <include name="**/*.png"/>
      <include name="**/*.gif"/>
      <include name="**/*.txt"/>
    </patternset>

    <taskdef resource="scala/tools/ant/sabbus/antlib.xml" classpathref="starr.compiler.path"/>
  </target>

<!-- ===========================================================================
                                  CLEANLINESS
=============================================================================-->
  <target name="libs.clean">                        <clean build="libs"/> <clean build="asm"/>                            </target>
  <target name="quick.clean"  depends="libs.clean">   <clean build="quick"/> <clean build="pack"/> <clean build="strap"/> </target>
  <target name="palo.clean"   depends="quick.clean">    <clean build="palo"/>                                             </target>
  <target name="locker.clean" depends="palo.clean">       <clean build="locker"/>                                         </target>

  <target name="docs.clean"> <clean build="docs"/> <delete dir="${build.dir}/manmaker" includeemptydirs="yes" quiet="yes" failonerror="no"/> </target>
  <target name="dist.clean"> <delete dir="${dists.dir}" includeemptydirs="yes" quiet="yes" failonerror="no"/> </target>

  <target name="all.clean" depends="locker.clean, docs.clean"> <clean build="sbt"/> <clean build="osgi"/> </target>

  <!-- Used by the scala-installer script -->
  <target name="allallclean" depends="all.clean, dist.clean"/>

  <macrodef name="clean">
    <attribute name="build"/>
    <sequential>
      <delete dir="${build-@{build}.dir}" includeemptydirs="yes" quiet="yes" failonerror="no"/>
    </sequential>
  </macrodef>

<!-- ===========================================================================
                                  LOCAL DEPENDENCY (FJBG)
============================================================================ -->
  <target name="fjbg.done" depends="init">
    <uptodate property="fjbg.available" targetfile="${build-libs.dir}/fjbg.complete">
      <srcfiles dir="${src.dir}/forkjoin"/></uptodate>
    <if><not><isset property="fjbg.available"/></not><then>
      <stopwatch name="fjbg.lib.timer"/>
      <mkdir dir="${build-libs.dir}/classes/fjbg"/>
      <javac
        srcdir="${src.dir}/fjbg"
        destdir="${build-libs.dir}/classes/fjbg"
        classpath="${build-libs.dir}/classes/fjbg"
        includes="**/*.java"
        target="1.6" source="1.5">
          <compilerarg line="${javac.args}"/>
      </javac>
      <jar whenmanifestonly="fail" destfile="${build-libs.dir}/fjbg.jar" basedir="${build-libs.dir}/classes/fjbg"/>
      <stopwatch name="fjbg.lib.timer" action="total"/>
      <touch file="${build-libs.dir}/fjbg.complete" verbose="no"/>
    </then></if>
  </target>

<!-- ===========================================================================
                                  LOCAL DEPENDENCY (Adapted ASM)
============================================================================ -->
  <target name="asm.done" depends="init">
    <available file="${build-asm.dir}/asm.complete" property="asm.available"/>
    <if><not><isset property="asm.available"/></not><then>
      <stopwatch name="asm.lib.timer"/>
      <mkdir dir="${build-asm.dir}/classes/"/>
      <javac
        srcdir="${src.dir}/asm"
        destdir="${build-asm.dir}/classes"
        classpath="${build-asm.dir}/classes"
        includes="**/*.java"
        target="1.6" source="1.5">
          <compilerarg line="${javac.args} -XDignore.symbol.file"/>
      </javac>
      <stopwatch name="asm.lib.timer" action="total"/>
      <touch file="${build-asm.dir}/asm.complete" verbose="no"/>
    </then></if>
  </target>

<!-- ===========================================================================
                                  LOCAL DEPENDENCY (FORKJOIN)
============================================================================ -->
  <target name="forkjoin.done" depends="init">
    <uptodate property="forkjoin.available" targetfile="${build-libs.dir}/forkjoin.complete">
      <srcfiles dir="${src.dir}/forkjoin"/></uptodate>
    <if><not><isset property="forkjoin.available"/></not><then>
      <stopwatch name="forkjoin.lib.timer"/>
      <mkdir dir="${build-libs.dir}/classes/forkjoin"/>
      <javac
        fork="yes"
        compiler="javac1.6"
        srcdir="${src.dir}/forkjoin"
        destdir="${build-libs.dir}/classes/forkjoin"
        classpath="${build-libs.dir}/classes/forkjoin"
        includes="**/*.java"
        debug="true"
        target="1.6" source="1.5">
          <compilerarg line="${javac.args} -XDignore.symbol.file"/>
      </javac>
      <jar whenmanifestonly="fail" destfile="${build-libs.dir}/forkjoin.jar" basedir="${build-libs.dir}/classes/forkjoin"/>
      <stopwatch name="forkjoin.lib.timer" action="total"/>
      <touch file="${build-libs.dir}/forkjoin.complete" verbose="no"/>
    </then></if>
  </target>

<!-- ===========================================================================
                                  STAGED COMPILATION MACROS
============================================================================ -->
  <macrodef name="staged-javac" >
    <attribute name="stage"/>    <!-- current stage (locker, quick, strap) -->
    <attribute name="project"/>  <!-- project: library/reflect/compiler/actors -->
    <attribute name="destproject" default="@{project}"/> <!-- overrides the output directory; used when building multiple projects into the same directory-->
    <attribute name="args" default=""/>
    <attribute name="excludes" default=""/>

    <sequential>
      <javac
        srcdir="${src.dir}/@{project}"
        destdir="${build-@{stage}.dir}/classes/@{destproject}"
        includes="**/*.java"
        excludes="@{excludes}"
        target="1.6" source="1.5">
          <compilerarg line="${javac.args} @{args}"/>
          <classpath refid="@{stage}.@{destproject}.build.path"/>
      </javac>
    </sequential>
  </macrodef>

  <macrodef name="staged-scalac" >
    <attribute name="with"/>           <!-- will use path `@{with}.compiler.path` to locate scalac -->
    <attribute name="stage"/>          <!-- current stage (locker, quick, strap) -->
    <attribute name="project"/>        <!-- project: library/reflect/compiler/actors -->
    <attribute name="srcpath" default="NOT SET"/>        <!-- needed to compile the library -->
    <attribute name="args" default=""/>                  <!-- additional args -->
    <attribute name="destproject" default="@{project}"/> <!-- overrides the output directory; used when building multiple projects into the same directory-->
    <attribute name="srcdir" default="@{project}"/>
    <element name="args" implicit="true" optional="true"/>

    <sequential>
      <if><equals arg1="@{srcpath}" arg2="NOT SET"/><then>
        <scalacfork taskname="@{stage}.@{project}"
          destdir="${build-@{stage}.dir}/classes/@{destproject}"
          compilerpathref="@{with}.compiler.path"
          params="${scalac.args.@{stage}} @{args}"
          srcdir="${src.dir}/@{srcdir}"
          jvmargs="${scalacfork.jvmargs}">
          <include name="**/*.scala"/>
          <compilationpath refid="@{stage}.@{project}.build.path"/>
          <args/>
        </scalacfork></then>
      <else>
        <scalacfork taskname="@{stage}.@{project}"
          destdir="${build-@{stage}.dir}/classes/@{destproject}"
          compilerpathref="@{with}.compiler.path"
          srcpath="@{srcpath}"
          params="${scalac.args.@{stage}} @{args}"
          srcdir="${src.dir}/@{srcdir}"
          jvmargs="${scalacfork.jvmargs}">
          <include name="**/*.scala"/>
          <compilationpath refid="@{stage}.@{project}.build.path"/>
          <args/>
        </scalacfork></else>
      </if>
    </sequential>
  </macrodef>

  <macrodef name="staged-uptodate" >
    <attribute name="stage"/>
    <attribute name="project"/>
    <element name="check"/>
    <element name="do"/>

    <sequential>
      <uptodate property="@{stage}.@{project}.available" targetfile="${build-@{stage}.dir}/@{project}.complete">
        <check/>
      </uptodate>
      <if><not><isset property="@{stage}.@{project}.available"/></not><then>
        <do/>
        <touch file="${build-@{stage}.dir}/@{project}.complete" verbose="no"/>
      </then></if>
    </sequential>
  </macrodef>

  <macrodef name="staged-build" >
    <attribute name="with"/>           <!-- will use path `@{with}.compiler.path` to locate scalac -->
    <attribute name="stage"/>          <!-- current stage (locker, quick, strap) -->
    <attribute name="project"/>        <!-- project: library/reflect/compiler/actors -->
    <attribute name="srcpath"       default="NOT SET"/>        <!-- needed to compile the library -->
    <attribute name="args"          default=""/>                  <!-- additional args -->
    <attribute name="includes"      default="comp.includes"/>
    <attribute name="version"       default=""/> <!-- non-empty for partest and scaladoc: use @{version}.version.number in property file-->

    <element name="pre" optional="true"/>
    <element name="post" optional="true"/>

    <sequential>
      <staged-uptodate stage="@{stage}" project="@{project}">
        <check><srcfiles dir="${src.dir}/@{project}"/></check>
        <do>
          <stopwatch name="@{stage}.@{project}.timer"/>
          <mkdir dir="${build-@{stage}.dir}/classes/@{project}"/>
          <pre/>
          <staged-scalac with="@{with}" stage="@{stage}" project="@{project}" srcpath="@{srcpath}" args="@{args}"/>
          <post/>
          <if><equals arg1="@{version}" arg2=""/><then>
            <propertyfile file = "${build-@{stage}.dir}/classes/@{project}/@{project}.properties">
              <entry key       = "version.number" value="${version.number}"/>
              <entry key       = "maven.version.number" value="${maven.version.number}"/>
              <entry key       = "osgi.version.number" value="${osgi.version.number}"/>
              <entry key       = "copyright.string" value="${copyright.string}"/>
            </propertyfile>
          </then><else>
            <propertyfile file = "${build-@{stage}.dir}/classes/@{project}/@{project}.properties">
              <entry key       = "version.number" value="${@{version}.version.number}"/>
              <entry key       = "copyright.string" value="${copyright.string}"/>
            </propertyfile>
          </else></if>
          <copy todir="${build-@{stage}.dir}/classes/@{project}">
            <fileset dir="${src.dir}/@{project}">
              <patternset refid="@{includes}"/>
            </fileset>
          </copy>
          <stopwatch name="@{stage}.@{project}.timer" action="total"/>
        </do>
      </staged-uptodate>
    </sequential>
  </macrodef>

  <macrodef name="staged-bin">
    <attribute name="stage"/>
    <attribute name="classpathref" default="NOT SET"/>
    <sequential>
      <staged-uptodate stage="@{stage}" project="bin">
        <check>
          <srcfiles dir="${src.dir}">
            <include name="compiler/scala/tools/ant/templates/**"/>
          </srcfiles>
        </check>
        <do>
          <taskdef name="mk-bin" classname="scala.tools.ant.ScalaTool" classpathref="@{stage}.bin.tool.path"/>
          <mkdir dir="${build-@{stage}.dir}/bin"/>
          <if><equals arg1="@{classpathref}" arg2="NOT SET"/><then>
            <mk-bin file="${build-@{stage}.dir}/bin/scala"    class="scala.tools.nsc.MainGenericRunner" javaFlags="${java.flags}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/scalac"   class="scala.tools.nsc.Main"              javaFlags="${java.flags}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/scaladoc" class="scala.tools.nsc.ScalaDoc"          javaFlags="${java.flags}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/fsc"      class="scala.tools.nsc.CompileClient"     javaFlags="${java.flags}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/scalap"   class="scala.tools.scalap.Main"           javaFlags="${java.flags}"/>
          </then><else>
            <mk-bin file="${build-@{stage}.dir}/bin/scala"    class="scala.tools.nsc.MainGenericRunner" javaFlags="${java.flags}" classpathref="@{classpathref}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/scalac"   class="scala.tools.nsc.Main"              javaFlags="${java.flags}" classpathref="@{classpathref}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/scaladoc" class="scala.tools.nsc.ScalaDoc"          javaFlags="${java.flags}" classpathref="@{classpathref}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/fsc"      class="scala.tools.nsc.CompileClient"     javaFlags="${java.flags}" classpathref="@{classpathref}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/scalap"   class="scala.tools.scalap.Main"           javaFlags="${java.flags}" classpathref="@{classpathref}"/>
          </else></if>
          <chmod perm="ugo+rx" file="${build-@{stage}.dir}/bin/scala"/>
          <chmod perm="ugo+rx" file="${build-@{stage}.dir}/bin/scalac"/>
          <chmod perm="ugo+rx" file="${build-@{stage}.dir}/bin/scaladoc"/>
          <chmod perm="ugo+rx" file="${build-@{stage}.dir}/bin/fsc"/>
          <chmod perm="ugo+rx" file="${build-@{stage}.dir}/bin/scalap"/>
        </do>
      </staged-uptodate>
    </sequential>
  </macrodef>

  <macrodef name="staged-pack">
    <attribute name="project"/>
    <attribute name="targetdir" default="lib"/>
    <attribute name="targetjar" default="scala-@{project}.jar"/>
    <element name="do" implicit="true"/>

    <sequential>
      <uptodate property="pack.@{project}.available"
        targetfile="${build-pack.dir}/@{targetdir}/@{targetjar}"
        srcfile="${build-quick.dir}/@{project}.complete"/>
      <if><not><isset property="pack.@{project}.available"/></not><then>
        <mkdir dir="${build-pack.dir}/@{targetdir}"/>
        <do/>
      </then></if>
    </sequential>
  </macrodef>

  <macrodef name="staged-docs">
    <attribute name="project"/>
    <attribute name="dir" default="@{project}"/>
    <attribute name="title"/>
    <attribute name="docroot" default="NOT SET"/>
    <element name="includes" implicit="true"/>

    <sequential>
      <staged-uptodate stage="docs" project="@{project}">
        <check><srcfiles dir="${src.dir}/@{dir}"/></check>
        <do>
          <stopwatch name="docs.@{project}.timer"/>
          <mkdir dir="${build-docs.dir}/@{project}"/>
          <if><equals arg1="@{classpathref}" arg2="NOT SET"/><then>
            <scaladoc
              destdir="${build-docs.dir}/@{project}"
              doctitle="@{title}"
              docversion="${version.number}"
              sourcepath="${src.dir}"
              classpathref="pack.compiler.path"
              srcdir="${src.dir}/@{dir}"
              addparams="${scalac.args.all}"
              implicits="on"
              diagrams="on"
              groups="on"
              rawOutput="${scaladoc.raw.output}"
              noPrefixes="${scaladoc.no.prefixes}">
              <includes/>
            </scaladoc>
          </then><else>
            <scaladoc
              destdir="${build-docs.dir}/@{project}"
              doctitle="@{title}"
              docversion="${version.number}"
              sourcepath="${src.dir}"
              classpathref="pack.compiler.path"
              srcdir="${src.dir}/@{dir}"
              docRootContent="${src.dir}/@{project}/@{docroot}"
              addparams="${scalac.args.all}"
              implicits="on"
              diagrams="on"
              groups="on"
              rawOutput="${scaladoc.raw.output}"
              noPrefixes="${scaladoc.no.prefixes}">
              <includes/>
            </scaladoc>
          </else></if>
          <stopwatch name="docs.@{project}.timer" action="total"/>
        </do>
      </staged-uptodate>
    </sequential>
  </macrodef>

<!-- ===========================================================================
                                  LOCAL REFERENCE BUILD (LOCKER)
============================================================================ -->
  <target name="locker.start" depends="asm.done, forkjoin.done, fjbg.done">
    <condition property="locker.locked"><available file="${build-locker.dir}/locker.locked"/></condition></target>

  <target name="locker.lib"     depends="locker.start" unless="locker.locked">
    <staged-build with="starr" stage="locker" project="library" srcpath="${src.dir}/library" includes="lib.includes">
            <pre><staged-javac stage="locker" project="library" args="-XDignore.symbol.file"/></pre></staged-build></target>
            <!-- TODO: args="-XDignore.symbol.file" necessary?? -->

  <target name="locker.reflect" depends="locker.lib"     unless="locker.locked"> <staged-build with="starr" stage="locker" project="reflect"/></target>
  <target name="locker.comp"    depends="locker.reflect" unless="locker.locked">
    <staged-build with="starr" stage="locker" project="compiler">
      <pre>
        <staged-javac stage="locker" project="msil" destproject="compiler" excludes="**/tests/**"/>
        <staged-scalac with="starr" stage="locker" project="msil" destproject="compiler"/>
      </pre>
    </staged-build>
  </target>

  <target name="locker.done"    depends="locker.comp">
    <mkdir dir="${build-locker.dir}"/>
    <touch file="${build-locker.dir}/locker.locked" verbose="no"/>
  </target>
  <target name="locker.unlock"> <delete file="${build-locker.dir}/locker.locked"/>
                                <delete file="${build-locker.dir}/*.complete"/></target>

<!-- ===========================================================================
                                  QUICK BUILD (QUICK)
============================================================================ -->
  <target name="quick.start" depends="locker.done"/>

  <target name="quick.lib" depends="quick.start">
    <staged-build with="locker" stage="quick" project="library" srcpath="${src.dir}/library" includes="lib.rootdoc.includes">
      <pre>
        <staged-javac stage="quick" project="library" args="-XDignore.symbol.file"/> <!-- TODO: args="-XDignore.symbol.file" necessary?? -->
        <staged-javac stage="quick" project="actors" destproject="library"/>
      </pre>
      <post>
        <staged-scalac with="locker" stage="quick" project="actors" destproject="library"/>
      </post>
    </staged-build>
  </target>

  <target name="quick.reflect" depends="quick.lib"> <staged-build with="locker" stage="quick" project="reflect"/> </target>

  <target name="quick.comp" depends="quick.reflect">
    <staged-build with="locker" stage="quick" project="compiler">
      <pre>
        <staged-javac stage="quick" project="msil" destproject="compiler" excludes="**/tests/**"/>
        <staged-scalac with="locker" stage="quick" project="msil" destproject="compiler"/>
      </pre>
    </staged-build>
  </target>

  <target name="quick.scalacheck" depends="quick.lib">
    <staged-build with="locker" stage="quick" project="scalacheck" args="-nowarn"/>
  </target>

  <target name="quick.scalap" depends="quick.comp">
    <staged-build with="locker" stage="quick" project="scalap"/>
  </target>

  <target name="quick.partest" depends="quick.scalap, quick.comp, asm.done">
    <staged-build with="locker" stage="quick" project="partest" version="partest">
      <pre><staged-javac stage="quick" project="partest"/></pre>
    </staged-build>
  </target>

  <target name="quick.swing" depends="quick.lib" if="has.java6">
    <staged-build with="locker" stage="quick" project="swing"/>
  </target>

  <target name="quick.plugins" depends="quick.comp">
    <staged-uptodate stage="quick" project="plugins">
      <check><srcfiles dir="${src.dir}/continuations"/></check>
      <do>
        <stopwatch name="quick.plugins.timer"/>

        <mkdir dir="${build-quick.dir}/classes/continuations-plugin"/>
        <staged-scalac with="locker" stage="quick" project="plugins" srcdir="continuations/plugin" destproject="continuations-plugin"/>
        <copy
           file="${src.dir}/continuations/plugin/scalac-plugin.xml"
           todir="${build-quick.dir}/classes/continuations-plugin"/>

        <!-- not very nice to create jar here but needed to load plugin -->
        <mkdir dir="${build-quick.dir}/misc/scala-devel/plugins"/>
        <jar whenmanifestonly="fail" destfile="${build-quick.dir}/misc/scala-devel/plugins/continuations.jar" basedir="${build-quick.dir}/classes/continuations-plugin"/>

        <!-- might split off library part into its own ant target -->
        <mkdir dir="${build-quick.dir}/classes/continuations-library"/>
        <!-- have to compile with quick compiler here! -->
        <staged-scalac with="quick" stage="quick" project="plugins"
                       srcdir="continuations/library" destproject="continuations-library"
                       args="-Xplugin-require:continuations -P:continuations:enable">
          <compilerarg value="-Xpluginsdir"/>
          <compilerarg file="${build-quick.dir}/misc/scala-devel/plugins"/>
        </staged-scalac>

        <stopwatch name="quick.plugins.timer" action="total"/>
      </do>
    </staged-uptodate>
  </target>

  <target name="quick.bin" depends="init">
    <staged-bin stage="quick" classpathref="quick.bin.tool.path"/>
  </target>

  <target name="quick.done" depends="quick.lib, quick.reflect, quick.comp, quick.scalacheck, quick.scalap, quick.swing, quick.plugins, quick.partest, quick.bin"/>
  <target name="quick-opt" description="Optimized version of quick.done."> <optimized name="quick.done"/></target>


<!-- ===========================================================================
                                  PACKED QUICK BUILD (PACK)
============================================================================ -->
  <target name="pack.lib" depends="quick.lib, quick.plugins, forkjoin.done">
    <staged-pack project="library">
      <!-- First copy maven dependencies -->
      <copy todir="${build-pack.dir}/lib">
        <fileset refid="dependency.fileset" />
        <mapper type="flatten" />
      </copy>
      <jar whenmanifestonly="fail" destfile="${build-pack.dir}/lib/scala-library.jar">
        <fileset dir="${build-quick.dir}/classes/library">
          <exclude name="scala/swing/**"/>
          <exclude name="scala/actors/**"/>
        </fileset>
        <fileset dir="${build-quick.dir}/classes/continuations-library"/>
        <fileset dir="${build-libs.dir}/classes/forkjoin"/>
      </jar>
      <jar whenmanifestonly="fail" destfile="${build-pack.dir}/lib/scala-actors.jar">
        <fileset dir="${build-quick.dir}/classes/library">
          <include name="scala/actors/**"/>
        </fileset>
      </jar>
    </staged-pack>
  </target>

  <target name="pack.swing" depends="quick.swing" if="has.java6">
    <staged-pack project="swing’">
      <jar whenmanifestonly="fail" destfile="${build-pack.dir}/lib/scala-swing.jar" basedir="${build-quick.dir}/classes/swing"/>
    </staged-pack>
  </target>

  <target name="pack.reflect" depends="quick.reflect">
    <staged-pack project="reflect’">
      <jar whenmanifestonly="fail" destfile="${build-pack.dir}/lib/scala-reflect.jar" basedir="${build-quick.dir}/classes/reflect"/>
    </staged-pack>
  </target>

  <target name="pack.comp" depends="quick.comp, asm.done">
    <staged-pack project="compiler">
      <mkdir dir="${build-pack.dir}/META-INF"/>
      <copy file="META-INF/MANIFEST.MF" toDir="${build-pack.dir}/META-INF"/>
      <manifest file="${build-pack.dir}/META-INF/MANIFEST.MF" mode="update">
        <attribute name="Bundle-Version" value="${version.number}"/>
        <attribute name="Class-Path" value="scala-reflect.jar scala-library.jar"/>
      </manifest>
      <jar whenmanifestonly="fail" destfile="${build-pack.dir}/lib/scala-compiler.jar" manifest="${build-pack.dir}/META-INF/MANIFEST.MF">
        <service type="javax.script.ScriptEngineFactory" provider="scala.tools.nsc.interpreter.IMain$Factory"/>
        <fileset dir="${build-quick.dir}/classes/compiler"/>
        <fileset dir="${build-asm.dir}/classes"/>
        <fileset dir="${build-libs.dir}/classes/fjbg"/>
      </jar>
      <copy file="${jline.jar}" toDir="${build-pack.dir}/lib"/>
      <copy todir="${build-pack.dir}/lib">
        <fileset dir="${lib-extra.dir}">
          <include name="**/*.jar"/>
        </fileset>
      </copy>
    </staged-pack>
  </target>

  <target name="pack.plugins" depends="quick.plugins">
    <staged-pack project="plugins" targetdir="misc/scala-devel/plugins" targetjar="continuations.jar">
      <jar whenmanifestonly="fail" destfile="${build-pack.dir}/misc/scala-devel/plugins/continuations.jar" basedir="${build-quick.dir}/classes/continuations-plugin"/>
    </staged-pack>
  </target>

  <target name="pack.scalacheck" depends="quick.scalacheck">
    <uptodate property="pack.scalacheck.available"
         targetfile="${build-pack.dir}/lib/scalacheck.jar">
      <srcfiles  dir="${build-quick.dir}/classes/scalacheck"/></uptodate>
    <if><not><isset property="pack.scalacheck.available"/></not><then>
      <jar whenmanifestonly="fail" destfile="${build-pack.dir}/lib/scalacheck.jar" basedir="${build-quick.dir}/classes/scalacheck"/>
    </then></if>
  </target>

  <target name="pack.partest" depends="quick.partest">
    <staged-pack project="partest">
      <jar whenmanifestonly="fail" destfile="${build-pack.dir}/lib/scala-partest.jar">
        <fileset dir="${build-quick.dir}/classes/partest">
          <exclude name="scala/tools/partest/javaagent/**"/>
        </fileset>
      </jar>
      <jar whenmanifestonly="fail" destfile     = "${build-pack.dir}/lib/scala-partest-javaagent.jar"
        manifest        = "${src.dir}/partest/scala/tools/partest/javaagent/MANIFEST.MF">
        <fileset dir    = "${build-quick.dir}/classes/partest">
          <include name = "scala/tools/partest/javaagent/**"/>
        </fileset>
      </jar>
    </staged-pack>
  </target>

  <target name="pack.scalap" depends="quick.scalap">
    <staged-pack project="plugins" targetjar="scalap.jar">
      <jar whenmanifestonly="fail" destfile="${build-pack.dir}/lib/scalap.jar">
        <fileset dir="${build-quick.dir}/classes/scalap"/>
        <fileset file="${src.dir}/scalap/decoder.properties"/>
      </jar>
    </staged-pack>
  </target>

  <target name="pack.bin" depends="pack.comp, pack.lib, pack.partest, pack.plugins, pack.reflect, pack.scalacheck, pack.scalap, pack.swing">
    <staged-bin stage="pack"/>
  </target>

  <target name="pack.done" depends="pack.bin">
    <taskdef resource="scala/tools/ant/antlib.xml" classpathref="pack.compiler.path"/>
    <taskdef resource="scala/tools/partest/antlib.xml" classpathref="pack.compiler.path"/>
  </target>


<!-- ===========================================================================
                                  BOOTSTRAPPING BUILD (STRAP)
============================================================================ -->
  <target name="strap.lib" depends="quick.done">
    <staged-build with="quick" stage="strap" project="library" srcpath="${src.dir}/library" includes="lib.rootdoc.includes">
      <pre>
        <staged-javac stage="strap" project="library" args="-XDignore.symbol.file"/> <!-- TODO: args="-XDignore.symbol.file" necessary?? -->
        <staged-javac stage="strap" project="actors" destproject="library"/>
      </pre>
      <post>
        <staged-scalac with="quick" stage="strap" project="actors" destproject="library"/>
      </post>
    </staged-build>
  </target>

  <target name="strap.reflect" depends="strap.lib"> <staged-build with="pack" stage="strap" project="reflect"/> </target>
  <target name="strap.comp"    depends="strap.reflect">
    <staged-build with="pack" stage="strap" project="compiler">
      <pre>
        <staged-javac stage="strap" project="msil" destproject="compiler" excludes="**/tests/**"/>
        <staged-scalac with="quick" stage="strap" project="msil" destproject="compiler"/>
      </pre>
    </staged-build>
  </target>
  <target name="strap.done"    depends="strap.comp"/>
  <target name="strap-opt" description="Optimized version of strap.done."> <optimized name="strap.done"/></target>


<!-- ===========================================================================
                                  PACKED LOCKER BUILD (PALO)
============================================================================ -->
  <target name="palo.done" depends="locker.done">
    <mkdir dir="${build-palo.dir}/lib"/>
    <jar whenmanifestonly="fail" destfile="${build-palo.dir}/lib/scala-library.jar">
      <fileset dir="${build-locker.dir}/classes/library"/>
      <fileset dir="${build-libs.dir}/classes/forkjoin"/>
    </jar>
    <jar whenmanifestonly="fail" destfile="${build-palo.dir}/lib/scala-reflect.jar" manifest="${basedir}/META-INF/MANIFEST.MF"
      basedir="${build-locker.dir}/classes/reflect"/>
    <jar whenmanifestonly="fail" destfile="${build-palo.dir}/lib/scala-compiler.jar" manifest="${basedir}/META-INF/MANIFEST.MF">
      <fileset dir="${build-locker.dir}/classes/compiler"/>
      <fileset dir="${build-asm.dir}/classes/"/>
      <fileset dir="${build-libs.dir}/classes/fjbg"/>
    </jar>
    <copy file="${jline.jar}" toDir="${build-palo.dir}/lib"/>
  </target>

  <target name="palo.bin" depends="palo.done"> <staged-bin stage="palo"/></target>


<!-- ===========================================================================
                                  OSGi Artifacts
============================================================================ -->
  <target name="osgi.done" depends="pack.done">
    <mkdir dir="${build-osgi.dir}"/>

    <!-- simplify fixing pom versions -->
    <macrodef name="make-bundle">
      <attribute name="name" />
      <attribute name="version" />
      <sequential>
        <copy file="${src.dir}/build/bnd/@{name}.bnd" tofile="${build-osgi.dir}/@{name}.bnd" overwrite="true">
          <filterset>
            <filter token="VERSION" value="@{version}" />
          </filterset>
        </copy>
        <bnd classpath="${build-pack.dir}/lib/@{name}.jar"
             eclipse="false"
             failok="false"
             exceptions="true"
             files="${build-osgi.dir}/@{name}.bnd"
             output="${build-osgi.dir}"/>
      </sequential>
    </macrodef>
    <macrodef name="make-plugin-bundle">
      <attribute name="name" />
      <attribute name="version" />
      <sequential>
        <copy file="${src.dir}/build/bnd/@{name}.bnd" tofile="${build-osgi.dir}/@{name}.bnd" overwrite="true">
          <filterset>
            <filter token="VERSION" value="@{version}" />
          </filterset>
        </copy>
        <bnd classpath="${build-pack.dir}/misc/scala-devel/plugins/@{name}.jar"
             eclipse="false"
             failok="false"
             exceptions="true"
             files="${build-osgi.dir}/@{name}.bnd"
             output="${build-osgi.dir}"/>
      </sequential>
    </macrodef>

    <uptodate property="osgi.bundles.available" targetfile="${build-osgi.dir}/bundles.complete">
      <srcfiles dir="${basedir}">
        <include name="build.xml"/>
        <include name="src/build/bnd/*.bnd"/>
      </srcfiles>
    </uptodate>

    <if><not><isset property="osgi.bundles.available"/></not><then>
      <stopwatch name="osgi.bundle.timer"/>
      <make-bundle name="scala-library" version="${osgi.version.number}" />
      <make-bundle name="scala-actors" version="${osgi.version.number}" />
      <make-bundle name="scala-reflect" version="${osgi.version.number}" />
      <make-bundle name="scala-compiler" version="${osgi.version.number}" />
      <make-plugin-bundle name="continuations" version="${osgi.version.number}" />
      <touch file="${build-osgi.dir}/bundles.complete" verbose="no"/>

      <if><isset property="has.java6"/><then>
        <make-bundle name="scala-swing" version="${osgi.version.number}"/></then>
      </if>
      <stopwatch name="osgi.bundle.timer" action="total"/></then>
    </if>
  </target>


<!-- ===========================================================================
                                  TEST SUITE
============================================================================ -->
  <!-- bootstrapping stability: compare {quick,strap}/(lib|reflect|comp) -->
  <target name="test.stability" depends="quick.lib, quick.reflect, quick.comp, strap.lib, strap.reflect, strap.comp">
    <exec osfamily="unix" vmlauncher="false" executable="${basedir}/tools/stability-test.sh" failonerror="true" />
    <!-- I think doing it this way means it will auto-pass on windows... that's the idea. If not, something like this. -->
    <!-- <exec osfamily="windows" executable="foo" failonerror="false" failifexecutionfails="false" /> -->
  </target>

  <target name="test.stability-opt" description="Optimized version of test.stability."> <optimized name="test.stability"/></target>

  <target name="test.osgi.init" depends="osgi.done">
    <uptodate property="test.osgi.available" targetfile="${build-osgi.dir}/test-compile.complete">
      <srcfiles dir="${test.osgi.src}">
        <include name="**/*.scala"/>
      </srcfiles>
    </uptodate>
  </target>

  <target name="test.osgi.comp" depends="test.osgi.init, quick.done" unless="test.osgi.available">
    <stopwatch name="test.osgi.compiler.timer"/>
    <mkdir dir="${test.osgi.classes}"/>
    <scalacfork
      destdir="${test.osgi.classes}"
      compilerpathref="quick.compiler.path"
      params="${scalac.args.quick}"
      srcdir="${test.osgi.src}"
      jvmargs="${scalacfork.jvmargs}">
      <include name="**/*.scala"/>
      <compilationpath refid="test.osgi.compiler.build.path"/>
    </scalacfork>
    <touch file="${build-osgi.dir}/test-compile.complete" verbose="no"/>
    <stopwatch name="test.osgi.compiler.timer" action="total"/>
  </target>

  <target name="test.osgi" depends="test.osgi.comp">
    <stopwatch name="test.osgi.timer"/>
    <mkdir dir="${test.osgi.classes}"/>
    <junit fork="yes" haltonfailure="yes">
      <classpath refid="test.osgi.compiler.build.path"/>
      <batchtest fork="yes" todir="${build-osgi.dir}">
        <fileset dir="${test.osgi.classes}">
          <include name="**/*Test.class"/>
        </fileset>
      </batchtest>
      <formatter type="brief" /> <!-- silenced by having it use a file; I tried for an hour to use other formatters but classpath issues drove me to this usefile="false" -->
    </junit>
    <stopwatch name="test.osgi.timer" action="total"/>
  </target>


<!-- ===========================================================================
                                  SBT Compiler Interface
============================================================================ -->
  <target name="test.sbt" depends="quick.done">
    <if><not><and>
        <available file="${sbt.interface.jar}"/>
        <available file="${sbt.interface.src.jar}"/></and></not>
    <then>
      <!-- Ensure directories exist -->
      <mkdir dir="${sbt.src.dir}"/>
      <mkdir dir="${sbt.lib.dir}"/>

      <get src="${sbt.interface.url}" dest="${sbt.interface.jar}"/>
      <get src="${sbt.interface.src.url}" dest="${sbt.interface.src.jar}"/>

      <!-- Explode sources -->
      <unzip src="${sbt.interface.src.jar}" dest="${sbt.src.dir}"/>
    </then></if>

    <stopwatch name="quick.sbt-interface.timer"/>
    <mkdir dir="${build-sbt.dir}/classes"/>
    <scalacfork
      destdir="${build-sbt.dir}/classes"
      compilerpathref="quick.compiler.path"
      params="${scalac.args.quick}"
      srcdir="${sbt.src.dir}"
      jvmargs="${scalacfork.jvmargs}">
      <include name="**/*.scala"/>
      <compilationpath refid="sbt.compile.build.path"/>
    </scalacfork>
    <touch file="${build-sbt.dir}/sbt-interface.complete" verbose="no"/>
    <stopwatch name="quick.sbt-interface.timer" action="total"/>
  </target>

  <property name="partest.srcdir" value="files" /> <!-- TODO: make targets for `pending` and other subdirs -->

  <target name="test.run" depends="pack.done">
    <partest showlog="yes" erroronfailed="yes" javacmd="${java.home}/bin/java"
             timeout="1200000"
             srcdir="${partest.srcdir}"
             scalacopts="${scalac.args.optimise}">

      <compilationpath refid="partest.classpath"/>
      <runtests  dir="${partest.dir}/${partest.srcdir}/run" includes="*.scala"/>
      <jvmtests dir="${partest.dir}/${partest.srcdir}/jvm" includes="*.scala"/>
    </partest>
  </target>

  <target name="test.suite" depends="pack.done">
    <partest showlog="yes" erroronfailed="yes" javacmd="${java.home}/bin/java"
             timeout="2400000"
             srcdir="${partest.srcdir}"
             scalacopts="${scalac.args.optimise}">
      <compilationpath refid="partest.classpath"/>
      <postests  dir="${partest.dir}/${partest.srcdir}/pos" includes="*.scala"/>
      <negtests  dir="${partest.dir}/${partest.srcdir}/neg" includes="*.scala"/>
      <runtests  dir="${partest.dir}/${partest.srcdir}/run" includes="*.scala"/>
      <jvmtests dir="${partest.dir}/${partest.srcdir}/jvm" includes="*.scala"/>
      <residenttests dir="${partest.dir}/${partest.srcdir}/res" includes="*.res"/>
      <buildmanagertests dir="${partest.dir}/${partest.srcdir}/buildmanager" includes="*"/>
      <scalaptests dir="${partest.dir}/${partest.srcdir}/scalap" includes="**/*.scala"/>
      <scalachecktests dir="${partest.dir}/${partest.srcdir}/scalacheck">
        <include name="*.scala"/>
      </scalachecktests>
      <specializedtests dir="${partest.dir}/${partest.srcdir}/specialized">
        <include name="*.scala"/>
      </specializedtests>
      <instrumentedtests dir="${partest.dir}/${partest.srcdir}/instrumented">
        <include name="*.scala"/>
      </instrumentedtests>
    </partest>
  </target>

  <target name="test.continuations.suite" depends="pack.done">
    <partest showlog="yes" erroronfailed="yes" javacmd="${java.home}/bin/java"
             timeout="2400000"
             srcdir="${partest.srcdir}"
             scalacopts="${scalac.args.optimise} -Xplugin-require:continuations -P:continuations:enable">
      <compilerarg value="-Xpluginsdir"/>
      <compilerarg file="${build-quick.dir}/misc/scala-devel/plugins"/>
      <compilationpath refid="partest.classpath"/>
      <negtests  dir="${partest.dir}/${partest.srcdir}/continuations-neg" includes="*.scala"/>
      <runtests  dir="${partest.dir}/${partest.srcdir}/continuations-run" includes="*.scala"/>
    </partest>
  </target>

  <target name="test.scaladoc" depends="pack.done">
    <partest erroronfailed="yes" scalacopts="${scalac.args.optimise}" showlog="yes">
      <compilationpath refid="partest.classpath"/>
      <runtests        dir="${partest.dir}/scaladoc/run"        includes="*.scala" />
      <scalachecktests dir="${partest.dir}/scaladoc/scalacheck" includes="*.scala" />
    </partest>
  </target>

  <target name="test.interactive" depends="pack.done">
    <partest erroronfailed="yes" scalacopts="${scalac.args.optimise}" showlog="yes">
      <compilationpath refid="partest.classpath"/>
      <presentationtests dir="${partest.dir}/${partest.srcdir}/presentation">
        <include name="*/*.scala"/>
      </presentationtests>
    </partest>
  </target>

<!-- currently disabled: test.ant, test.bc, test.positions, test.classload -->
  <target name="test.done" depends="test.osgi, test.sbt, test.interactive, test.continuations.suite, test.suite, test.scaladoc, test.stability"/>


<!-- ===========================================================================
                                  BINARY COMPATIBILITY TESTING
============================================================================ -->
  <target name="bc.init" depends="init" unless="maven-deps-done-mima">
    <property name="bc-build.dir" value="${build.dir}/bc"/>
    <!-- Obtain mima -->
    <mkdir dir="${bc-build.dir}"/>
    <!-- Pull down MIMA -->
    <artifact:dependencies pathId="mima.classpath">
      <dependency groupId="com.typesafe" artifactId="mima-reporter_2.9.2" version="0.1.5"/>
    </artifact:dependencies>
    <artifact:dependencies pathId="old.bc.classpath">
      <dependency groupId="org.scala-lang" artifactId="scala-swing" version="2.10.0"/>
      <dependency groupId="org.scala-lang" artifactId="scala-library" version="2.10.0"/>
      <dependency groupId="org.scala-lang" artifactId="scala-reflect" version="2.10.0"/>
    </artifact:dependencies>
    <property name="maven-deps-done-mima" value="true"/>
  </target>

  <macrodef name="bc.run-mima">
    <attribute name="jar-name"/>
    <attribute name="prev"/>
    <attribute name="curr"/>
    <attribute name="direction"/>
    <sequential>
      <echo message="Checking @{direction} binary compatibility for @{jar-name}"/>
      <java
         fork="true"
         failonerror="true"
         classname="com.typesafe.tools.mima.cli.Main">
           <arg value="--prev"/>
           <arg value="@{prev}"/>
           <arg value="--curr"/>
           <arg value="@{curr}"/>
           <arg value="--filters"/>
           <arg value="${basedir}/bincompat-@{direction}.whitelist.conf"/>
           <arg value="--generate-filters"/>
           <classpath>
             <path refid="mima.classpath"/>
           </classpath>
      </java>
    </sequential>
  </macrodef>

  <macrodef name="bc.check">
    <attribute name="jar-name"/>
    <sequential>
        <bc.run-mima
                jar-name="@{jar-name}"
                prev="${org.scala-lang:@{jar-name}:jar}"
                curr="${build-pack.dir}/lib/@{jar-name}.jar"
                direction="backward"/>
        <bc.run-mima
                jar-name="@{jar-name}"
                prev="${build-pack.dir}/lib/@{jar-name}.jar"
                curr="${org.scala-lang:@{jar-name}:jar}"
                direction="forward"/>
    </sequential>
  </macrodef>

  <target name="test.bc" depends="bc.init, pack.lib, pack.reflect, pack.swing">
    <bc.check jar-name="scala-library"/>
    <bc.check jar-name="scala-reflect"/>
    <bc.check jar-name="scala-swing"/>
  </target>

<!-- ===========================================================================
                                  DOCUMENTATION
============================================================================ -->
  <target name="docs.start" depends="pack.done">
    <!-- Set the github commit scaladoc sources point to -->
    <!-- For releases, look for the tag with the same name as the maven version -->
    <condition property="scaladoc.git.commit" value="v${maven.version.number}">
      <isset property="build.release"/>
    </condition>
    <!-- For snapshots, if we know the commit, point scaladoc to that particular commit instead of master -->
    <condition property="scaladoc.git.commit" value="${git.commit.sha}">
      <not><equals arg1="${git.commit.sha}" arg2="unknown"/></not>
    </condition>
    <!-- Fallback: point scaladoc to master -->
    <property name="scaladoc.git.commit" value="master"/>
    <!-- Compute the URL and show it -->
    <property name="scaladoc.url" value="https://github.com/scala/scala/tree/${scaladoc.git.commit}/src"/>
    <echo message="Scaladoc will point to ${scaladoc.url} for source files."/>

    <!-- Unless set with -Dscaladoc.<...>, these won't be activated -->
    <property name="scaladoc.raw.output" value="no"/>
    <property name="scaladoc.no.prefixes" value="no"/>
  </target>

  <target name="docs.lib" depends="docs.start">
    <staged-uptodate stage="docs" project="library">
      <check><srcfiles dir="${src.dir}">
        <include name="library/**"/>
        <include name="swing/**"/>
        <include name="actors/**"/>
        <include name="reflect/**"/>
      </srcfiles></check>
      <do>
        <stopwatch name="docs.lib.timer"/>
        <mkdir dir="${build-docs.dir}/library"/>
        <!-- last three attributes not supported by staged-docs: -->
        <scaladoc
          destdir="${build-docs.dir}/library"
          doctitle="Scala Standard Library API (Scaladoc)"
          docversion="${version.number}"
          docsourceurl="${scaladoc.url}€{FILE_PATH}.scala#L1"
          sourcepath="${src.dir}"
          classpathref="pack.compiler.path"
          addparams="${scalac.args.all}"
          docRootContent="${src.dir}/library/rootdoc.txt"
          implicits="on"
          diagrams="on"
          groups="on"
          rawOutput="${scaladoc.raw.output}"
          noPrefixes="${scaladoc.no.prefixes}"
          docfooter="epfl"
          docUncompilable="${src.dir}/library-aux"
          skipPackages="scala.reflect.macros.internal:scala.reflect.internal:scala.reflect.io:scala.concurrent.impl">
          <src>
            <files includes="${src.dir}/actors"/>
            <files includes="${src.dir}/library"/>
            <files includes="${src.dir}/reflect"/>
            <files includes="${src.dir}/swing"/>
            <files includes="${src.dir}/continuations/library"/>
          </src>
          <include name="**/*.scala"/>
          <exclude name="reflect/Code.scala"/>
          <exclude name="reflect/Print.scala"/>
          <exclude name="reflect/Symbol.scala"/>
          <exclude name="reflect/Tree.scala"/>
          <exclude name="reflect/Type.scala"/>
          <exclude name="runtime/*$.scala"/>
          <exclude name="runtime/ScalaRunTime.scala"/>
          <exclude name="runtime/StringAdd.scala"/>
        </scaladoc>
        <stopwatch name="docs.lib.timer" action="total"/>
      </do>
    </staged-uptodate>
  </target>

  <target name="docs.comp" depends="docs.start">
    <staged-docs project="compiler" title="Scala Compiler" docroot="rootdoc.txt">
      <include name="**/*.scala"/>
    </staged-docs>
  </target>

  <target name="docs.jline" depends="docs.start">
    <staged-docs project="jline" dir="jline/src/main/java" title="Scala JLine">
      <include name="**/*.scala"/>
      <include name="**/*.java"/>
    </staged-docs>
  </target>

  <target name="docs.scalap" depends="docs.start">
    <staged-docs project="scalap" title="Scalap">
      <include name="**/*.scala"/>
    </staged-docs>
  </target>

  <target name="docs.partest" depends="docs.start">
    <staged-docs project="partest" title="Scala Parallel Testing Framework">
      <include name="**/*.scala"/>
    </staged-docs>
  </target>

  <target name="docs.continuations-plugin" depends="docs.start">
    <staged-docs project="continuations-plugin" dir="continuations/plugin" title="Delimited Continuations Compiler Plugin">
      <include name="**/*.scala"/>
    </staged-docs>
  </target>

  <target name="docs.man" depends="docs.start">
    <staged-uptodate stage="docs" project="manual">
      <check><srcfiles dir="${src.dir}/manual"/></check>
      <do>
        <mkdir dir="${build.dir}/manmaker/classes"/>
        <scalac
          destdir="${build.dir}/manmaker/classes"
          classpathref="pack.compiler.path"
          srcdir="${src.dir}/manual"
          includes="**/*.scala"
          addparams="${scalac.args.all}"/>
        <mkdir dir="${build-docs.dir}/manual/man/man1"/>
        <mkdir dir="${build-docs.dir}/manual/html"/>
        <mkdir dir="${build-docs.dir}/manual/genman/man1"/>
        <taskdef name="genman"
                 classname="scala.tools.docutil.ManMaker"
                 classpathref="manual.classpath"/>
        <genman command="fsc, scala, scalac, scaladoc, scalap"
                htmlout="${build-docs.dir}/manual/html"
                manout="${build-docs.dir}/manual/genman"/>
        <!-- On Windows source and target files can't be the same ! -->
        <fixcrlf
          srcdir="${build-docs.dir}/manual/genman"
          destdir="${build-docs.dir}/manual/man"
          eol="unix" includes="**/*.1"/>
        <copy todir="${build-docs.dir}/manual/html">
          <fileset dir="${src.dir}/manual/scala/tools/docutil/resources">
            <include name="**/*.html"/>
            <include name="**/*.css"/>
            <include name="**/*.gif"/>
            <include name="**/*.png"/>
          </fileset>
        </copy>
      </do>
    </staged-uptodate>
  </target>

  <target name="docs.done" depends="docs.jline, docs.comp, docs.man, docs.lib, docs.scalap, docs.partest, docs.continuations-plugin"/>


<!-- ===========================================================================
                                  DISTRIBUTION
============================================================================ -->
  <target name="dist.base" depends="pack.done, osgi.done">
    <property name="dist.name" value="scala-${version.number}"/>
    <property name="dist.dir" value="${dists.dir}/${dist.name}"/>

    <macrodef name="copy-bundle">
      <attribute name="name" />
      <sequential>
        <copy file="${build-osgi.dir}/org.scala-lang.@{name}.jar"
          tofile="${dist.dir}/lib/@{name}.jar"/>
      </sequential>
    </macrodef>
    <macrodef name="copy-plugin-bundle">
      <attribute name="name" />
      <sequential>
        <copy file="${build-osgi.dir}/org.scala-lang.plugins.@{name}.jar"
          tofile="${dist.dir}/misc/scala-devel/plugins/@{name}.jar"
          overwrite="yes"/>
      </sequential>
    </macrodef>

    <mkdir dir="${dist.dir}/lib"/>
    <copy toDir="${dist.dir}/lib">
      <fileset dir="${build-pack.dir}/lib">
        <include name="jline.jar"/>
        <include name="scalacheck.jar"/>
        <include name="scala-partest.jar"/>
        <include name="scalap.jar"/>
      </fileset>
    </copy>
    <mkdir dir="${dist.dir}/bin"/>
    <!-- TODO - Stop being inefficient and don't copy OSGi bundles overtop other jars. -->
    <copy-bundle name="scala-library"/>
    <copy-bundle name="scala-reflect"/>
    <copy-bundle name="scala-swing"/>
    <copy-bundle name="scala-actors"/>
    <copy-bundle name="scala-compiler"/>
    <copy toDir="${dist.dir}/bin">
      <fileset dir="${build-pack.dir}/bin"/>
    </copy>
    <chmod perm="ugo+rx" file="${dist.dir}/bin/scala"/>
    <chmod perm="ugo+rx" file="${dist.dir}/bin/scalac"/>
    <chmod perm="ugo+rx" file="${dist.dir}/bin/scaladoc"/>
    <chmod perm="ugo+rx" file="${dist.dir}/bin/fsc"/>
    <chmod perm="ugo+rx" file="${dist.dir}/bin/scalap"/>
    <mkdir dir="${dist.dir}/misc/scala-devel/plugins"/>
    <copy-plugin-bundle name="continuations"/>
  </target>

  <target name="dist.doc" depends="dist.base, docs.done">
    <mkdir dir="${dist.dir}/doc/scala-devel-docs"/>
    <copy file="${docs.dir}/LICENSE" toDir="${dist.dir}/doc"/>
    <copy file="${docs.dir}/README" toDir="${dist.dir}/doc"/>
    <mkdir dir="${dist.dir}/doc/scala-devel-docs/api"/>
    <copy toDir="${dist.dir}/doc/scala-devel-docs/api">
      <fileset dir="${build-docs.dir}/library"/>
    </copy>
    <mkdir dir="${dist.dir}/doc/scala-devel-docs/examples"/>
    <copy toDir="${dist.dir}/doc/scala-devel-docs/examples">
      <fileset dir="${docs.dir}/examples">
        <exclude name="**/*.desired.sha1"/>
      </fileset>
    </copy>
    <mkdir dir="${dist.dir}/doc/scala-devel-docs/tools"/>
    <copy toDir="${dist.dir}/doc/scala-devel-docs/tools">
      <fileset dir="${build-docs.dir}/manual/html"/>
    </copy>
    <copy file="${src.dir}/swing/doc/README"
          toFile="${dist.dir}/doc/scala-devel-docs/README.scala-swing"/>
  </target>

  <target name="dist.man" depends="dist.base">
    <mkdir dir="${dist.dir}/man"/>
    <copy toDir="${dist.dir}/man">
      <fileset dir="${build-docs.dir}/manual/man"/>
    </copy>
  </target>

  <target name="dist.src" depends="dist.base">
    <mkdir dir="${dist.dir}/src"/>
    <jar whenmanifestonly="fail" destfile="${dist.dir}/src/scala-library-src.jar">
      <fileset dir="${src.dir}/library"/>
      <fileset dir="${src.dir}/continuations/library"/>
    </jar>
    <jar whenmanifestonly="fail" destfile="${dist.dir}/src/scala-reflect-src.jar"  basedir="${src.dir}/reflect"/>
    <jar whenmanifestonly="fail" destfile="${dist.dir}/src/scala-swing-src.jar"    basedir="${src.dir}/swing"/>
    <jar whenmanifestonly="fail" destfile="${dist.dir}/src/scala-compiler-src.jar" basedir="${src.dir}/compiler"/>
    <jar whenmanifestonly="fail" destfile="${dist.dir}/src/fjbg-src.jar"           basedir="${src.dir}/fjbg"/>
    <jar whenmanifestonly="fail" destfile="${dist.dir}/src/msil-src.jar"           basedir="${src.dir}/msil"/>
    <jar whenmanifestonly="fail" destfile="${dist.dir}/src/scala-actors-src.jar"   basedir="${src.dir}/actors"/>
    <jar whenmanifestonly="fail" destfile="${dist.dir}/src/scalap-src.jar"         basedir="${src.dir}/scalap"/>
    <jar whenmanifestonly="fail" destfile="${dist.dir}/src/scala-partest-src.jar"  basedir="${src.dir}/partest"/>
  </target>

  <target name="dist.partial" depends="dist.base">
    <if><not><os family="windows"/></not><then>
      <symlink link="${dists.dir}/latest" resource="${dist.name}" overwrite="yes"/>
    </then><else> <!-- XXX THIS PROBABLY DOES NOT WORK: copying must happen last during dist.done! is this guaranteed? -->
      <copydir dest="${dists.dir}/latest" src="${dist.dir}"/>
    </else></if>
  </target>

  <target name="dist.done" depends="dist.doc, dist.man, dist.src, dist.partial"/>


<!-- ===========================================================================
                                  STABLE REFERENCE (STARR)
============================================================================ -->
<!-- Does not use any properties other than ${basedir}, so that it can
     run without 'init' (when using 'replacestarrwin') -->

  <target name="starr.start">
    <fail message="Library in build/pack not available">
      <condition><not><and>
        <available file="${build-pack.dir}/lib/scala-library.jar"/>
      </and></not></condition>
    </fail>
    <fail message="Compiler in build/quick not available">
      <condition><not><and>
        <available file="${build-quick.dir}/classes/compiler"/>
        <available file="${build-quick.dir}/compiler.complete"/>
      </and></not></condition>
    </fail>
  </target>

  <target name="starr.jars" depends="starr.start">
    <copy toDir="${lib.dir}" overwrite="yes">
      <fileset dir="${build-pack.dir}/lib">
        <include name="scala-library.jar"/>
        <include name="scala-reflect.jar"/>
        <include name="scala-compiler.jar"/>
      </fileset>
    </copy>
  </target>

  <target name="starr.src" depends="starr.jars">
    <jar whenmanifestonly="fail" destfile="${lib.dir}/scala-library-src.jar">
      <fileset dir="${src.dir}/library"/>
      <fileset dir="${src.dir}/swing"/>
      <fileset dir="${src.dir}/actors"/>
      <fileset dir="${src.dir}/forkjoin"/>
    </jar>
    <jar whenmanifestonly="fail" destfile="${lib.dir}/scala-reflect-src.jar" basedir="${src.dir}/reflect"/>
    <jar whenmanifestonly="fail" destfile="${lib.dir}/scala-compiler-src.jar">
      <fileset dir="${src.dir}/compiler"/>
      <fileset dir="${src.dir}/asm"/>
    </jar>
  </target>

  <target name="starr.removesha1" depends="starr.src">
    <!-- remove SHA1 files for no starr, so we don't loose artifacts. -->
    <delete>
      <fileset dir="${lib.dir}">
        <include name="scala-compiler.jar.desired.sha1"/>
        <include name="scala-reflect.jar.desired.sha1"/>
        <include name="scala-library.jar.desired.sha1"/>
        <include name="scala-library-src.jar.desired.sha1"/>
        <include name="scala-reflect-src.jar.desired.sha1"/>
        <include name="scala-compiler-src.jar.desired.sha1"/>
      </fileset>
    </delete>
  </target>

  <target name="starr.done" depends="starr.jars, starr.removesha1"/>

  <target name="replacestarr" description="Replaces the Starr compiler and library by fresh ones built from current sources and tests them.">
    <fail message="This target is not available on Windows. Use 'ant replacestarrwin' instead.">
      <condition>
        <os family="windows"/>
      </condition>
    </fail>
    <!-- needs antcall to enforce ordering -->
    <antcall target="locker.clean"/>
    <antcall target="pack.done"/>
    <antcall target="starr.done"/>
    <antcall target="locker.clean"/>
    <antcall target="test.done"/>
  </target>

  <target name="replacestarr-opt" description="Replaces the Starr compiler and library by fresh, optimised ones built from current sources and tests them.">
    <optimize name="replacestarr"/></target>

  <!-- Ant on Windows is not able to delete jar files that are referenced in any <path>.
       See ticket 1290 on trac. -->
  <target name="replacestarrwin" description="Creates a new Starr on Windows. Manually execute 'ant locker.clean build' first!">
    <fail message="This target is only available on Windows. Use 'ant replacestarr' instead.">
      <condition>
        <not><os family="windows"/></not>
      </condition>
    </fail>
    <echo message="CAUTION: Make sure to execute 'ant locker.clean build' prior to calling 'replacestarrwin'."/>
    <antcall target="starr.done"/>
    <antcall target="locker.clean"/>
    <antcall target="test.done"/>
  </target>

  <target name="replacestarrwin-opt" description="Creates a new Starr on Windows. Manually execute 'ant locker.clean build' first!">
    <optimize name="replacestarrwin"/></target>

  <target name="replacelocker" description="Replaces the Locker compiler and library by fresh ones built from current sources."
    depends="palo.clean, locker.unlock, palo.done"/>

  <target name="replacelocker-opt" description="Replaces the Locker compiler and library by fresh, optimised ones built from current sources.">
    <optimize name="replacelocker"/></target>

  <target name="buildlocker" description="Does the same for locker as build does for quick." depends="locker.unlock, palo.bin"/>
  <target name="unlocklocker" description="Same as buildlocker." depends="buildlocker"/> <!-- REMOVE -->

  <target name="fastlocker.lib" description="Buildlocker without extra fuss" depends="locker.unlock, locker.lib">
    <property name="fastlocker" value="true"/>
  </target>

  <target name="fastlocker.reflect" description="Buildlocker without extra fuss" depends="locker.unlock, locker.reflect">
    <property name="fastlocker" value="true"/>
  </target>

  <target name="fastlocker.comp" description="Buildlocker without extra fuss" depends="locker.unlock, locker.comp">
    <property name="fastlocker" value="true"/>
  </target>

  <target name="fastlocker" description="Buildlocker without extra fuss" depends="fastlocker.comp"/>


<!-- ===========================================================================
                                  TODO: FIX OR REMOVE
============================================================================ -->

  <!-- not called by test target -->
  <target name="test.classload" depends="pack.done">
    <!-- TODO - Add actors + reflect to this -->
    <classloadVerify classpath="${build-pack.dir}/lib/scala-library.jar" />
  </target>

  <!-- not called by test target -->
  <target name="test.ant" depends="pack.done">
    <partest showlog="yes" erroronfailed="yes" javacmd="${java.home}/bin/java"
             srcdir="${partest.srcdir}"
             scalacopts="${scalac.args.optimise}">
      <compilationpath refid="partest.classpath"/>
      <anttests dir="${partest.dir}/${partest.srcdir}/ant" includes="*build.xml"/>
    </partest>
  </target>

  <!-- not called by test target -->
  <target name="test.positions" depends="quick.comp">
    <antcall target="test.positions.tests.sub" inheritRefs="true">
      <param name="test.tests.srcs" value="${partest.dir}/files/positions"/>
    </antcall>
    <antcall target="test.positions.sub" inheritRefs="true">
      <param name="test.srcs" value="${src.dir}/compiler"/>
    </antcall>
    <antcall target="test.positions.sub" inheritRefs="true">
      <param name="test.srcs" value="${src.dir}/library"/>
    </antcall>
    <antcall target="test.positions.sub" inheritRefs="true">
      <param name="test.srcs" value="${src.dir}/actors"/>
    </antcall>
    <antcall target="test.positions.sub" inheritRefs="true">
      <param name="test.srcs" value="${src.dir}/dbc"/>
    </antcall>
    <antcall target="test.positions.sub" inheritRefs="true">
      <param name="test.srcs" value="${src.dir}/swing"/>
    </antcall>
    <antcall target="test.positions.sub" inheritRefs="true">
      <param name="test.srcs" value="${src.dir}/partest"/>
    </antcall>
    <antcall target="test.positions.sub" inheritRefs="true">
      <param name="test.srcs" value="${src.dir}/scalap"/>
    </antcall>
    <antcall target="test.positions.tests.sub" inheritRefs="true">
      <param name="test.tests.srcs" value="${partest.dir}/files/pos"/>
    </antcall>
    <antcall target="test.positions.tests.sub" inheritRefs="true">
      <param name="test.tests.srcs" value="${partest.dir}/files/run"/>
    </antcall>
    <antcall target="test.positions.tests.sub" inheritRefs="true">
      <param name="test.tests.srcs" value="${partest.dir}/files/neg"/>
    </antcall>
  </target>

  <target name="test.positions.sub">
    <echo message="Validating positions for: ${test.srcs}"/>
    <if>
      <isfileselected file="${test.srcs}">
        <type type="dir"/>
      </isfileselected>
      <then>
        <property name="srcdir" value="${test.srcs}"/>
        <property name="srcs" value="**/*.scala"/>
      </then>
      <else>
        <dirname property="srcdir" file="${test.srcs}"/>
        <basename property="srcs" file="${test.srcs}"/>
      </else>
    </if>
    <scalacfork
      destdir=""
      compilerpathref="locker.compiler.path"
      srcpath="${srcdir}"
      params="-Xprint-pos -Yide-debug"
      srcdir="${srcdir}"
      jvmargs="${scalacfork.jvmargs}">
      <include name="${srcs}"/>
      <compilationpath refid="test.positions.sub.build.path"/>
    </scalacfork>
  </target>

  <target name="test.positions.tests.sub">
    <foreach target="test.positions.sub"
      inheritAll="true"
      inheritRefs="true"
      param="test.srcs">
      <path>
        <fileset dir="${test.tests.srcs}" includes="*.scala"/>
        <dirset dir="${test.tests.srcs}">
          <include name="*"/>
        </dirset>
      </path>
    </foreach>
  </target>

<!-- ===========================================================================
                                  VISUALIZATION
============================================================================ -->

  <target name="graph.init">
    <taskdef name="vizant" classname="vizant.Vizant" classpath="${lib-ant.dir}/vizant.jar"/>
  </target>

  <target name="graph.all" depends="graph.init">
    <vizant antfile="${ant.file}" outfile="${ant.project.name}.dot" from="all.done"/>
  </target>

  <target name="graph.sabbus" depends="graph.init">
    <vizant antfile="${ant.file}" outfile="${ant.project.name}.dot"/>
  </target>
</project>
