<?xml version="1.0" encoding="UTF-8"?>

<project name="sabbus" default="build" xmlns:artifact="urn:maven-artifact-ant">
  <include file="test/build-partest.xml" as="partest"/>

  <description>
SuperSabbus for Scala core, builds the scala library and compiler. It can also package it as a simple distribution, tests it for stable bootstrapping and against the Scala test suite.
  </description>

<!-- HINTS

 - for faster builds, have a build.properties in the same directory as build.xml that says:
      locker.skip=1
      starr.use.released=1

-->

<!-- USAGE FROM JENKINS SCRIPTS IS (CURRENTLY) AS FOLLOWS:
ant $antArgs $scalacArgs $targets

antArgs tend to be:
 -Darchives.skipxz=true
 -Dscalac.args.optimise=-optimise

scalacArgs examples:
  "-Dscalac.args=\"-Yrangepos\" -Dpartest.scalac_opts=\"-Yrangepos\""

targets exercised:
  locker.done build-opt nightly test.suite test.continuations.suite test.scaladoc
-->

<!-- To use Zinc with the ant build:
  - install zinc and symlink the installed zinc script to ${basedir}/tools/zinc  (${basedir} is where build.xml and the rest of your checkout resides)
  - make sure to set ZINC_OPTS to match ANT_OPTS!
-->

<!--
TODO:
  - detect zinc anywhere on PATH
  - automatically set ZINC_OPTS
  - skip locker (and test.stability) by default to speed up PR validation, still do full build & testing during nightly
  - (rework the build to pack locker and build using that when using zinc)
-->


<!-- ===========================================================================
                                  END-USER TARGETS
============================================================================ -->
  <target name="build"     depends="pack.done"      description="Builds the Scala compiler and library. Executables are in 'build/pack/bin'."/>
  <target name="test"      depends="test.done"      description="Runs test suite and bootstrapping test on Scala compiler and library."/>
  <target name="docs"      depends="docs.done"      description="Builds documentation for the Scala library. Scaladoc is in 'build/scaladoc/library'."/>
  <target name="docscomp"  depends="docs.comp"      description="Builds documentation for the Scala compiler and library. Scaladoc is in 'build/scaladoc'."/>
  <target name="dist" depends="all.clean, all.done" description="Cleans all and builds and tests a new distribution."/>
  <target name="partialdist" depends="dist.partial" description="Makes a new distribution without documentation, so just for testing."/>
  <target name="fastdist"    depends="dist.done"    description="Makes a new distribution without testing it or removing partially build elements."/>

  <target name="build-opt"       description="Optimized version of build.">       <optimized name="build"/></target>
  <target name="test-opt"        description="Optimized version of test.">        <optimized name="test"/></target>
  <target name="dist-opt"        description="Optimized version of dist.">        <optimized name="dist"/></target>
  <target name="partialdist-opt" description="Optimized version of partialdist."> <optimized name="partialdist"/></target>
  <target name="fastdist-opt"    description="Optimized version of fastdist.">    <optimized name="fastdist"/></target>

  <!-- packaging -->
  <target name="distpack" depends="dist.done, docs.done">
    <ant antfile="${src.dir}/build/pack.xml" target="pack-all.done" inheritall="yes" inheritrefs="yes"/></target>

  <target name="distpack-maven" depends="dist.done, docs.done">
    <ant antfile="${src.dir}/build/pack.xml" target="pack-maven.done" inheritall="yes" inheritrefs="yes"/></target>

  <target name="distpack-opt" description="Builds an optimised distribution."> <optimized name="distpack"/></target>
  <target name="distpack-maven-opt" description="Builds an optimised maven distribution."><optimized name="distpack-maven"/></target>

  <target name="all.done" depends="dist.done, test.done"/>

  <!-- must use depends for all.done, not antcall: need the properties defined in there (dist.dir) -->
  <target name="nightly-nopt" depends="all.done, docs.done">
    <ant antfile="${src.dir}/build/pack.xml" target="pack-all.done" inheritall="yes" inheritrefs="yes"/></target>
  <target name="nightly"><optimized name="nightly-nopt"/></target>

  <target name="nightly.checkall">
    <antcall target="nightly-nopt"> <param name="partest.scalac_opts" value="-Ycheck:all"/></antcall></target>

  <target name="clean"       depends="quick.clean"  description="Removes binaries of compiler and library. Locker and distributions are untouched."/>
  <target name="docsclean"   depends="docs.clean"   description="Removes generated documentation. Distributions are untouched."/>
  <target name="distclean"   depends="dist.clean"   description="Removes all distributions. Binaries and documentation are untouched."/>

  <macrodef name="optimized" >
    <attribute name="name"/>
    <sequential>
      <antcall target="@{name}"><param name="scalac.args.optimise" value="-optimise"/></antcall>
    </sequential>
  </macrodef>

<!-- ===========================================================================
                                  PROPERTIES
============================================================================ -->

  <property environment="env"/>
  <!-- Prevents system classpath from being used -->
  <property name="build.sysclasspath"     value="ignore"/>

  <!-- Defines the repository layout -->
  <property name="docs.dir"               value="${basedir}/docs"/>
  <property name="lib.dir"                value="${basedir}/lib"/>
  <property name="src.dir"                value="${basedir}/src"/>
  <property name="partest.dir"            value="${basedir}/test"/>

  <property name="lib-ant.dir"            value="${lib.dir}/ant"/>
  <!-- For developers: any jars placed in this dir will be added to the classpath
       of all targets and copied into quick/pack/etc builds. -->
  <property name="lib-extra.dir"          value="${lib.dir}/extra"/>

  <!-- Loads custom properties definitions -->
  <property file="${basedir}/build.properties"/>

  <!-- Generating version number -->
  <property file="${basedir}/build.number"/>

  <!-- read starr.version -->
  <property file="${basedir}/starr.number"/>

  <!-- Sets location of pre-compiled libraries -->
  <property name="library.starr.jar"       value="${lib.dir}/scala-library.jar"/>
  <property name="reflect.starr.jar"       value="${lib.dir}/scala-reflect.jar"/>
  <property name="compiler.starr.jar"      value="${lib.dir}/scala-compiler.jar"/>
  <property name="jline.jar"               value="${lib.dir}/jline.jar"/>
  <property name="ant.jar"                 value="${ant.home}/lib/ant.jar"/>
  <property name="scalacheck.jar"          value="${lib.dir}/scalacheck.jar"/>

  <!-- Sets location of build folders -->
  <property name="build.dir"               value="${basedir}/build"/>
  <property name="build-libs.dir"          value="${build.dir}/libs"/>
  <property name="build-asm.dir"           value="${build.dir}/asm"/>
  <property name="build-forkjoin.dir"      value="${build-libs.dir}"/>
  <property name="build-locker.dir"        value="${build.dir}/locker"/>
  <property name="build-palo.dir"          value="${build.dir}/palo"/>
  <property name="build-quick.dir"         value="${build.dir}/quick"/>
  <property name="build-pack.dir"          value="${build.dir}/pack"/>
  <property name="build-osgi.dir"          value="${build.dir}/osgi"/>
  <property name="build-junit.dir"         value="${build.dir}/junit"/>
  <property name="build-strap.dir"         value="${build.dir}/strap"/>
  <property name="build-docs.dir"          value="${build.dir}/scaladoc"/>
  <property name="build-sbt.dir"           value="${build.dir}/sbt-interface"/>

  <property name="test.osgi.src"           value="${partest.dir}/osgi/src"/>
  <property name="test.osgi.classes"       value="${build-osgi.dir}/classes"/>

  <property name="test.junit.src"          value="${partest.dir}/junit"/>
  <property name="test.junit.classes"      value="${build-junit.dir}/classes"/>

  <property name="dists.dir"               value="${basedir}/dists"/>

  <property name="copyright.string"        value="Copyright 2002-2013, LAMP/EPFL"/>
  <property name="partest.version.number"  value="0.9.3"/>

  <!-- These are NOT the flags used to run SuperSabbus, but the ones written
       into the script runners created with scala.tools.ant.ScalaTool -->
  <property name="java.flags"              value="-Xmx256M -Xms32M"/>
  <property name="jvm.opts"                value=""/>

  <!-- if ANT_OPTS is already set by the environment, it will be unaltered,
       but if it is unset it will take this default value. -->
  <property name="env.ANT_OPTS"            value="-Xms1536M -Xmx1536M -Xss1M -XX:MaxPermSize=192M -XX:+UseParallelGC" />

  <property name="scalacfork.jvmargs"      value="${env.ANT_OPTS} ${jvm.opts}"/>

<!-- ===========================================================================
                                  INITIALIZATION
============================================================================ -->
  <target name="desired.jars.uptodate">
    <patternset id="desired.jars">
      <include name="lib/**/*.desired.sha1"/>
      <include name="test/files/**/*.desired.sha1"/>
      <include name="tools/**/*.desired.sha1"/>
    </patternset>

    <uptodate property="lib.jars.uptodate">
      <srcfiles dir="${basedir}"><patternset refid="desired.jars"/></srcfiles>
      <mapper type="glob" from="*.desired.sha1" to="*"/>
    </uptodate>
  </target>

  <target name="boot" depends="desired.jars.uptodate" unless="lib.jars.uptodate">
    <echo level="warn" message="Updating bootstrap libs.  (To do this by hand, run ./pull-binary-libs.sh)"/>
    <exec osfamily="unix" vmlauncher="false" executable="./pull-binary-libs.sh" failifexecutionfails="true" />
    <exec osfamily="windows" vmlauncher="false" executable="pull-binary-libs.sh" failifexecutionfails="true" />
    <!-- uptodate task needs to know these are what's in the sha. -->
    <touch>
      <fileset dir="${basedir}"><patternset refid="desired.jars"/></fileset>
      <mapper type="glob" from="*.desired.sha1" to="*"/>
    </touch>
  </target>

  <target name="init" depends="boot">
    <!-- Set up Ant contrib tasks so we can use <if><then><else> instead of the clunky `unless` attribute -->
    <taskdef resource="net/sf/antcontrib/antlib.xml" classpath="${lib-ant.dir}/ant-contrib.jar"/>

    <!-- Add our maven ant tasks -->
    <path id="maven-ant-tasks.classpath" path="${lib-ant.dir}/maven-ant-tasks-2.1.1.jar" />
    <typedef resource="org/apache/maven/artifact/ant/antlib.xml" uri="urn:maven-artifact-ant" classpathref="maven-ant-tasks.classpath" />

    <!-- Resolve maven dependencies -->

    <!-- work around http://jira.codehaus.org/browse/MANTTASKS-203:
         java.lang.ClassCastException: org.codehaus.plexus.DefaultPlexusContainer cannot be cast to org.codehaus.plexus.PlexusContainer
         on repeated use of artifact:dependencies
    -->
    <if><not><isset property="maven-deps-done"></isset></not><then>
      <mkdir dir="${user.home}/.m2/repository"/>
      <!-- This task has an issue where if the user directory does not exist, so we create it above. UGH. -->
      <artifact:dependencies pathId="extra.tasks.classpath" filesetId="extra.tasks.fileset">
        <dependency groupId="biz.aQute" artifactId="bnd" version="1.50.0"/>
      </artifact:dependencies>

      <!-- JUnit -->
      <property name="junit.version" value="4.10"/>
      <artifact:dependencies pathId="junit.classpath" filesetId="junit.fileset">
        <dependency groupId="junit" artifactId="junit" version="${junit.version}"/>
      </artifact:dependencies>

      <!-- Pax runner -->
      <property name="pax.exam.version" value="2.5.0"/>
      <artifact:dependencies pathId="pax.exam.classpath" filesetId="pax.exam.fileset">
        <dependency groupId="org.ops4j.pax.exam" artifactId="pax-exam-container-native" version="${pax.exam.version}"/>
        <dependency groupId="org.ops4j.pax.exam" artifactId="pax-exam-junit4" version="${pax.exam.version}"/>
        <dependency groupId="org.ops4j.pax.exam" artifactId="pax-exam-link-assembly" version="${pax.exam.version}"/>
        <dependency groupId="org.ops4j.pax.url" artifactId="pax-url-aether" version="1.4.0"/>
        <dependency groupId="org.ops4j.pax.swissbox" artifactId="pax-swissbox-framework" version="1.5.1"/>
        <dependency groupId="ch.qos.logback" artifactId="logback-core" version="0.9.20"/>
        <dependency groupId="ch.qos.logback" artifactId="logback-classic" version="0.9.20"/>
        <dependency groupId="junit" artifactId="junit" version="${junit.version}"/>
        <dependency groupId="org.apache.felix" artifactId="org.apache.felix.framework" version="3.2.2"/>
      </artifact:dependencies>


      <artifact:dependencies pathId="partest.extras.classpath" filesetId="partest.extras.fileset" versionsId="partest.extras.versions">
        <dependency groupId="com.googlecode.java-diff-utils" artifactId="diffutils" version="1.3.0"/>
        <dependency groupId="org.scala-tools.testing" artifactId="test-interface" version="0.5" />
      </artifact:dependencies>

      <!-- BND support -->
      <typedef resource="aQute/bnd/ant/taskdef.properties" classpathref="extra.tasks.classpath" />

      <!-- Download STARR via maven if `starr.use.released` is set,
           and `starr.version` is specified (see the starr.number properties file).
           Want to slow down STARR changes, using only released versions. -->
      <if><isset property="starr.use.released"/><then>
        <echo message="Using Scala ${starr.version} for STARR."/>
        <artifact:dependencies pathId="starr.core.path">
          <dependency groupId="org.scala-lang" artifactId="scala-library" version="${starr.version}"/>
          <dependency groupId="org.scala-lang" artifactId="scala-reflect" version="${starr.version}"/>
          <dependency groupId="org.scala-lang" artifactId="scala-compiler" version="${starr.version}"/>
        </artifact:dependencies></then>
      <else>
        <path id="starr.core.path">
          <pathelement location="${library.starr.jar}"/>
          <pathelement location="${reflect.starr.jar}"/>
          <pathelement location="${compiler.starr.jar}"/>
        </path></else>
      </if>

      <property name="maven-deps-done"     value="yep!"/>
    </then></if>


    <!-- NOTE: ant properties are write-once: second writes are silently discarded; the logic below relies on this -->

    <!-- Compute defaults (i.e., if not specified on command-line) for OSGi/maven version suffixes.
      Try to establish the invariant (verified below):
      `version.suffix == maven.version.suffix == osgi.version.suffix`,
      except for:
        - snapshot builds, where:
          - `maven.suffix == "-SNAPSHOT"`
          - `version.suffix == osgi.version.suffix == ""`
        - final builds, where:
          - `osgi.suffix == "-VFINAL"`
          - `version.suffix == maven.version.suffix == ""`
    -->
    <if><not><equals arg1="${version.bnum}" arg2="0"/></not><then>
      <property name="version.suffix"          value="-${version.bnum}"/>
    </then></if>

    <if><or><not><isset property="version.suffix"/></not><equals arg1="${version.suffix}" arg2=""/></or><then>
      <if><isset property="build.release"/><then>
        <property name="maven.version.suffix"  value=""/>
        <property name="version.suffix"        value="${maven.version.suffix}"/>
        <if><equals arg1="${maven.version.suffix}" arg2=""/><then>
          <property name="osgi.version.suffix" value="-VFINAL"/></then>
        <else>
          <property name="osgi.version.suffix" value="${maven.version.suffix}"/></else></if></then></if></then>
    <else> <!-- version.suffix set and not empty -->
      <property name="maven.version.suffix"    value="${version.suffix}"/>
      <property name="osgi.version.suffix"     value="${version.suffix}"/></else></if>

    <!-- if a maven version suffix was set (or inferred), assume we're building a release -->
    <if><isset property="maven.version.suffix"/><then>
      <property name="build.release"  value="1"/></then></if>

    <!-- not building a release and no version.suffix specified -->
    <property name="maven.version.suffix"      value="-SNAPSHOT"/>

    <if><equals arg1="${maven.version.suffix}" arg2="-SNAPSHOT"/><then>
      <property name="osgi.version.suffix"     value=""/>
      <property name="version.suffix"          value=""/></then>
    <else>
      <property name="osgi.version.suffix"     value="${maven.version.suffix}"/>
      <property name="version.suffix"          value="${maven.version.suffix}"/></else></if>


    <exec osfamily="unix" executable="tools/get-scala-commit-sha" outputproperty="git.commit.sha" failifexecutionfails="false" />
    <exec osfamily="windows" executable="cmd.exe" outputproperty="git.commit.sha" failifexecutionfails="false">
      <arg value="/c"/>
      <arg value="tools\get-scala-commit-sha.bat"/>
      <arg value="-p"/>
    </exec>
    <exec osfamily="unix" executable="tools/get-scala-commit-date" outputproperty="git.commit.date" failifexecutionfails="false" />
    <exec osfamily="windows" executable="cmd.exe" outputproperty="git.commit.date" failifexecutionfails="false">
      <arg value="/c"/>
      <arg value="tools\get-scala-commit-date.bat"/>
      <arg value="-p"/>
    </exec>

    <!-- some default in case something went wrong getting the revision -->
    <property name="git.commit.sha"          value="unknown"/>
    <property name="git.commit.date"         value="unknown"/>

    <!-- We use the git describe to determine the OSGi modifier for our build. -->
    <property name="maven.version.number"
      value="${version.major}.${version.minor}.${version.patch}${maven.version.suffix}"/>
    <property name="osgi.version.number"
      value="${version.major}.${version.minor}.${version.patch}.v${git.commit.date}${osgi.version.suffix}-${git.commit.sha}"/>

    <if><isset property="build.release"/><then>
      <property name="version.number"        value="${maven.version.number}"/>
    </then><else>
      <property name="version.number"        value="${version.major}.${version.minor}.${version.patch}${version.suffix}-${git.commit.date}-${git.commit.sha}"/>
    </else></if>

    <condition property="has.java6">
        <equals arg1="${ant.java.version}" arg2="1.6"/>
    </condition>
    <condition property="has.java7">
        <equals arg1="${ant.java.version}" arg2="1.7"/>
    </condition>
    <condition property="has.unsupported.jdk">
       <not><or>
         <isset property="has.java7" />
         <isset property="has.java6" />
       </or></not>
    </condition>

    <fail if="has.unsupported.jdk" message="JDK ${ant.java.version} is not supported by this build!"/>

    <if><isset property="has.java7"/><then>
      <echo level="warning"> You are using JDK7 for this build.
        While this will be able to build most of Scala, it will not build the Swing project.
        You will be unable to create a distribution.
      </echo>
    </then></if>

    <!-- Allow this to be overridden simply -->
    <property name="sbt.latest.version"    value="0.12.2"/>

    <property name="sbt.src.dir"           value="${build-sbt.dir}/${sbt.latest.version}/src"/>
    <property name="sbt.lib.dir"           value="${build-sbt.dir}/${sbt.latest.version}/lib"/>

    <property name="sbt.interface.jar"     value="${sbt.lib.dir}/interface.jar"/>
    <property name="sbt.interface.url"     value="http://typesafe.artifactoryonline.com/typesafe/ivy-releases/org.scala-sbt/interface/${sbt.latest.version}/jars/interface.jar"/>
    <property name="sbt.interface.src.jar" value="${sbt.src.dir}/compiler-interface-src.jar"/>
    <property name="sbt.interface.src.url" value="http://typesafe.artifactoryonline.com/typesafe/ivy-releases/org.scala-sbt/compiler-interface/${sbt.latest.version}/jars/compiler-interface-src.jar"/>


    <!-- Additional command line arguments for scalac. They are added to all build targets -->
    <property name="scalac.args"           value=""/>
    <property name="javac.args"            value=""/>

    <property name="scalac.args.always"    value="" />
    <property name="scalac.args.optimise"  value=""/> <!-- scalac.args.optimise is selectively overridden in certain antcall tasks. -->
    <property name="scalac.args.all"       value="${scalac.args.always} ${scalac.args} ${scalac.args.optimise}"/>
    <property name="scalac.args.locker"    value="${scalac.args.all}"/>
    <property name="scalac.args.quick"     value="${scalac.args.all}"/>
    <property name="scalac.args.strap"     value="${scalac.args.quick}"/>

    <!-- This is the start time for the distribution -->
    <tstamp prefix="time">
      <format property="human" pattern="d MMMM yyyy, HH:mm:ss" locale="en,US"/>
      <format property="short" pattern="yyyyMMddHHmmss"/>
    </tstamp>

    <!-- some default in case something went wrong getting the revision -->
    <property name="version.number"       value="-unknown-"/>
    <property name="init.avail"           value="yes"/>

    <!-- Local libs (developer use.) -->
    <mkdir dir="${lib-extra.dir}"/>

    <!-- Auxiliary libs placed on every classpath. -->
    <path id="aux.libs">
      <pathelement location="${ant.jar}"/>
      <!-- needs ant 1.7.1 -->
      <!-- <fileset dir="${lib-extra.dir}" erroronmissingdir="false"> -->
      <fileset dir="${lib-extra.dir}">
        <include name="**/*.jar"/>
      </fileset>
    </path>

    <!-- And print-out what we are building -->
    <echo message="       build time: ${time.human}" />
    <echo message="     java version: ${java.vm.name} ${java.version} (${ant.java.version})" />
    <echo message="        java args: ${env.ANT_OPTS} ${jvm.opts}" />
    <echo message="       javac args: ${javac.args}" />
    <echo message="      scalac args: ${scalac.args.all}" />
    <echo message="scalac quick args: ${scalac.args.quick}" />
    <echo message="         git date: ${git.commit.date}" />
    <echo message="         git hash: ${git.commit.sha}" />
    <echo message="    maven version: ${maven.version.number}"/>
    <echo message="     OSGi version: ${osgi.version.number}" />
    <echo message="canonical version: ${version.number}" />

    <!-- validate version suffixes -->
    <if><equals arg1="${maven.version.suffix}" arg2="-SNAPSHOT"/><then>
      <condition property="version.suffixes.consistent"><and>
        <equals arg1="${osgi.version.suffix}" arg2=""/>
        <equals arg1="${version.suffix}" arg2=""/>
      </and></condition></then>
    <else>
      <if><equals arg1="${osgi.version.suffix}" arg2="-VFINAL"/><then>
        <condition property="version.suffixes.consistent"><and>
          <equals arg1="${maven.version.suffix}" arg2=""/>
          <equals arg1="${version.suffix}" arg2=""/>
        </and></condition></then>
      <else>
        <condition property="version.suffixes.consistent"><and>
          <equals arg1="${osgi.version.suffix}" arg2="${maven.version.suffix}"/>
          <equals arg1="${version.suffix}" arg2="${maven.version.suffix}"/>
        </and></condition></else></if></else></if>

    <!-- <echo message="    maven suffix: ${maven.version.suffix}"/>
    <echo message="     OSGi suffix: ${osgi.version.suffix}" />
    <echo message="canonical suffix: ${version.suffix}" /> -->
    <fail unless="version.suffixes.consistent" message="Version suffixes inconsistent!"/>

    <path id="forkjoin.classpath" path="${build-libs.dir}/classes/forkjoin"/>
    <path id="asm.classpath"      path="${build-asm.dir}/classes"/>
    <property name="forkjoin-classes" refid="forkjoin.classpath"/>
    <property name="asm-classes" refid="asm.classpath"/>

    <!-- Compilers to use for the various stages.

      There must be a variable of the shape @{stage}.compiler.path  for all @{stage} in starr, locker, quick, strap.
    -->
    <path id="starr.compiler.path">
      <path refid="starr.core.path"/>
      <pathelement location="${lib.dir}/forkjoin.jar"/>
      <path refid="aux.libs"/>
    </path>

    <!-- To skip locker, use -Dlocker.skip=1 -->
    <if><isset property="locker.skip"/><then>
      <echo message="Using STARR to build the quick stage (skipping locker)."/>
      <path id="locker.compiler.path" refid="starr.compiler.path"/>
      <property name="locker.locked" value="locker skipped"/></then>
    <else>
      <path id="locker.compiler.path"><path refid="locker.compiler.build.path"/></path></else></if>

    <!-- compilerpathref for compiling with quick -->
    <path id="quick.compiler.path"> <path refid="quick.compiler.build.path"/></path>


    <!-- What to have on the compilation path when compiling during certain phases.

      There must be a variable of the shape @{stage}.@{project}.build.path
      for all @{stage} in locker, quick, strap
      and all @{project} in library, reflect, compiler
        when stage is quick, @{project} also includes: actors, repl, swing, plugins, scalacheck, interactive, scaladoc, partest, scalap
    -->

    <!-- LOCKER -->
    <path id="locker.library.build.path">
      <pathelement location="${build-locker.dir}/classes/library"/>
      <path refid="forkjoin.classpath"/>
      <path refid="aux.libs"/>
    </path>

    <path id="locker.actors.build.path">
      <path refid="locker.library.build.path"/>
      <pathelement location="${build-locker.dir}/classes/actors"/>
    </path>

    <path id="locker.reflect.build.path">
      <path refid="locker.library.build.path"/>
      <pathelement location="${build-locker.dir}/classes/reflect"/>
    </path>

    <path id="locker.compiler.build.path">
      <path refid="locker.reflect.build.path"/>
      <pathelement location="${build-locker.dir}/classes/compiler"/>
      <path refid="asm.classpath"/>
    </path>

    <!-- QUICK -->
    <path id="quick.library.build.path">
      <pathelement location="${build-quick.dir}/classes/library"/>
      <path refid="forkjoin.classpath"/>
      <path refid="aux.libs"/>
    </path>

    <path id="quick.actors.build.path">
      <path refid="quick.library.build.path"/>
      <pathelement location="${build-quick.dir}/classes/actors"/>
    </path>

    <path id="quick.reflect.build.path">
      <path refid="quick.library.build.path"/>
      <pathelement location="${build-quick.dir}/classes/reflect"/>
    </path>

    <path id="quick.compiler.build.path">
      <path refid="quick.reflect.build.path"/>
      <pathelement location="${build-quick.dir}/classes/compiler"/>
      <path refid="asm.classpath"/>
    </path>

    <path id="quick.repl.build.path">
      <path refid="quick.compiler.build.path"/>
      <pathelement location="${build-quick.dir}/classes/repl"/>
      <pathelement location="${jline.jar}"/>
    </path>

    <path id="quick.swing.build.path">
      <path refid="quick.library.build.path"/>
      <path refid="quick.actors.build.path"/>
      <pathelement location="${build-quick.dir}/classes/swing"/>
    </path>

    <path id="quick.plugins.build.path">
      <path refid="quick.compiler.build.path"/>
      <pathelement location="${build-quick.dir}/classes/continuations-plugin"/>
    </path>

    <path id="quick.scalacheck.build.path">
      <pathelement location="${build-quick.dir}/classes/library"/>
      <pathelement location="${build-quick.dir}/classes/actors"/>
      <pathelement location="${build-quick.dir}/classes/scalacheck"/>
      <path refid="partest.extras.classpath"/>
    </path>

    <path id="quick.scalap.build.path">
      <path refid="quick.compiler.build.path"/>
      <pathelement location="${build-quick.dir}/classes/scalap"/>
      <pathelement location="${build-quick.dir}/classes/partest"/>
    </path>

    <path id="quick.partest.build.path">
      <path refid="quick.scalap.build.path"/>
      <path refid="partest.extras.classpath"/>
      <pathelement location="${build-quick.dir}/classes/repl"/>
      <pathelement location="${scalacheck.jar}"/>
    </path>

    <path id="quick.scaladoc.build.path">
      <path refid="quick.compiler.build.path"/>
      <pathelement location="${build-quick.dir}/classes/partest"/>
      <pathelement location="${build-quick.dir}/classes/scaladoc"/>
    </path>

    <path id="quick.interactive.build.path">
      <path refid="quick.compiler.build.path"/>
      <pathelement location="${build-quick.dir}/classes/scaladoc"/>
      <pathelement location="${build-quick.dir}/classes/interactive"/>
    </path>

    <path id="quick.bin.tool.path">
      <path refid="quick.repl.build.path"/>
      <path refid="quick.actors.build.path"/>
      <pathelement location="${build-quick.dir}/classes/scalap"/>
      <pathelement location="${build-quick.dir}/classes/continuations-library"/>
    </path>

    <!-- PACK -->
    <!-- also used for docs.* targets TODO: use separate paths for those -->
    <path id="pack.compiler.path">
      <pathelement location="${build-pack.dir}/lib/scala-library.jar"/>
      <pathelement location="${build-pack.dir}/lib/scala-reflect.jar"/>
      <pathelement location="${build-pack.dir}/lib/scala-compiler.jar"/>
      <pathelement location="${build-pack.dir}/lib/scala-partest.jar"/>
      <pathelement location="${build-pack.dir}/lib/scalap.jar"/>
      <pathelement location="${build-pack.dir}/lib/scala-actors.jar"/>
      <pathelement location="${ant.jar}"/>
      <path refid="partest.extras.classpath"/>
      <path refid="aux.libs"/>
    </path>

    <path id="pack.bin.tool.path">
      <pathelement location="${build-pack.dir}/lib/scala-library.jar"/>
      <pathelement location="${build-pack.dir}/lib/scala-reflect.jar"/>
      <pathelement location="${build-pack.dir}/lib/scala-compiler.jar"/>
      <pathelement location="${build-pack.dir}/lib/scalap.jar"/>
      <pathelement location="${build-pack.dir}/lib/jline.jar"/>
      <path refid="aux.libs"/>
    </path>

    <path id="pack.library.files">
      <fileset dir="${build-quick.dir}/classes/library"/>
      <fileset dir="${build-quick.dir}/classes/continuations-library"/>
      <fileset dir="${forkjoin-classes}"/>
    </path>

    <path id="pack.actors.files">
      <fileset dir="${build-quick.dir}/classes/actors"/>
    </path>

    <path id="pack.compiler.files">
      <fileset dir="${build-quick.dir}/classes/compiler"/>
      <fileset dir="${build-quick.dir}/classes/repl"/>
      <fileset dir="${build-quick.dir}/classes/scaladoc"/>
      <fileset dir="${build-quick.dir}/classes/interactive"/>
      <fileset dir="${asm-classes}"/>
    </path>

    <path id="pack.swing.files">      <fileset dir="${build-quick.dir}/classes/swing"/> </path>
    <path id="pack.reflect.files">    <fileset dir="${build-quick.dir}/classes/reflect"/> </path>
    <path id="pack.plugins.files">    <fileset dir="${build-quick.dir}/classes/continuations-plugin"/> </path>
    <path id="pack.scalacheck.files"> <fileset dir="${build-quick.dir}/classes/scalacheck"/> </path>
    <path id="pack.scalap.files">     <fileset dir="${build-quick.dir}/classes/scalap"/>
                                      <fileset file="${src.dir}/scalap/decoder.properties"/> </path>

    <path id="pack.partest.files">
      <fileset dir="${build-quick.dir}/classes/partest">
        <exclude name="scala/tools/partest/javaagent/**"/>
      </fileset>
    </path>

    <path id="pack.partest-javaagent.files">
      <fileset dir="${build-quick.dir}/classes/partest">
        <include name="scala/tools/partest/javaagent/**"/>
      </fileset>
    </path>

    <!-- STRAP -->
    <path id="strap.library.build.path">
      <pathelement location="${build-strap.dir}/classes/library"/>
      <path refid="forkjoin.classpath"/>
      <path refid="aux.libs"/>
    </path>

    <path id="strap.reflect.build.path">
      <path refid="strap.library.build.path"/>
      <pathelement location="${build-strap.dir}/classes/reflect"/>
    </path>

    <path id="strap.compiler.build.path">
      <path refid="strap.reflect.build.path"/>
      <pathelement location="${build-strap.dir}/classes/compiler"/>
      <path refid="asm.classpath"/>
    </path>

    <!-- MISC -->
    <path id="sbt.compile.build.path">
      <path refid="quick.compiler.build.path"/>
      <pathelement location="${build-quick.dir}/classes/repl"/>
      <pathelement location="${build-quick.dir}/classes/scaladoc"/>
      <pathelement location="${build-quick.dir}/classes/interactive"/>
      <pathelement location="${sbt.interface.jar}"/>
    </path>

    <path id="manual.classpath">
      <pathelement location="${build-pack.dir}/lib/scala-library.jar"/>
      <pathelement location="${build.dir}/manmaker/classes"/>
    </path>

    <path id="partest.classpath">
      <path refid="pack.compiler.path"/>
      <path refid="partest.extras.classpath"/>
    </path>

    <!-- obsolete? -->
    <!-- TODO - segregate swing tests (there can't be many) -->
    <!--
    <path id="partest.build.path">
      <path refid="pack.compiler.path"/>
      <fileset dir="${partest.dir}/files/lib" includes="*.jar" />
      <pathelement location="${pack.dir}/lib/scala-swing.jar"/>
    </path>
    -->

    <path id="test.junit.compiler.build.path">
      <pathelement location="${test.junit.classes}"/>
      <path refid="quick.compiler.build.path"/>
      <path refid="junit.classpath"/>
    </path>

    <path id="test.osgi.compiler.build.path">
      <pathelement location="${test.osgi.classes}"/>
      <pathelement location="${build-osgi.dir}/org.scala-lang.scala-library.jar"/>
      <pathelement location="${build-osgi.dir}/org.scala-lang.scala-reflect.jar"/>
      <pathelement location="${build-osgi.dir}/org.scala-lang.scala-compiler.jar"/>
      <pathelement location="${build-osgi.dir}/org.scala-lang.scala-actors.jar"/>
      <path refid="pax.exam.classpath"/>
      <path refid="forkjoin.classpath"/>
    </path>

    <path id="palo.bin.tool.path">
      <pathelement location="${build-palo.dir}/lib/scala-library.jar"/>
      <pathelement location="${build-palo.dir}/lib/scala-reflect.jar"/>
      <pathelement location="${build-palo.dir}/lib/scala-compiler.jar"/>
      <pathelement location="${build-palo.dir}/lib/jline.jar"/>
    </path>

    <path id="test.positions.sub.build.path" path="${build-quick.dir}/classes/library"/>

    <!-- TODO: consolidate *.includes -->
    <patternset id="partest.includes">
      <include name="**/*.xml"/>
    </patternset>

    <patternset id="lib.includes">
      <include name="**/*.tmpl"/>
      <include name="**/*.xml"/>
      <include name="**/*.js"/>
      <include name="**/*.css"/>
    </patternset>

    <patternset id="lib.rootdoc.includes">
      <include name="**/*.tmpl"/>
      <include name="**/*.xml"/>
      <include name="**/*.js"/>
      <include name="**/*.css"/>
      <include name="rootdoc.txt"/>
    </patternset>

    <patternset id="comp.includes">
      <include name="**/*.tmpl"/>
      <include name="**/*.xml"/>
      <include name="**/*.js"/>
      <include name="**/*.css"/>
      <include name="**/*.html"/>
      <include name="**/*.properties"/>
      <include name="**/*.swf"/>
      <include name="**/*.png"/>
      <include name="**/*.gif"/>
      <include name="**/*.txt"/>
    </patternset>

    <taskdef resource="scala/tools/ant/sabbus/antlib.xml" classpathref="starr.compiler.path"/>
  </target>

<!-- ===========================================================================
                                  CLEANLINESS
=============================================================================-->
  <target name="libs.clean">                        <clean build="libs"/> <clean build="asm"/>                            </target>
  <target name="quick.clean"  depends="libs.clean">   <clean build="quick"/> <clean build="pack"/> <clean build="strap"/> </target>
  <target name="palo.clean"   depends="quick.clean">    <clean build="palo"/>                                             </target>
  <target name="locker.clean" depends="palo.clean">       <clean build="locker"/>                                         </target>

  <target name="docs.clean"> <clean build="docs"/> <delete dir="${build.dir}/manmaker" includeemptydirs="yes" quiet="yes" failonerror="no"/> </target>
  <target name="dist.clean"> <delete dir="${dists.dir}" includeemptydirs="yes" quiet="yes" failonerror="no"/> </target>

  <target name="all.clean" depends="locker.clean, docs.clean"> <clean build="sbt"/> <clean build="osgi"/> </target>

  <!-- Used by the scala-installer script -->
  <target name="allallclean" depends="all.clean, dist.clean"/>

  <macrodef name="clean">
    <attribute name="build"/>
    <sequential>
      <delete dir="${build-@{build}.dir}" includeemptydirs="yes" quiet="yes" failonerror="no"/>
    </sequential>
  </macrodef>
<!-- ===========================================================================
                                  LOCAL DEPENDENCIES
============================================================================ -->
  <macrodef name="simple-javac" >
    <attribute name="project"/>  <!-- project: asm/forkjoin -->
    <attribute name="args" default=""/>
    <attribute name="jar"  default="yes"/>
    <sequential>
      <uptodate property="@{project}.available" targetfile="${build-libs.dir}/@{project}.complete">
        <srcfiles dir="${src.dir}/@{project}"/></uptodate>
      <if><not><isset property="@{project}.available"/></not><then>
        <stopwatch name="@{project}.timer"/>
        <mkdir dir="${@{project}-classes}"/>
        <javac
          debug="true"
          srcdir="${src.dir}/@{project}"
          destdir="${@{project}-classes}"
          classpath="${@{project}-classes}"
          includes="**/*.java"
          target="1.6" source="1.5"
          compiler="javac1.6">
            <compilerarg line="${javac.args} @{args}"/>
        </javac>
        <if><equals arg1="@{jar}" arg2="yes"/><then>
          <jar whenmanifestonly="fail" destfile="${build-libs.dir}/@{project}.jar" basedir="${@{project}-classes}"/></then></if>
        <stopwatch name="@{project}.timer" action="total"/>
        <mkdir dir="${build-libs.dir}"/>
        <touch file="${build-libs.dir}/@{project}.complete" verbose="no"/>
      </then></if>
    </sequential>
  </macrodef>

  <target name="asm.done"      depends="init"> <simple-javac project="asm" jar="no"/> </target>
  <target name="forkjoin.done" depends="init"> <simple-javac project="forkjoin" args="-XDignore.symbol.file"/></target>

<!-- ===========================================================================
                                  STAGED COMPILATION MACROS
============================================================================ -->
  <macrodef name="staged-javac" >
    <attribute name="stage"/>    <!-- current stage (locker, quick, strap) -->
    <attribute name="project"/>  <!-- project: library/reflect/compiler/actors -->
    <attribute name="destproject" default="@{project}"/> <!-- overrides the output directory; used when building multiple projects into the same directory-->
    <attribute name="args" default=""/>
    <attribute name="excludes" default=""/>

    <sequential>
      <javac
        debug="true"
        srcdir="${src.dir}/@{project}"
        destdir="${build-@{stage}.dir}/classes/@{destproject}"
        includes="**/*.java"
        excludes="@{excludes}"
        target="1.6" source="1.5">
          <compilerarg line="${javac.args} @{args}"/>
          <classpath refid="@{stage}.@{destproject}.build.path"/>
      </javac>
    </sequential>
  </macrodef>

  <!-- Zinc assumes a one-to-one correspondence of output folder to set of source files.
   When compiling different sets of source files in multiple compilations to the same output directory,
   Zinc thinks source files that appeared in an earlier compilation but are absent in the current one,
   were deleted and thus deletes the corresponding output files.

   Note that zinc also requires each arg to scalac to be prefixed by -S.
  -->
  <macrodef name="zinc">
    <attribute name="compilerpathref"   />
    <attribute name="destdir"           />
    <attribute name="srcdir"            />
    <attribute name="srcpath" default="NOT SET"/>        <!-- needed to compile the library, "NOT SET" is just a convention to denote an optional attribute -->
    <attribute name="buildpathref"      />
    <attribute name="params" default="" />
    <attribute name="java-excludes" default=""/>

    <sequential>
      <local name="sources"/>
      <pathconvert pathsep=" " property="sources">
        <fileset dir="@{srcdir}">
          <include name="**/*.java"/>
          <include name="**/*.scala"/>
          <exclude name="@{java-excludes}"/>
        </fileset>
      </pathconvert>
      <local name="args"/>
      <local name="sargs"/>
      <if><not><equals arg1="@{srcpath}" arg2="NOT SET"/></not><then>
        <property name="args" value="@{params} -sourcepath @{srcpath}"/>
      </then></if>
      <property name="args" value="@{params}"/> <!-- default -->

      <!-- HACK: prefix scalac args by -S -->
      <script language="javascript">
        project.setProperty("sargs", project.getProperty("args").trim().replaceAll(" ", " -S"));
      </script>

      <exec osfamily="unix" executable="tools/zinc" failifexecutionfails="true" failonerror="true">
        <arg line="-nailed -compile-order JavaThenScala -scala-path ${ant.refid:@{compilerpathref}} -d @{destdir} -classpath ${toString:@{buildpathref}} ${sargs} ${sources}"/>
      </exec>
    </sequential>
  </macrodef>

  <macrodef name="staged-scalac" >
    <attribute name="with"/>           <!-- will use path `@{with}.compiler.path` to locate scalac -->
    <attribute name="stage"/>          <!-- current stage (locker, quick, strap) -->
    <attribute name="project"/>        <!-- project: library/reflect/compiler/actors -->
    <attribute name="srcpath" default="NOT SET"/>        <!-- needed to compile the library -->
    <attribute name="args" default=""/>                  <!-- additional args -->
    <attribute name="destproject" default="@{project}"/> <!-- overrides the output directory; used when building multiple projects into the same directory-->
    <attribute name="srcdir" default="@{project}"/>
    <attribute name="java-excludes" default=""/>

    <sequential>
      <!-- TODO: detect zinc anywhere on PATH
           use zinc for the quick stage if it's available;
           would use it for locker but something is iffy in sbt: get a class cast error on global phase -->
      <if><and> <available file="tools/zinc"/>
                <equals arg1="@{stage}" arg2="quick"/>
                <not><equals arg1="@{project}" arg2="plugins"/></not> <!-- doesn't work in zinc because it requires the quick compiler, which isn't jarred up-->
          </and><then>
        <zinc taskname="Z.@{stage}.@{project}"
          compilerpathref="@{with}.compiler.path"
          destdir="${build-@{stage}.dir}/classes/@{destproject}"
          srcdir="${src.dir}/@{srcdir}"
          srcpath="@{srcpath}"
          buildpathref="@{stage}.@{project}.build.path"
          params="${scalac.args.@{stage}} @{args}"
          java-excludes="@{java-excludes}"/></then>
      <else>
      <if><equals arg1="@{srcpath}" arg2="NOT SET"/><then>
        <scalacfork taskname="@{stage}.@{project}"
          jvmargs="${scalacfork.jvmargs}"
          compilerpathref="@{with}.compiler.path"
          destdir="${build-@{stage}.dir}/classes/@{destproject}"
          srcdir="${src.dir}/@{srcdir}"
          params="${scalac.args.@{stage}} @{args}">
          <include name="**/*.scala"/>
          <compilationpath refid="@{stage}.@{project}.build.path"/></scalacfork></then>
      <else>
        <scalacfork taskname="@{stage}.@{project}"
          jvmargs="${scalacfork.jvmargs}"
          compilerpathref="@{with}.compiler.path"
          destdir="${build-@{stage}.dir}/classes/@{destproject}"
          srcdir="${src.dir}/@{srcdir}"
          srcpath="@{srcpath}"
          params="${scalac.args.@{stage}} @{args}">
          <include name="**/*.scala"/>
          <compilationpath refid="@{stage}.@{project}.build.path"/></scalacfork></else>
      </if>
      </else></if>
    </sequential>
  </macrodef>

  <macrodef name="staged-uptodate" >
    <attribute name="stage"/>
    <attribute name="project"/>
    <element name="check"/>
    <element name="do"/>

    <sequential>
      <uptodate property="@{stage}.@{project}.available" targetfile="${build-@{stage}.dir}/@{project}.complete">
        <check/>
      </uptodate>
      <if><not><isset property="@{stage}.@{project}.available"/></not><then>
        <do/>
        <touch file="${build-@{stage}.dir}/@{project}.complete" verbose="no"/>
      </then></if>
    </sequential>
  </macrodef>

  <macrodef name="staged-build" >
    <attribute name="with"/>           <!-- will use path `@{with}.compiler.path` to locate scalac -->
    <attribute name="stage"/>          <!-- current stage (locker, quick, strap) -->
    <attribute name="project"/>        <!-- project: library/reflect/compiler/actors -->
    <attribute name="srcpath"       default="NOT SET"/>        <!-- needed to compile the library -->
    <attribute name="args"          default=""/>                  <!-- additional args -->
    <attribute name="includes"      default="comp.includes"/>
    <attribute name="java-excludes" default=""/>
    <attribute name="version"       default=""/> <!-- non-empty for partest and scaladoc: use @{version}.version.number in property file-->

    <sequential>
      <staged-uptodate stage="@{stage}" project="@{project}">
        <check><srcfiles dir="${src.dir}/@{project}"/></check>
        <do>
          <stopwatch name="@{stage}.@{project}.timer"/>
          <mkdir dir="${build-@{stage}.dir}/classes/@{project}"/>
          <staged-javac stage="@{stage}" project="@{project}" excludes="@{java-excludes}"/> <!-- always compile with javac for simplicity and regularity; it's cheap -->
          <staged-scalac with="@{with}" stage="@{stage}" project="@{project}" srcpath="@{srcpath}" args="@{args}" java-excludes="@{java-excludes}"/>
          <if><equals arg1="@{version}" arg2=""/><then>
            <propertyfile file = "${build-@{stage}.dir}/classes/@{project}/@{project}.properties">
              <entry key       = "version.number" value="${version.number}"/>
              <entry key       = "maven.version.number" value="${maven.version.number}"/>
              <entry key       = "osgi.version.number" value="${osgi.version.number}"/>
              <entry key       = "copyright.string" value="${copyright.string}"/>
            </propertyfile>
          </then><else>
            <propertyfile file = "${build-@{stage}.dir}/classes/@{project}/@{project}.properties">
              <entry key       = "version.number" value="${@{version}.version.number}"/>
              <entry key       = "copyright.string" value="${copyright.string}"/>
            </propertyfile>
          </else></if>
          <copy todir="${build-@{stage}.dir}/classes/@{project}">
            <fileset dir="${src.dir}/@{project}">
              <patternset refid="@{includes}"/>
            </fileset>
          </copy>
          <stopwatch name="@{stage}.@{project}.timer" action="total"/>
        </do>
      </staged-uptodate>
    </sequential>
  </macrodef>

  <macrodef name="staged-bin">
    <attribute name="stage"/>
    <attribute name="classpathref" default="NOT SET"/>
    <sequential>
      <staged-uptodate stage="@{stage}" project="bin">
        <check>
          <srcfiles dir="${src.dir}">
            <include name="compiler/scala/tools/ant/templates/**"/>
          </srcfiles>
        </check>
        <do>
          <taskdef name="mk-bin" classname="scala.tools.ant.ScalaTool" classpathref="@{stage}.bin.tool.path"/>
          <mkdir dir="${build-@{stage}.dir}/bin"/>
          <if><equals arg1="@{classpathref}" arg2="NOT SET"/><then>
            <mk-bin file="${build-@{stage}.dir}/bin/scala"    class="scala.tools.nsc.MainGenericRunner" javaFlags="${java.flags}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/scalac"   class="scala.tools.nsc.Main"              javaFlags="${java.flags}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/scaladoc" class="scala.tools.nsc.ScalaDoc"          javaFlags="${java.flags}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/fsc"      class="scala.tools.nsc.CompileClient"     javaFlags="${java.flags}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/scalap"   class="scala.tools.scalap.Main"           javaFlags="${java.flags}"/>
          </then><else>
            <mk-bin file="${build-@{stage}.dir}/bin/scala"    class="scala.tools.nsc.MainGenericRunner" javaFlags="${java.flags}" classpathref="@{classpathref}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/scalac"   class="scala.tools.nsc.Main"              javaFlags="${java.flags}" classpathref="@{classpathref}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/scaladoc" class="scala.tools.nsc.ScalaDoc"          javaFlags="${java.flags}" classpathref="@{classpathref}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/fsc"      class="scala.tools.nsc.CompileClient"     javaFlags="${java.flags}" classpathref="@{classpathref}"/>
            <mk-bin file="${build-@{stage}.dir}/bin/scalap"   class="scala.tools.scalap.Main"           javaFlags="${java.flags}" classpathref="@{classpathref}"/>
          </else></if>
          <chmod perm="ugo+rx" file="${build-@{stage}.dir}/bin/scala"/>
          <chmod perm="ugo+rx" file="${build-@{stage}.dir}/bin/scalac"/>
          <chmod perm="ugo+rx" file="${build-@{stage}.dir}/bin/scaladoc"/>
          <chmod perm="ugo+rx" file="${build-@{stage}.dir}/bin/fsc"/>
          <chmod perm="ugo+rx" file="${build-@{stage}.dir}/bin/scalap"/>
        </do>
      </staged-uptodate>
    </sequential>
  </macrodef>

  <macrodef name="staged-pack">
    <attribute name="project"/>
    <attribute name="targetdir" default="lib"/>
    <attribute name="targetjar" default="scala-@{project}.jar"/>
    <attribute name="destfile"  default="${build-pack.dir}/@{targetdir}/@{targetjar}"/>
    <attribute name="manifest"  default=""/>
    <element name="pre"         optional="true"/>
    <element name="jar-opts"    optional="true"/>

    <sequential>
      <uptodate property="pack.@{project}.available" targetfile="@{destfile}">
        <srcresources>
          <resources refid="pack.@{project}.files"/>
          <!-- <path><pathelement location="${build-quick.dir}/@{project}.complete"/></path> -->
        </srcresources>
      </uptodate>
      <if><not><isset property="pack.@{project}.available"/></not><then>
        <mkdir dir="${build-pack.dir}/@{targetdir}"/>
        <pre/>

        <if><not><equals arg1="@{manifest}" arg2=""/></not><then>
          <jar whenmanifestonly="fail" destfile="@{destfile}" manifest="@{manifest}"> <!-- update="true" makes no difference on my machine, so starting from scratch-->
            <jar-opts/>
            <path refid="pack.@{project}.files"/>
          </jar></then>
        <else>
          <jar whenmanifestonly="fail" destfile="@{destfile}">
            <jar-opts/>
            <path refid="pack.@{project}.files"/>
          </jar>
        </else></if>
      </then></if>
    </sequential>
  </macrodef>

  <macrodef name="staged-docs">
    <attribute name="project"/>
    <attribute name="dir" default="@{project}"/>
    <attribute name="title"/>
    <attribute name="docroot" default="NOT SET"/>
    <element name="includes" implicit="true"/>

    <sequential>
      <staged-uptodate stage="docs" project="@{project}">
        <check><srcfiles dir="${src.dir}/@{dir}"/></check>
        <do>
          <stopwatch name="docs.@{project}.timer"/>
          <mkdir dir="${build-docs.dir}/@{project}"/>
          <if><equals arg1="@{docroot}" arg2="NOT SET"/><then>
            <!-- TODO: introduce docs.@{project}.build.path for classpathref -->
            <scaladoc
              destdir="${build-docs.dir}/@{project}"
              doctitle="@{title}"
              docversion="${version.number}"
              sourcepath="${src.dir}"
              classpathref="pack.compiler.path"
              srcdir="${src.dir}/@{dir}"
              addparams="${scalac.args.all}"
              implicits="on"
              diagrams="on"
              groups="on"
              rawOutput="${scaladoc.raw.output}"
              noPrefixes="${scaladoc.no.prefixes}">
              <includes/>
            </scaladoc>
          </then><else>
            <scaladoc
              destdir="${build-docs.dir}/@{project}"
              doctitle="@{title}"
              docversion="${version.number}"
              sourcepath="${src.dir}"
              classpathref="pack.compiler.path"
              srcdir="${src.dir}/@{dir}"
              docRootContent="${src.dir}/@{project}/@{docroot}"
              addparams="${scalac.args.all}"
              implicits="on"
              diagrams="on"
              groups="on"
              rawOutput="${scaladoc.raw.output}"
              noPrefixes="${scaladoc.no.prefixes}">
              <includes/>
            </scaladoc>
          </else></if>
          <stopwatch name="docs.@{project}.timer" action="total"/>
        </do>
      </staged-uptodate>
    </sequential>
  </macrodef>

<!-- ===========================================================================
                                  LOCAL REFERENCE BUILD (LOCKER)
============================================================================ -->
  <target name="locker.start"  depends="asm.done, forkjoin.done">
    <condition property="locker.locked"><available file="${build-locker.dir}/locker.locked"/></condition></target>

  <target name="locker.lib"    depends="locker.start"     unless="locker.locked">
    <staged-build with="starr" stage="locker" project="library" srcpath="${src.dir}/library" includes="lib.includes"/></target>

  <target name="locker.actors" depends="locker.lib"       unless="locker.locked">
    <staged-build with="starr" stage="locker" project="actors"/> </target>

  <target name="locker.reflect" depends="locker.lib"      unless="locker.locked">
    <staged-build with="starr" stage="locker" project="reflect"/></target>

  <target name="locker.comp"    depends="locker.reflect" unless="locker.locked">
    <staged-build with="starr" stage="locker" project="compiler"/></target>

  <target name="locker.done"    depends="locker.comp">
    <mkdir dir="${build-locker.dir}"/>
    <touch file="${build-locker.dir}/locker.locked" verbose="no"/>
  </target>
  <target name="locker.unlock"> <delete file="${build-locker.dir}/locker.locked"/>
                                <delete file="${build-locker.dir}/*.complete"/></target>

<!-- ===========================================================================
                                  QUICK BUILD (QUICK)
============================================================================ -->
  <target name="quick.start"      depends="locker.done"/>

  <target name="quick.lib"        depends="quick.start">
    <staged-build with="locker"   stage="quick" project="library" srcpath="${src.dir}/library" includes="lib.rootdoc.includes"/></target>

  <target name="quick.actors"     depends="quick.lib">
    <staged-build with="locker"   stage="quick" project="actors"/> </target>

  <target name="quick.reflect"    depends="quick.lib">
    <staged-build with="locker"   stage="quick" project="reflect"/> </target>

  <target name="quick.comp"       depends="quick.reflect">
    <staged-build with="locker"   stage="quick" project="compiler"/> </target>

  <target name="quick.repl"       depends="quick.comp">
    <staged-build with="locker"   stage="quick" project="repl"/> </target>

  <target name="quick.scalacheck" depends="quick.actors, quick.lib">
    <staged-build with="locker"   stage="quick" project="scalacheck" args="-nowarn"/> </target>

  <target name="quick.scalap"     depends="quick.repl">
    <staged-build with="locker"   stage="quick" project="scalap"/> </target>

  <target name="quick.partest"    depends="quick.scalap, quick.repl, asm.done">
    <staged-build with="locker"   stage="quick" project="partest" version="partest"/> </target>

  <target name="quick.scaladoc" depends="quick.comp, quick.partest">
    <staged-build with="locker" stage="quick" project="scaladoc" version="scaladoc"/> </target>

  <target name="quick.interactive" depends="quick.comp, quick.scaladoc">
    <staged-build with="locker"   stage="quick" project="interactive"/> </target>

  <target name="quick.swing"      depends="quick.actors, quick.lib" if="has.java6">
    <staged-build with="locker"   stage="quick" project="swing"/> </target>

  <target name="quick.plugins"    depends="quick.comp">
    <staged-uptodate              stage="quick" project="plugins">
      <check><srcfiles dir="${src.dir}/continuations"/></check>
      <do>
        <stopwatch name="quick.plugins.timer"/>

        <mkdir dir="${build-quick.dir}/classes/continuations-plugin"/>
        <staged-scalac with="locker" stage="quick" project="plugins" srcdir="continuations/plugin" destproject="continuations-plugin"/>
        <copy
           file="${src.dir}/continuations/plugin/scalac-plugin.xml"
           todir="${build-quick.dir}/classes/continuations-plugin"/>

        <!-- not very nice to create jar here but needed to load plugin -->
        <mkdir dir="${build-quick.dir}/misc/scala-devel/plugins"/>
        <jar whenmanifestonly="fail" destfile="${build-quick.dir}/misc/scala-devel/plugins/continuations.jar" basedir="${build-quick.dir}/classes/continuations-plugin"/>

        <!-- might split off library part into its own ant target -->
        <mkdir dir="${build-quick.dir}/classes/continuations-library"/>
        <!-- TODO: must build with quick to avoid
        [quick.plugins] error: java.lang.NoClassDefFoundError: scala/tools/nsc/transform/patmat/PatternMatching
        [quick.plugins] 	at scala.tools.selectivecps.SelectiveCPSTransform.newTransformer(SelectiveCPSTransform.scala:29)

        WHY OH WHY!? scala/tools/nsc/transform/patmat/PatternMatching should be on locker.compiler.path
        -->
        <staged-scalac with="quick" stage="quick" project="plugins"
                       srcdir="continuations/library" destproject="continuations-library"
                       args="-Xplugin-require:continuations -P:continuations:enable -Xpluginsdir ${build-quick.dir}/misc/scala-devel/plugins"/>

        <stopwatch name="quick.plugins.timer" action="total"/>
      </do>
    </staged-uptodate>
  </target>

  <target name="quick.bin" depends="quick.lib, quick.reflect, quick.comp, quick.repl, quick.scalacheck, quick.scalap, quick.interactive, quick.swing, quick.plugins, quick.partest, quick.scaladoc">
    <staged-bin stage="quick" classpathref="quick.bin.tool.path"/>
  </target>

  <target name="quick.done" depends="quick.bin"/>
  <target name="quick-opt" description="Optimized version of quick.done."> <optimized name="quick.done"/></target>


<!-- ===========================================================================
                                  PACKED QUICK BUILD (PACK)
============================================================================ -->
  <target name="pack.lib"    depends="quick.lib, quick.plugins, forkjoin.done">
    <staged-pack project="library"/></target>

  <target name="pack.actors"  depends="quick.lib">                <staged-pack project="actors"/> </target>
  <target name="pack.swing" if="has.java6" depends="quick.swing"> <staged-pack project="swing"/> </target>
  <target name="pack.reflect" depends="quick.reflect">            <staged-pack project="reflect"/> </target>

  <target name="pack.comp"    depends="quick.comp, quick.scaladoc, quick.interactive, quick.repl, asm.done">
    <staged-pack project="compiler" manifest="${build-pack.dir}/META-INF/MANIFEST.MF">
      <pre> <!-- TODO the files copied here do not influence actuality of this target (nor does the manifest) -->
        <copy file="${jline.jar}" toDir="${build-pack.dir}/lib"/>
        <copy todir="${build-pack.dir}/lib">
          <fileset dir="${lib-extra.dir}">
            <include name="**/*.jar"/>
          </fileset>
        </copy>
        <mkdir dir="${build-pack.dir}/META-INF"/>
        <copy file="${basedir}/META-INF/MANIFEST.MF" toDir="${build-pack.dir}/META-INF"/>
        <manifest file="${build-pack.dir}/META-INF/MANIFEST.MF" mode="update">
          <attribute name="Bundle-Version" value="${version.number}"/>
          <attribute name="Class-Path" value="scala-reflect.jar scala-library.jar"/>
        </manifest>
      </pre>
      <jar-opts>
        <service type="javax.script.ScriptEngineFactory" provider="scala.tools.nsc.interpreter.IMain$Factory"/>
      </jar-opts>
    </staged-pack>
  </target>

  <target name="pack.plugins"    depends="quick.plugins">    <staged-pack project="plugins"    targetdir="misc/scala-devel/plugins" targetjar="continuations.jar"/> </target>
  <target name="pack.scalacheck" depends="quick.scalacheck"> <staged-pack project="scalacheck" targetjar="scalacheck.jar"/> </target>

  <target name="pack.partest" depends="quick.partest">
    <staged-pack project="partest"/>
     <!-- TODO the manifest should influence actuality of this target -->
    <staged-pack project="partest-javaagent" manifest="${src.dir}/partest/scala/tools/partest/javaagent/MANIFEST.MF"/>
  </target>

  <target name="pack.scalap"     depends="quick.scalap">     <staged-pack project="scalap"     targetjar="scalap.jar"/> </target>

  <target name="pack.bin" depends="pack.comp, pack.lib, pack.actors, pack.partest, pack.plugins, pack.reflect, pack.scalacheck, pack.scalap, pack.swing">
    <staged-bin stage="pack"/>
  </target>

  <!-- depend on quick.done so quick.bin is run when pack.done is -->
  <target name="pack.done" depends="quick.done, pack.bin">
    <!-- copy dependencies to build/pack/lib, it only takes a second so don't bother with uptodate checks -->
    <copy todir="${build-pack.dir}/lib">
      <resources refid="partest.extras.fileset"/>
      <mapper classpathref="maven-ant-tasks.classpath" classname="org.apache.maven.artifact.ant.VersionMapper"
              from="${partest.extras.versions}" to="flatten"/>
    </copy>

    <taskdef resource="scala/tools/ant/antlib.xml" classpathref="pack.compiler.path"/>
    <taskdef resource="scala/tools/partest/antlib.xml" classpathref="partest.classpath"/>
  </target>


<!-- ===========================================================================
                                  BOOTSTRAPPING BUILD (STRAP)
============================================================================ -->
  <target name="strap.done" depends="pack.done">
    <staged-build with="pack" stage="strap" project="library" srcpath="${src.dir}/library" includes="lib.rootdoc.includes"/>
    <staged-build with="pack" stage="strap" project="reflect"/>
    <staged-build with="pack" stage="strap" project="compiler"/>
  </target>

  <target name="strap-opt" description="Optimized version of strap.done."> <optimized name="strap.done"/></target>


<!-- ===========================================================================
                                  PACKED LOCKER BUILD (PALO)
============================================================================ -->
  <target name="palo.done" depends="locker.done">
    <mkdir dir="${build-palo.dir}/lib"/>
    <jar whenmanifestonly="fail" destfile="${build-palo.dir}/lib/scala-library.jar">
      <fileset dir="${build-locker.dir}/classes/library"/>
      <fileset dir="${forkjoin-classes}"/>
    </jar>
    <jar whenmanifestonly="fail" destfile="${build-palo.dir}/lib/scala-reflect.jar" manifest="${basedir}/META-INF/MANIFEST.MF"
      basedir="${build-locker.dir}/classes/reflect"/>
    <jar whenmanifestonly="fail" destfile="${build-palo.dir}/lib/scala-compiler.jar" manifest="${basedir}/META-INF/MANIFEST.MF">
      <fileset dir="${build-locker.dir}/classes/compiler"/>
      <fileset dir="${asm-classes}"/>
    </jar>
    <copy file="${jline.jar}" toDir="${build-palo.dir}/lib"/>
  </target>

  <target name="palo.bin" depends="palo.done"> <staged-bin stage="palo"/></target>


<!-- ===========================================================================
                                  OSGi Artifacts
============================================================================ -->
  <target name="osgi.done" depends="pack.done">
    <mkdir dir="${build-osgi.dir}"/>

    <!-- simplify fixing pom versions -->
    <macrodef name="make-bundle">
      <attribute name="name" />
      <attribute name="version" />
      <sequential>
        <copy file="${src.dir}/build/bnd/@{name}.bnd" tofile="${build-osgi.dir}/@{name}.bnd" overwrite="true">
          <filterset>
            <filter token="VERSION" value="@{version}" />
          </filterset>
        </copy>
        <bnd classpath="${build-pack.dir}/lib/@{name}.jar"
             eclipse="false"
             failok="false"
             exceptions="true"
             files="${build-osgi.dir}/@{name}.bnd"
             output="${build-osgi.dir}"/>
      </sequential>
    </macrodef>
    <macrodef name="make-plugin-bundle">
      <attribute name="name" />
      <attribute name="version" />
      <sequential>
        <copy file="${src.dir}/build/bnd/@{name}.bnd" tofile="${build-osgi.dir}/@{name}.bnd" overwrite="true">
          <filterset>
            <filter token="VERSION" value="@{version}" />
          </filterset>
        </copy>
        <bnd classpath="${build-pack.dir}/misc/scala-devel/plugins/@{name}.jar"
             eclipse="false"
             failok="false"
             exceptions="true"
             files="${build-osgi.dir}/@{name}.bnd"
             output="${build-osgi.dir}"/>
      </sequential>
    </macrodef>

    <uptodate property="osgi.bundles.available" targetfile="${build-osgi.dir}/bundles.complete">
      <srcfiles dir="${basedir}">
        <include name="build.xml"/>
        <include name="src/build/bnd/*.bnd"/>
      </srcfiles>
    </uptodate>

    <if><not><isset property="osgi.bundles.available"/></not><then>
      <stopwatch name="osgi.bundle.timer"/>
      <make-bundle name="scala-library" version="${osgi.version.number}" />
      <make-bundle name="scala-actors" version="${osgi.version.number}" />
      <make-bundle name="scala-reflect" version="${osgi.version.number}" />
      <make-bundle name="scala-compiler" version="${osgi.version.number}" />
      <make-plugin-bundle name="continuations" version="${osgi.version.number}" />
      <touch file="${build-osgi.dir}/bundles.complete" verbose="no"/>

      <if><isset property="has.java6"/><then>
        <make-bundle name="scala-swing" version="${osgi.version.number}"/></then>
      </if>
      <stopwatch name="osgi.bundle.timer" action="total"/></then>
    </if>
  </target>


<!-- ===========================================================================
                                  TEST SUITE
============================================================================ -->
  <!-- bootstrapping stability: compare {quick,strap}/(lib|reflect|comp) -->
  <target name="test.stability" depends="strap.done">
    <exec osfamily="unix" vmlauncher="false" executable="${basedir}/tools/stability-test.sh" failonerror="true" />
    <!-- I think doing it this way means it will auto-pass on windows... that's the idea. If not, something like this. -->
    <!-- <exec osfamily="windows" executable="foo" failonerror="false" failifexecutionfails="false" /> -->
  </target>

  <target name="test.stability-opt" description="Optimized version of test.stability."> <optimized name="test.stability"/></target>

  <target name="test.osgi.init" depends="osgi.done">
    <uptodate property="test.osgi.available" targetfile="${build-osgi.dir}/test-compile.complete">
      <srcfiles dir="${test.osgi.src}">
        <include name="**/*.scala"/>
      </srcfiles>
    </uptodate>
  </target>

  <target name="test.osgi.comp" depends="test.osgi.init, quick.done" unless="test.osgi.available">
    <stopwatch name="test.osgi.compiler.timer"/>
    <mkdir dir="${test.osgi.classes}"/>
    <scalacfork
      destdir="${test.osgi.classes}"
      compilerpathref="quick.compiler.path"
      params="${scalac.args.quick}"
      srcdir="${test.osgi.src}"
      jvmargs="${scalacfork.jvmargs}">
      <include name="**/*.scala"/>
      <compilationpath refid="test.osgi.compiler.build.path"/>
    </scalacfork>
    <touch file="${build-osgi.dir}/test-compile.complete" verbose="no"/>
    <stopwatch name="test.osgi.compiler.timer" action="total"/>
  </target>

  <target name="test.osgi" depends="test.osgi.comp">
    <stopwatch name="test.osgi.timer"/>
    <mkdir dir="${test.osgi.classes}"/>
    <junit fork="yes" haltonfailure="yes">
      <classpath refid="test.osgi.compiler.build.path"/>
      <batchtest fork="yes" todir="${build-osgi.dir}">
        <fileset dir="${test.osgi.classes}">
          <include name="**/*Test.class"/>
        </fileset>
      </batchtest>
      <formatter type="brief" /> <!-- silenced by having it use a file; I tried for an hour to use other formatters but classpath issues drove me to this usefile="false" -->
    </junit>
    <stopwatch name="test.osgi.timer" action="total"/>
  </target>


<!-- ===========================================================================
                                  SBT Compiler Interface
============================================================================ -->
  <target name="test.sbt" depends="quick.done">
    <if><not><and>
        <available file="${sbt.interface.jar}"/>
        <available file="${sbt.interface.src.jar}"/></and></not>
    <then>
      <!-- Ensure directories exist -->
      <mkdir dir="${sbt.src.dir}"/>
      <mkdir dir="${sbt.lib.dir}"/>

      <get src="${sbt.interface.url}" dest="${sbt.interface.jar}"/>
      <get src="${sbt.interface.src.url}" dest="${sbt.interface.src.jar}"/>

      <!-- Explode sources -->
      <unzip src="${sbt.interface.src.jar}" dest="${sbt.src.dir}"/>
    </then></if>

    <stopwatch name="quick.sbt-interface.timer"/>
    <mkdir dir="${build-sbt.dir}/classes"/>
    <scalacfork
      destdir="${build-sbt.dir}/classes"
      compilerpathref="quick.compiler.path"
      params="${scalac.args.quick}"
      srcdir="${sbt.src.dir}"
      jvmargs="${scalacfork.jvmargs}">
      <include name="**/*.scala"/>
      <compilationpath refid="sbt.compile.build.path"/>
    </scalacfork>
    <touch file="${build-sbt.dir}/sbt-interface.complete" verbose="no"/>
    <stopwatch name="quick.sbt-interface.timer" action="total"/>
  </target>

  <target name="test.junit.init" depends="quick.done">
    <uptodate property="test.junit.available" targetfile="${build-junit.dir}/test-compile.complete">
      <srcfiles dir="${test.junit.src}">
        <include name="**/*.scala"/>
      </srcfiles>
    </uptodate>
  </target>

  <target name="test.junit.comp" depends="test.junit.init, quick.done" unless="test.junit.available">
    <stopwatch name="test.junit.compiler.timer"/>
    <mkdir dir="${test.junit.classes}"/>
    <scalacfork
      destdir="${test.junit.classes}"
      compilerpathref="quick.compiler.path"
      params="${scalac.args.quick}"
      srcdir="${test.junit.src}"
      jvmargs="${scalacfork.jvmargs}">
      <include name="**/*.scala"/>
      <compilationpath refid="test.junit.compiler.build.path"/>
    </scalacfork>
    <touch file="${build-junit.dir}/test-compile.complete" verbose="no"/>
    <stopwatch name="test.junit.compiler.timer" action="total"/>
  </target>

  <target name="test.junit" depends="test.junit.comp">
    <stopwatch name="test.junit.timer"/>
    <mkdir dir="${test.junit.classes}"/>
    <junit fork="yes" haltonfailure="yes" showoutput="yes" printsummary="on">
      <classpath refid="test.junit.compiler.build.path"/>
      <batchtest fork="yes" todir="${build-junit.dir}">
        <fileset dir="${test.junit.classes}">
          <include name="**/*Test.class"/>
        </fileset>
      </batchtest>
      <formatter type="plain"/>
    </junit>
    <stopwatch name="test.junit.timer" action="total"/>
  </target>

  <!-- See test/build-partest.xml for the macro(s) being used here. -->

  <target name="test.suite" depends="pack.done">
    <testSuite/>
  </target>

  <target name="test.suite.color" depends="pack.done">
    <testSuite colors="8"/>
  </target>

  <target name="test.run" depends="pack.done">
    <testSuite kinds="run jvm"/>
  </target>

  <target name="test.continuations.suite" depends="pack.done">
    <testSuite kinds="continuations-neg continuations-run"
          scalacOpts="${scalac.args.optimise} -Xpluginsdir ${build-quick.dir}/misc/scala-devel/plugins -Xplugin-require:continuations -P:continuations:enable"
    />
  </target>

  <target name="test.scaladoc" depends="pack.done">
    <testSuite kinds="run scalacheck" srcdir="scaladoc"/>
  </target>

  <target name="test.interactive" depends="pack.done">
    <testSuite kinds="presentation"/>
  </target>

  <!-- for use in PR validation, where stability is rarely broken, so we're going to use starr for locker,
       and skip test.stability (which requires locker == quick) -->
  <target name="test.core" depends="test.osgi, test.sbt, test.bc, test.junit, test.interactive, test.continuations.suite, test.scaladoc, test.suite"/>
  <target name="test.done" depends="test.core, test.stability"/>

<!-- ===========================================================================
                                  BINARY COMPATIBILITY TESTING
============================================================================ -->
  <target name="bc.init" depends="init" unless="maven-deps-done-mima">
    <property name="bc-reference-version" value="2.11.0"/>

    <property name="bc-build.dir" value="${build.dir}/bc"/>
    <!-- Obtain mima -->
    <mkdir dir="${bc-build.dir}"/>
    <!-- Pull down MIMA -->
    <artifact:dependencies pathId="mima.classpath">
      <dependency groupId="com.typesafe" artifactId="mima-reporter_2.9.2" version="0.1.5"/>
    </artifact:dependencies>
    <artifact:dependencies pathId="old.bc.classpath">
      <dependency groupId="org.scala-lang" artifactId="scala-swing" version="${bc-reference-version}"/>
      <dependency groupId="org.scala-lang" artifactId="scala-library" version="${bc-reference-version}"/>
      <dependency groupId="org.scala-lang" artifactId="scala-reflect" version="${bc-reference-version}"/>
    </artifact:dependencies>
    <property name="maven-deps-done-mima" value="true"/>
  </target>

  <macrodef name="bc.run-mima">
    <attribute name="jar-name"/>
    <attribute name="prev"/>
    <attribute name="curr"/>
    <attribute name="direction"/>
    <sequential>
      <echo message="Checking @{direction} binary compatibility for @{jar-name} (against ${bc-reference-version})"/>
      <java taskname="mima"
         fork="true"
         failonerror="true"
         classname="com.typesafe.tools.mima.cli.Main">
           <arg value="--prev"/>
           <arg value="@{prev}"/>
           <arg value="--curr"/>
           <arg value="@{curr}"/>
           <arg value="--filters"/>
           <arg value="${basedir}/bincompat-@{direction}.whitelist.conf"/>
           <arg value="--generate-filters"/>
           <classpath>
             <path refid="mima.classpath"/>
           </classpath>
      </java>
    </sequential>
  </macrodef>

  <macrodef name="bc.check">
    <attribute name="jar-name"/>
    <sequential>
        <bc.run-mima
                jar-name="@{jar-name}"
                prev="${org.scala-lang:@{jar-name}:jar}"
                curr="${build-pack.dir}/lib/@{jar-name}.jar"
                direction="backward"/>
        <bc.run-mima
                jar-name="@{jar-name}"
                prev="${build-pack.dir}/lib/@{jar-name}.jar"
                curr="${org.scala-lang:@{jar-name}:jar}"
                direction="forward"/>
    </sequential>
  </macrodef>

  <target name="test.bc-opt" description="Optimized version of test.bc."> <optimized name="test.bc"/></target>

  <!-- Enable after the release of the 2.11.0 or a prior RC that estabilishes the new baseline. -->
  <target name="test.bc"></target>
  <target name="test.bc.disabled" depends="bc.init, pack.lib, pack.reflect, pack.swing">
    <bc.check jar-name="scala-library"/>
    <bc.check jar-name="scala-reflect"/>
    <bc.check jar-name="scala-swing"/>
  </target>

<!-- ===========================================================================
                                  DOCUMENTATION
============================================================================ -->
  <target name="docs.start" depends="pack.done">
    <!-- Set the github commit scaladoc sources point to -->
    <!-- For releases, look for the tag with the same name as the maven version -->
    <condition property="scaladoc.git.commit" value="v${maven.version.number}">
      <isset property="build.release"/>
    </condition>
    <!-- For snapshots, if we know the commit, point scaladoc to that particular commit instead of master -->
    <condition property="scaladoc.git.commit" value="${git.commit.sha}">
      <not><equals arg1="${git.commit.sha}" arg2="unknown"/></not>
    </condition>
    <!-- Fallback: point scaladoc to master -->
    <property name="scaladoc.git.commit" value="master"/>
    <!-- Compute the URL and show it -->
    <property name="scaladoc.url" value="https://github.com/scala/scala/tree/${scaladoc.git.commit}/src"/>
    <echo message="Scaladoc will point to ${scaladoc.url} for source files."/>

    <!-- Unless set with -Dscaladoc.<...>, these won't be activated -->
    <property name="scaladoc.raw.output" value="no"/>
    <property name="scaladoc.no.prefixes" value="no"/>
  </target>

  <target name="docs.lib" depends="docs.start">
    <staged-uptodate stage="docs" project="library">
      <check><srcfiles dir="${src.dir}">
        <include name="library/**"/>
        <include name="swing/**"/>
        <include name="actors/**"/>
        <include name="reflect/**"/>
        <include name="continuations/library/**"/>
      </srcfiles></check>
      <do>
        <stopwatch name="docs.lib.timer"/>
        <mkdir dir="${build-docs.dir}/library"/>
        <!-- last three attributes not supported by staged-docs: -->
        <scaladoc
          destdir="${build-docs.dir}/library"
          doctitle="Scala Standard Library API (Scaladoc)"
          docversion="${version.number}"
          docsourceurl="${scaladoc.url}€{FILE_PATH}.scala#L1"
          sourcepath="${src.dir}"
          classpathref="pack.compiler.path"
          addparams="${scalac.args.all}"
          docRootContent="${src.dir}/library/rootdoc.txt"
          implicits="on"
          diagrams="on"
          groups="on"
          rawOutput="${scaladoc.raw.output}"
          noPrefixes="${scaladoc.no.prefixes}"
          docfooter="epfl"
          docUncompilable="${src.dir}/library-aux"
          skipPackages="scala.reflect.macros.internal:scala.reflect.internal:scala.reflect.io:scala.concurrent.impl">
          <src>
            <files includes="${src.dir}/actors"/>
            <files includes="${src.dir}/library"/>
            <files includes="${src.dir}/reflect"/>
            <files includes="${src.dir}/swing"/>
            <files includes="${src.dir}/continuations/library"/>
          </src>
          <include name="**/*.scala"/>
          <exclude name="reflect/Code.scala"/>
          <exclude name="reflect/Print.scala"/>
          <exclude name="reflect/Symbol.scala"/>
          <exclude name="reflect/Tree.scala"/>
          <exclude name="reflect/Type.scala"/>
          <exclude name="runtime/*$.scala"/>
          <exclude name="runtime/ScalaRunTime.scala"/>
          <exclude name="runtime/StringAdd.scala"/>
        </scaladoc>
        <stopwatch name="docs.lib.timer" action="total"/>
      </do>
    </staged-uptodate>
  </target>

  <target name="docs.comp" depends="docs.start">
    <staged-docs project="compiler" title="Scala Compiler" docroot="rootdoc.txt">
      <include name="**/*.scala"/>
    </staged-docs>
  </target>

  <target name="docs.jline" depends="docs.start">
    <staged-docs project="jline" dir="jline/src/main/java" title="Scala JLine">
      <include name="**/*.scala"/>
      <include name="**/*.java"/>
    </staged-docs>
  </target>

  <target name="docs.scalap" depends="docs.start">
    <staged-docs project="scalap" title="Scalap">
      <include name="**/*.scala"/>
    </staged-docs>
  </target>

  <target name="docs.partest" depends="docs.start">
    <staged-docs project="partest" title="Scala Parallel Testing Framework">
      <include name="**/*.scala"/>
    </staged-docs>
  </target>

  <target name="docs.continuations-plugin" depends="docs.start">
    <staged-docs project="continuations-plugin" dir="continuations/plugin" title="Delimited Continuations Compiler Plugin">
      <include name="**/*.scala"/>
    </staged-docs>
  </target>

  <target name="docs.man" depends="docs.start">
    <staged-uptodate stage="docs" project="manual">
      <check><srcfiles dir="${src.dir}/manual"/></check>
      <do>
        <mkdir dir="${build.dir}/manmaker/classes"/>
        <scalac
          destdir="${build.dir}/manmaker/classes"
          classpathref="pack.compiler.path"
          srcdir="${src.dir}/manual"
          includes="**/*.scala"
          addparams="${scalac.args.all}"/>
        <mkdir dir="${build-docs.dir}/manual/man/man1"/>
        <mkdir dir="${build-docs.dir}/manual/html"/>
        <mkdir dir="${build-docs.dir}/manual/genman/man1"/>
        <taskdef name="genman"
                 classname="scala.tools.docutil.ManMaker"
                 classpathref="manual.classpath"/>
        <genman command="fsc, scala, scalac, scaladoc, scalap"
                htmlout="${build-docs.dir}/manual/html"
                manout="${build-docs.dir}/manual/genman"/>
        <!-- On Windows source and target files can't be the same ! -->
        <fixcrlf
          srcdir="${build-docs.dir}/manual/genman"
          destdir="${build-docs.dir}/manual/man"
          eol="unix" includes="**/*.1"/>
        <copy todir="${build-docs.dir}/manual/html">
          <fileset dir="${src.dir}/manual/scala/tools/docutil/resources">
            <include name="**/*.html"/>
            <include name="**/*.css"/>
            <include name="**/*.gif"/>
            <include name="**/*.png"/>
          </fileset>
        </copy>
      </do>
    </staged-uptodate>
  </target>

  <target name="docs.done" depends="docs.jline, docs.comp, docs.man, docs.lib, docs.scalap, docs.partest, docs.continuations-plugin"/>


<!-- ===========================================================================
                                  DISTRIBUTION
============================================================================ -->
  <target name="dist.base" depends="pack.done, osgi.done">
    <property name="dist.name" value="scala-${version.number}"/>
    <property name="dist.dir" value="${dists.dir}/${dist.name}"/>

    <macrodef name="copy-bundle">
      <attribute name="name" />
      <sequential>
        <copy file="${build-osgi.dir}/org.scala-lang.@{name}.jar"
          tofile="${dist.dir}/lib/@{name}.jar"/>
      </sequential>
    </macrodef>
    <macrodef name="copy-plugin-bundle">
      <attribute name="name" />
      <sequential>
        <copy file="${build-osgi.dir}/org.scala-lang.plugins.@{name}.jar"
          tofile="${dist.dir}/misc/scala-devel/plugins/@{name}.jar"
          overwrite="yes"/>
      </sequential>
    </macrodef>

    <mkdir dir="${dist.dir}/lib"/>
    <copy toDir="${dist.dir}/lib">
      <fileset dir="${build-pack.dir}/lib">
        <include name="jline.jar"/>
        <include name="scalacheck.jar"/>
        <include name="scala-partest.jar"/>
        <include name="scalap.jar"/>
      </fileset>
    </copy>

    <copy todir="${dist.dir}/lib">
      <resources refid="partest.extras.fileset"/>
      <mapper classpathref="maven-ant-tasks.classpath" classname="org.apache.maven.artifact.ant.VersionMapper"
              from="${partest.extras.versions}" to="flatten"/>
    </copy>

    <mkdir dir="${dist.dir}/bin"/>
    <!-- TODO - Stop being inefficient and don't copy OSGi bundles overtop other jars. -->
    <copy-bundle name="scala-library"/>
    <copy-bundle name="scala-reflect"/>
    <copy-bundle name="scala-swing"/>
    <copy-bundle name="scala-actors"/>
    <copy-bundle name="scala-compiler"/>
    <copy toDir="${dist.dir}/bin">
      <fileset dir="${build-pack.dir}/bin"/>
    </copy>
    <chmod perm="ugo+rx" file="${dist.dir}/bin/scala"/>
    <chmod perm="ugo+rx" file="${dist.dir}/bin/scalac"/>
    <chmod perm="ugo+rx" file="${dist.dir}/bin/scaladoc"/>
    <chmod perm="ugo+rx" file="${dist.dir}/bin/fsc"/>
    <chmod perm="ugo+rx" file="${dist.dir}/bin/scalap"/>
    <mkdir dir="${dist.dir}/misc/scala-devel/plugins"/>
    <copy-plugin-bundle name="continuations"/>
  </target>

  <target name="dist.doc" depends="dist.base, docs.done">
    <mkdir dir="${dist.dir}/doc/scala-devel-docs"/>
    <copy file="${docs.dir}/LICENSE" toDir="${dist.dir}/doc"/>
    <copy file="${docs.dir}/README" toDir="${dist.dir}/doc"/>
    <mkdir dir="${dist.dir}/doc/scala-devel-docs/api"/>
    <copy toDir="${dist.dir}/doc/scala-devel-docs/api">
      <fileset dir="${build-docs.dir}/library"/>
    </copy>
    <mkdir dir="${dist.dir}/doc/scala-devel-docs/examples"/>
    <copy toDir="${dist.dir}/doc/scala-devel-docs/examples">
      <fileset dir="${docs.dir}/examples">
        <exclude name="**/*.desired.sha1"/>
      </fileset>
    </copy>
    <mkdir dir="${dist.dir}/doc/scala-devel-docs/tools"/>
    <copy toDir="${dist.dir}/doc/scala-devel-docs/tools">
      <fileset dir="${build-docs.dir}/manual/html"/>
    </copy>
    <copy file="${src.dir}/swing/doc/README"
          toFile="${dist.dir}/doc/scala-devel-docs/README.scala-swing"/>
  </target>

  <target name="dist.man" depends="dist.base">
    <mkdir dir="${dist.dir}/man"/>
    <copy toDir="${dist.dir}/man">
      <fileset dir="${build-docs.dir}/manual/man"/>
    </copy>
  </target>

  <target name="dist.src" depends="dist.base">
    <mkdir dir="${dist.dir}/src"/>
    <jar whenmanifestonly="fail" destfile="${dist.dir}/src/scala-library-src.jar">
      <fileset dir="${src.dir}/library"/>
      <fileset dir="${src.dir}/continuations/library"/>
    </jar>
    <jar whenmanifestonly="fail" destfile="${dist.dir}/src/scala-actors-src.jar"   basedir="${src.dir}/actors"/>
    <jar whenmanifestonly="fail" destfile="${dist.dir}/src/scala-compiler-src.jar">
      <fileset dir="${src.dir}/compiler"/>
      <fileset dir="${src.dir}/repl"/>
      <fileset dir="${src.dir}/scaladoc"/>
      <fileset dir="${src.dir}/interactive"/>
      <fileset dir="${src.dir}/continuations/plugin"/>
    </jar>
    <jar whenmanifestonly="fail" destfile="${dist.dir}/src/scala-swing-src.jar"    basedir="${src.dir}/swing"/>
    <jar whenmanifestonly="fail" destfile="${dist.dir}/src/scala-reflect-src.jar"  basedir="${src.dir}/reflect"/>
    <jar whenmanifestonly="fail" destfile="${dist.dir}/src/scalap-src.jar"         basedir="${src.dir}/scalap"/>
    <jar whenmanifestonly="fail" destfile="${dist.dir}/src/scala-partest-src.jar"  basedir="${src.dir}/partest"/>
  </target>

  <target name="dist.partial" depends="dist.base">
    <if><not><os family="windows"/></not><then>
      <symlink link="${dists.dir}/latest" resource="${dist.name}" overwrite="yes"/>
    </then><else> <!-- XXX THIS PROBABLY DOES NOT WORK: copying must happen last during dist.done! is this guaranteed? -->
      <copydir dest="${dists.dir}/latest" src="${dist.dir}"/>
    </else></if>
  </target>

  <target name="dist.done" depends="dist.doc, dist.man, dist.src, dist.partial"/>


<!-- ===========================================================================
                                  STABLE REFERENCE (STARR)
============================================================================ -->
<!-- Does not use any properties other than ${basedir}, so that it can
     run without 'init' (when using 'replacestarrwin') -->

  <target name="starr.start">
    <fail message="Library in build/pack not available">
      <condition><not><and>
        <available file="${build-pack.dir}/lib/scala-library.jar"/>
      </and></not></condition>
    </fail>
    <fail message="Compiler in build/quick not available">
      <condition><not><and>
        <available file="${build-quick.dir}/classes/compiler"/>
        <available file="${build-quick.dir}/compiler.complete"/>
      </and></not></condition>
    </fail>
  </target>

  <target name="starr.jars" depends="starr.start">
    <copy toDir="${lib.dir}" overwrite="yes">
      <fileset dir="${build-pack.dir}/lib">
        <include name="scala-library.jar"/>
        <include name="scala-reflect.jar"/>
        <include name="scala-compiler.jar"/>
      </fileset>
    </copy>
  </target>

  <target name="starr.src" depends="starr.jars">
    <jar whenmanifestonly="fail" destfile="${lib.dir}/scala-library-src.jar">
      <fileset dir="${src.dir}/library"/>
      <fileset dir="${src.dir}/swing"/>
      <fileset dir="${src.dir}/actors"/>
      <fileset dir="${src.dir}/forkjoin"/>
    </jar>
    <jar whenmanifestonly="fail" destfile="${lib.dir}/scala-reflect-src.jar" basedir="${src.dir}/reflect"/>
    <jar whenmanifestonly="fail" destfile="${lib.dir}/scala-compiler-src.jar">
      <fileset dir="${src.dir}/compiler"/>
      <fileset dir="${src.dir}/asm"/>
    </jar>
  </target>

  <target name="starr.removesha1" depends="starr.src">
    <!-- remove SHA1 files for no starr, so we don't loose artifacts. -->
    <delete>
      <fileset dir="${lib.dir}">
        <include name="scala-compiler.jar.desired.sha1"/>
        <include name="scala-reflect.jar.desired.sha1"/>
        <include name="scala-library.jar.desired.sha1"/>
        <include name="scala-library-src.jar.desired.sha1"/>
        <include name="scala-reflect-src.jar.desired.sha1"/>
        <include name="scala-compiler-src.jar.desired.sha1"/>
      </fileset>
    </delete>
  </target>

  <target name="starr.done" depends="starr.jars, starr.removesha1"/>

  <target name="replacestarr" description="Replaces the Starr compiler and library by fresh ones built from current sources and tests them.">
    <fail message="This target is not available on Windows. Use 'ant replacestarrwin' instead.">
      <condition>
        <os family="windows"/>
      </condition>
    </fail>
    <!-- needs antcall to enforce ordering -->
    <antcall target="locker.clean"/>
    <antcall target="pack.done"/>
    <antcall target="starr.done"/>
    <antcall target="locker.clean"/>
    <antcall target="test.done"/>
  </target>

  <target name="replacestarr-opt" description="Replaces the Starr compiler and library by fresh, optimised ones built from current sources and tests them.">
    <optimized name="replacestarr"/></target>

  <!-- Ant on Windows is not able to delete jar files that are referenced in any <path>.
       See ticket 1290 on trac. -->
  <target name="replacestarrwin" description="Creates a new Starr on Windows. Manually execute 'ant locker.clean build' first!">
    <fail message="This target is only available on Windows. Use 'ant replacestarr' instead.">
      <condition>
        <not><os family="windows"/></not>
      </condition>
    </fail>
    <echo message="CAUTION: Make sure to execute 'ant locker.clean build' prior to calling 'replacestarrwin'."/>
    <antcall target="starr.done"/>
    <antcall target="locker.clean"/>
    <antcall target="test.done"/>
  </target>

  <target name="replacestarrwin-opt" description="Creates a new Starr on Windows. Manually execute 'ant locker.clean build' first!">
    <optimized name="replacestarrwin"/></target>

  <target name="replacelocker" description="Replaces the Locker compiler and library by fresh ones built from current sources."
    depends="palo.clean, locker.unlock, palo.done"/>

  <target name="replacelocker-opt" description="Replaces the Locker compiler and library by fresh, optimised ones built from current sources.">
    <optimized name="replacelocker"/></target>

  <target name="buildlocker" description="Does the same for locker as build does for quick." depends="locker.unlock, palo.bin"/>
  <target name="unlocklocker" description="Same as buildlocker." depends="buildlocker"/> <!-- REMOVE -->

  <target name="fastlocker.lib" description="Buildlocker without extra fuss" depends="locker.unlock, locker.lib">
    <property name="fastlocker" value="true"/>
  </target>

  <target name="fastlocker.reflect" description="Buildlocker without extra fuss" depends="locker.unlock, locker.reflect">
    <property name="fastlocker" value="true"/>
  </target>

  <target name="fastlocker.comp" description="Buildlocker without extra fuss" depends="locker.unlock, locker.comp">
    <property name="fastlocker" value="true"/>
  </target>

  <target name="fastlocker" description="Buildlocker without extra fuss" depends="fastlocker.comp"/>

<!-- ===========================================================================
                                  VISUALIZATION
============================================================================ -->

  <target name="graph.init">
    <taskdef name="vizant" classname="vizant.Vizant" classpath="${lib-ant.dir}/vizant.jar"/>
  </target>

  <target name="graph.all" depends="graph.init">
    <vizant antfile="${ant.file}" outfile="${ant.project.name}.dot" from="all.done"/>
  </target>

  <target name="graph.sabbus" depends="graph.init">
    <vizant antfile="${ant.file}" outfile="${ant.project.name}.dot"/>
  </target>
</project>
