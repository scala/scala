<?xml version="1.0" encoding="UTF-8"?>

<project name="sabbus" default="build"
  xmlns:artifact="urn:maven-artifact-ant"
  xmlns:rsel="antlib:org.apache.tools.ant.types.resources.selectors">
  <include file="build-ant-macros.xml" as="macros"/>

  <description>
SuperSabbus for Scala core, builds the scala library and compiler. It can also package it as a simple distribution, tests it for stable bootstrapping and against the Scala test suite.
  </description>

<!-- HINTS
 - for faster builds, have a build.properties in the same directory as build.xml that says:
      locker.skip=1
-->

<!-- USAGE FROM JENKINS SCRIPTS IS (CURRENTLY) AS FOLLOWS:
ant $antArgs $scalacArgs $targets

antArgs tend to be:
 -Darchives.skipxz=true
 -Dscalac.args.optimise=-optimise

scalacArgs examples:
  "-Dscalac.args=\"-Yrangepos\" -Dpartest.scalac_opts=\"-Yrangepos\""

supported/exercised targets
  to publish: nightly publish-opt-nodocs
  to build: build build-opt locker.done
  to run tests: test.suite test.scaladoc

DO NOT RELY ON ANY OTHER TARGETS (ok, you're probably ok assuming the ones defined in the first 100 lines of this file)

To build your own Scala distribution, do, e.g.:

  ant publish-local-opt -Dmaven.version.suffix="-foo"
  cd ~/git
  hub clone scala/scala-dist
  cd scala-dist
  sbt 'set version := "2.11.0-foo"' 'set resolvers += Resolver.mavenLocal' universal:package-bin

NOTE: `ant build` builds the essence of a Scala distribution under build/pack
  (The only thing missing are the docs; see `pack.doc` and `docs.done`.)

-->

<!-- To use Zinc with the ant build:
  - install zinc and symlink the installed zinc script to ${basedir}/tools/zinc  (${basedir} is where build.xml and the rest of your checkout resides)
  - make sure to set ZINC_OPTS to match ANT_OPTS!
-->

<!--
TODO:
  - detect zinc anywhere on PATH
  - automatically set ZINC_OPTS
  - skip locker (and test.stability) by default to speed up PR validation, still do full build & testing during nightly
  - (rework the build to pack locker and build using that when using zinc)
-->


<!-- ===========================================================================
                                  END-USER TARGETS
============================================================================ -->
  <target name="build"     depends="pack.done"      description="Builds the Scala compiler and library. Executables are in 'build/pack/bin'."/>
  <target name="test"      depends="test.done"      description="Runs test suite and bootstrapping test on Scala compiler and library."/>
  <target name="docs"      depends="docs.done"      description="Builds documentation for the Scala library. Scaladoc is in 'build/scaladoc/library'."/>
  <target name="docscomp"  depends="docs.comp"      description="Builds documentation for the Scala compiler and library. Scaladoc is in 'build/scaladoc'."/>

  <target name="build-opt"       description="Optimized version of build.">       <optimized name="build"/></target>
  <target name="test-opt"        description="Optimized version of test.">        <optimized name="test"/></target>
  <target name="test-core-opt"   description="Optimized version of test.core.">   <optimized name="test.core"/></target>
  <target name="test-stab-opt"   description="Optimized version of test.stability.">   <optimized name="test.stability"/></target>

  <target name="all.done" depends="test.done, pack-maven.done"/>
  <target name="nightly"><optimized name="all.done"/></target>
  <target name="nightly.checkall"> <antcall target="all.done"> <param name="partest.scalac_opts" value="-Ycheck:all"/></antcall></target>

  <!-- The IDE build requires actors/swing/continuations, so need to publish them during PR validation until they are modules -->
  <target name="publish-opt-nodocs" description="Publishes Scala (optimized) without generating docs/testing (library/reflect/compiler/actors/swing/continuations).">
    <antcall target="publish">
      <param name="docs.skip" value="1"/>
      <param name="scalac.args.optimise" value="-optimise"/>
    </antcall>
  </target>
  <target name="publish-core-opt-nodocs" description="Builds an untested, undocumented optimised core (library/reflect/compiler) and publishes to maven.">
    <antcall target="publish-core">
      <param name="docs.skip" value="1"/>
      <param name="scalac.args.optimise" value="-optimise"/>
    </antcall>
  </target>
  <target name="publish-core-local-nodocs" description="Builds an untested, undocumented core (library/reflect/compiler) and locally publishes to maven">
    <antcall target="publish-core-local">
      <param name="docs.skip" value="1"/>
    </antcall>
  </target>

  <!-- prefer the sbt names, but the dotted names are used in jenkins;
       rename there first before dropping the dotted ones -->
  <target name="publish-local"  depends="publish.local"/>
  <target name="publish-local-opt"><optimized name="publish-local"/></target>
  <target name="publish-signed" depends="publish.signed"/>









<!-- DEPRECATED -->
  <target name="dist" depends="all.clean, all.done" description="Cleans all and builds and tests a new distribution."/>
  <target name="partialdist" depends="pack.done"    description="Makes a new distribution without testing it or removing partially build elements."/>
  <target name="fastdist"    depends="pack.done, pack.doc" description="Makes a new distribution without testing it or removing partially build elements."/>
  <target name="dist-opt"        description="Optimized version of dist.">        <optimized name="dist"/></target>
  <target name="partialdist-opt" description="Optimized version of partialdist."> <optimized name="partialdist"/></target>
  <target name="fastdist-opt"    description="Optimized version of fastdist.">    <optimized name="fastdist"/></target>

  <!-- packaging -->
  <target name="distpack" depends="pack-maven.done"/>
  <target name="distpack-maven" depends="pack-maven.done"/>
  <target name="distpack-opt" description="Builds an optimised distribution."> <optimized name="distpack"/></target>
  <target name="distpack-maven-opt" description="Builds an optimised maven distribution."><optimized name="distpack-maven"/></target>
  <target name="distclean"   depends="dist.clean"   description="Removes all distributions. Binaries and documentation are untouched."/>

  <target name="nightly-nopt" depends="all.done"/>

  <target name="clean"       depends="quick.clean"  description="Removes binaries of compiler and library. Locker and distributions are untouched."/>
  <target name="docsclean"   depends="docs.clean"   description="Removes generated documentation. Distributions are untouched."/>



<!-- ===========================================================================
                                  PROPERTIES
============================================================================ -->

  <property environment="env"/>
  <!-- Prevents system classpath from being used -->
  <property name="build.sysclasspath"     value="ignore"/>

  <!-- Defines the repository layout -->
  <property name="doc.dir"                value="${basedir}/doc"/>
  <property name="lib.dir"                value="${basedir}/lib"/>
  <property name="src.dir"                value="${basedir}/src"/>
  <property name="partest.dir"            value="${basedir}/test"/>

  <property name="lib-ant.dir"            value="${lib.dir}/ant"/>
  <!-- For developers: any jars placed in this dir will be added to the classpath
       of all targets and copied into quick/pack/etc builds. -->
  <property name="lib-extra.dir"          value="${lib.dir}/extra"/>

  <!-- Loads custom properties definitions -->
  <property file="${basedir}/build.properties"/>

  <!-- Generating version number -->
  <property file="${basedir}/build.number"/>

  <!-- read versions.properties -->
  <property file="${basedir}/versions.properties"/>

  <!-- Sets location of pre-compiled libraries -->
  <property name="ant.jar"                 value="${ant.home}/lib/ant.jar"/>

  <!-- Sets location of build folders -->
  <property name="build.dir"               value="${basedir}/build"/>
  <property name="build-deps.dir"          value="${build.dir}/deps"/>
  <property name="build-libs.dir"          value="${build.dir}/libs"/>
  <property name="build-forkjoin.dir"      value="${build-libs.dir}"/>
  <property name="build-locker.dir"        value="${build.dir}/locker"/>
  <property name="build-quick.dir"         value="${build.dir}/quick"/>
  <property name="build-pack.dir"          value="${build.dir}/pack"/>
  <property name="build-manual.dir"        value="${build.dir}/manual"/>
  <property name="build-osgi.dir"          value="${build.dir}/osgi"/>
  <property name="build-junit.dir"         value="${build.dir}/junit"/>
  <property name="build-strap.dir"         value="${build.dir}/strap"/>
  <property name="build-docs.dir"          value="${build.dir}/scaladoc"/>
  <property name="build-sbt.dir"           value="${build.dir}/sbt-interface"/>

  <property name="test.osgi.src"           value="${partest.dir}/osgi/src"/>
  <property name="test.osgi.classes"       value="${build-osgi.dir}/classes"/>

  <property name="test.junit.src"          value="${partest.dir}/junit"/>
  <property name="test.junit.classes"      value="${build-junit.dir}/classes"/>

  <property name="dists.dir"               value="${basedir}/dists"/>

  <property name="copyright.string"        value="Copyright 2002-2017, LAMP/EPFL"/>

  <!-- These are NOT the flags used to run SuperSabbus, but the ones written
       into the script runners created with scala.tools.ant.ScalaTool -->
  <property name="java.flags"              value="-Xmx256M -Xms32M"/>
  <property name="jvm.opts"                value=""/>

  <!-- if ANT_OPTS is already set by the environment, it will be unaltered,
       but if it is unset it will take this default value. -->
  <property name="env.ANT_OPTS"            value="-Xms1536M -Xmx1536M -Xss1M -XX:MaxPermSize=192M -XX:+UseParallelGC" />

  <property name="scalacfork.jvmargs"      value="${env.ANT_OPTS} ${jvm.opts}"/>

<!-- ===========================================================================
                                  INITIALIZATION
============================================================================ -->
  <target name="desired.jars.uptodate">
    <patternset id="desired.jars">
      <include name="lib/**/*.desired.sha1"/>
      <include name="test/files/**/*.desired.sha1"/>
      <include name="tools/**/*.desired.sha1"/>
    </patternset>

    <uptodate property="lib.jars.uptodate">
      <srcfiles dir="${basedir}"><patternset refid="desired.jars"/></srcfiles>
      <mapper type="glob" from="*.desired.sha1" to="*"/>
    </uptodate>
  </target>

  <target name="boot" depends="desired.jars.uptodate" unless="lib.jars.uptodate">
    <echo level="warn" message="Updating bootstrap libs.  (To do this by hand, run ./pull-binary-libs.sh)"/>
    <exec osfamily="unix" vmlauncher="false" executable="./pull-binary-libs.sh" failifexecutionfails="true" />
    <exec osfamily="windows" vmlauncher="false" executable="pull-binary-libs.sh" failifexecutionfails="true" />
    <!-- uptodate task needs to know these are what's in the sha. -->
    <touch>
      <fileset dir="${basedir}"><patternset refid="desired.jars"/></fileset>
      <mapper type="glob" from="*.desired.sha1" to="*"/>
    </touch>
  </target>

  <target name="init.git" depends="boot">
    <!-- replacestarr needs git.commit.sha, but doesn't want to run the init target (it computes maven.version.number) -->
    <exec osfamily="unix" executable="tools/get-scala-commit-sha" outputproperty="git.commit.sha" failifexecutionfails="false" />
    <exec osfamily="windows" executable="cmd.exe" outputproperty="git.commit.sha" failifexecutionfails="false">
      <arg value="/c"/>
      <arg value="tools\get-scala-commit-sha.bat"/>
      <arg value="-p"/>
    </exec>
    <exec osfamily="unix" executable="tools/get-scala-commit-date" outputproperty="git.commit.date" failifexecutionfails="false" />
    <exec osfamily="windows" executable="cmd.exe" outputproperty="git.commit.date" failifexecutionfails="false">
      <arg value="/c"/>
      <arg value="tools\get-scala-commit-date.bat"/>
      <arg value="-p"/>
    </exec>

    <!-- some default in case something went wrong getting the revision -->
    <property name="git.commit.sha"          value="unknown"/>
    <property name="git.commit.date"         value="unknown"/>
  </target>

  <target name="init" depends="init.git">
    <!-- Set up Ant contrib tasks so we can use <if><then><else> instead of the clunky `unless` attribute -->
    <taskdef resource="net/sf/antcontrib/antlib.xml" classpath="${lib-ant.dir}/ant-contrib.jar"/>

    <property name="scala.ant.min.version" value="1.8.2"/>
    <if><not><antversion atleast="${scala.ant.min.version}"/></not>
      <then><fail message="Ant version ${scala.ant.min.version} is required. You are running ${ant.version}"/></then>
    </if>

    <!-- Add our maven ant tasks -->
    <path id="maven-ant-tasks.classpath" path="${lib-ant.dir}/maven-ant-tasks-2.1.1.jar" />
    <typedef resource="org/apache/maven/artifact/ant/antlib.xml" uri="urn:maven-artifact-ant" classpathref="maven-ant-tasks.classpath" />

    <!-- Resolve maven dependencies -->

    <!-- work around http://jira.codehaus.org/browse/MANTTASKS-203:
         java.lang.ClassCastException: org.codehaus.plexus.DefaultPlexusContainer cannot be cast to org.codehaus.plexus.PlexusContainer
         on repeated use of artifact:dependencies
    -->
    <if><not><isset property="maven-deps-done"></isset></not><then>
      <mkdir dir="${user.home}/.m2/repository"/>

      <artifact:remoteRepository id="sonatype-release" url="https://oss.sonatype.org/content/repositories/releases"/>
      <artifact:remoteRepository id="sonatype-snapshots" url="https://oss.sonatype.org/content/repositories/snapshots"/>
      <artifact:remoteRepository id="extra-repo" url="${extra.repo.url}"/>

      <!-- This task has an issue where if the user directory does not exist, so we create it above. UGH. -->
      <artifact:dependencies pathId="extra.tasks.classpath" filesetId="extra.tasks.fileset">
        <dependency groupId="biz.aQute" artifactId="bnd" version="1.50.0"/>
      </artifact:dependencies>

      <artifact:dependencies pathId="jarjar.classpath">
        <dependency groupId="com.googlecode.jarjar" artifactId="jarjar" version="1.3"/>
      </artifact:dependencies>

      <artifact:dependencies pathId="jarlister.classpath">
        <dependency groupId="com.github.rjolly" artifactId="jarlister_2.11" version="1.0"/>
      </artifact:dependencies>

      <!-- JUnit -->
      <property name="junit.version" value="4.11"/>
      <artifact:dependencies pathId="junit.classpath" filesetId="junit.fileset">
        <dependency groupId="junit" artifactId="junit" version="${junit.version}"/>
      </artifact:dependencies>
      <copy-deps project="junit"/>

      <!-- Pax runner -->
      <property name="pax.exam.version" value="3.5.0"/><!-- Last version which supports Java 6 -->
      <property name="osgi.felix.version" value="4.4.0"/>
      <property name="osgi.equinox.version" value="3.7.1"/>
      <artifact:dependencies pathId="pax.exam.classpath" filesetId="pax.exam.fileset">
        <dependency groupId="org.ops4j.pax.exam" artifactId="pax-exam-container-native" version="${pax.exam.version}">
          <exclusion groupId="org.osgi" artifactId="org.osgi.core"/><!-- Avoid dragging in a dependency which requires Java >6 -->
        </dependency>
        <dependency groupId="org.ops4j.pax.exam" artifactId="pax-exam-junit4" version="${pax.exam.version}"/>
        <dependency groupId="org.ops4j.pax.exam" artifactId="pax-exam-link-assembly" version="${pax.exam.version}"/>
        <dependency groupId="org.ops4j.pax.url" artifactId="pax-url-aether" version="2.2.0"/>
        <dependency groupId="org.ops4j.pax.swissbox" artifactId="pax-swissbox-tracker" version="1.8.0"/>
        <dependency groupId="ch.qos.logback" artifactId="logback-core" version="1.1.2"/>
        <dependency groupId="ch.qos.logback" artifactId="logback-classic" version="1.1.2"/>
        <dependency groupId="junit" artifactId="junit" version="${junit.version}"/>
      </artifact:dependencies>
      <copy-deps project="pax.exam"/>

      <artifact:dependencies pathId="osgi.framework.felix">
        <dependency groupId="org.apache.felix" artifactId="org.apache.felix.framework" version="${osgi.felix.version}"/>
      </artifact:dependencies>

      <artifact:dependencies pathId="osgi.framework.equinox">
        <dependency groupId="org.eclipse.osgi" artifactId="org.eclipse.osgi" version="${osgi.equinox.version}"/>
      </artifact:dependencies>

      <artifact:remoteRepository id="sonatype-release" url="https://oss.sonatype.org/content/repositories/releases"/>
      <artifact:remoteRepository id="extra-repo" url="${extra.repo.url}"/>

      <!-- scala-java8-compat, used by the experimental -target jvm-1.8 support. -->
      <if><isset property="scala-java8-compat.package"/><then>
        <property name="scala-java8-compat.version" value="0.5.0"/>
        <property name="scala-java8-compat.binary.version" value="2.11"/>
        <artifact:dependencies pathId="scala-java8-compat.classpath" filesetId="scala-java8-compat.fileset">
          <dependency groupId="org.scala-lang.modules" artifactId="scala-java8-compat_${scala-java8-compat.binary.version}" version="${scala-java8-compat.version}">
            <exclusion groupId="org.scala-lang" artifactId="scala-library"/>
          </dependency>
        </artifact:dependencies>
        <property name="scala-java8-compat-classes" value="${build-quick.dir}/scala-java8-compat"/>
        <delete dir="${scala-java8-compat-classes}"/>
        <unzip dest="${scala-java8-compat-classes}">
          <fileset refid="scala-java8-compat.fileset"/>
          <patternset>
            <include name="**/*.class"/>
          </patternset>
        </unzip>
        <path id="scala-java8-compat.libs">
          <pathelement location="${scala-java8-compat-classes}"/>
        </path>
        <fileset id="scala-java8-compat.fileset" dir="${scala-java8-compat-classes}">
          <include name="**/*"/>
        </fileset>
      </then>
        <else>
          <path id="scala-java8-compat.libs"/>
          <fileset id="scala-java8-compat.fileset" dir="." excludes="**"/>
        </else>
      </if>

      <!-- prepare, for each of the names below, the property "@{name}.cross", set to the
           necessary cross suffix (usually something like "_2.11.0-M6". -->
      <prepareCross name="scala-xml" />
      <prepareCross name="scala-parser-combinators" />
      <property name="scala-continuations-plugin.cross.suffix" value="_${scala.full.version}"/>
      <prepareCross name="scala-continuations-plugin" />
      <prepareCross name="scala-continuations-library"/>
      <prepareCross name="scala-swing"/>
      <prepareCross name="partest"/>
      <prepareCross name="scalacheck"/>

      <artifact:dependencies pathId="asm.classpath" filesetId="asm.fileset">
        <dependency groupId="org.scala-lang.modules" artifactId="scala-asm" version="${scala-asm.version}"/>
      </artifact:dependencies>
      <copy-deps project="asm"/>

      <!-- TODO: delay until absolutely necessary to allow minimal build, also move out partest dependency from scaladoc -->
      <artifact:dependencies pathId="partest.classpath" filesetId="partest.fileset" versionsId="partest.versions">
        <!-- uncomment the following if you're deploying your own partest locally -->
        <!-- <localRepository path="${user.home}/.m2/repository"/> -->
        <!-- so we don't have to wait for artifacts to synch to maven central
            (we don't distribute partest with Scala, so the risk of sonatype and maven being out of synch is irrelevant):
          -->
        <artifact:remoteRepository refid="sonatype-release"/>
        <artifact:remoteRepository refid="extra-repo"/>
        <dependency groupId="org.scala-lang.modules" artifactId="scala-partest${partest.cross}" version="${partest.version.number}" />
      </artifact:dependencies>
      <copy-deps project="partest"/>

      <artifact:dependencies pathId="scalacheck.classpath" filesetId="scalacheck.fileset" versionsId="scalacheck.versions">
        <artifact:remoteRepository refid="extra-repo"/>
        <dependency groupId="org.scalacheck"         artifactId="scalacheck${scalacheck.cross}"    version="${scalacheck.version.number}" />
      </artifact:dependencies>

      <artifact:dependencies pathId="repl.deps.classpath" filesetId="repl.fileset" versionsId="repl.deps.versions">
        <dependency groupId="jline" artifactId="jline" version="${jline.version}"/>
      </artifact:dependencies>
      <copy-deps project="repl"/>

      <!-- used by the test.osgi target to create osgi bundles for the xml, parser-combinator jars
           must specify sourcesFilesetId, javadocFilesetId to download these types of artifacts -->
      <artifact:dependencies pathId="external-modules.deps.classpath" sourcesFilesetId="external-modules.sources.fileset" javadocFilesetId="external-modules.javadoc.fileset">
        <artifact:remoteRepository refid="extra-repo"/>
        <dependency groupId="org.scala-lang.modules" artifactId="scala-xml${scala-xml.cross}" version="${scala-xml.version.number}"/>
        <dependency groupId="org.scala-lang.modules" artifactId="scala-parser-combinators${scala-parser-combinators.cross}" version="${scala-parser-combinators.version.number}"/>
        <dependency groupId="org.scala-lang.plugins" artifactId="scala-continuations-plugin${scala-continuations-plugin.cross}"  version="${scala-continuations-plugin.version.number}"/>
        <dependency groupId="org.scala-lang.plugins" artifactId="scala-continuations-library${scala-continuations-library.cross}" version="${scala-continuations-library.version.number}"/>
        <dependency groupId="org.scala-lang.modules" artifactId="scala-swing${scala-swing.cross}" version="${scala-swing.version.number}"/>
      </artifact:dependencies>

      <!-- External modules, excluding the core -->
      <path id="external-modules-nocore">
        <restrict>
          <path refid="external-modules.deps.classpath"/>
          <rsel:not><rsel:or>
            <rsel:name name="scala-library*.jar"/>
            <rsel:name name="scala-reflect*.jar"/>
            <rsel:name name="scala-compiler*.jar"/>
          </rsel:or></rsel:not>
        </restrict>
      </path>
      <copy-deps refid="external-modules-nocore" project="scaladoc"/>

      <propertyForCrossedArtifact name="scala-parser-combinators" jar="org.scala-lang.modules:scala-parser-combinators"/>
      <propertyForCrossedArtifact name="scala-xml"                jar="org.scala-lang.modules:scala-xml"/>
      <propertyForCrossedArtifact name="scala-continuations-plugin"  jar="org.scala-lang.plugins:scala-continuations-plugin"/>
      <propertyForCrossedArtifact name="scala-continuations-library" jar="org.scala-lang.plugins:scala-continuations-library"/>
      <propertyForCrossedArtifact name="scala-swing"                 jar="org.scala-lang.modules:scala-swing"/>

      <!-- BND support -->
      <typedef resource="aQute/bnd/ant/taskdef.properties" classpathref="extra.tasks.classpath" />

      <echo message="Using Scala ${starr.version} for STARR."/>
      <artifact:dependencies pathId="starr.compiler.path" filesetId="starr.fileset">
        <artifact:remoteRepository refid="extra-repo"/>
        <dependency groupId="org.scala-lang" artifactId="scala-library" version="${starr.version}"/>
        <dependency groupId="org.scala-lang" artifactId="scala-reflect" version="${starr.version}"/>
        <dependency groupId="org.scala-lang" artifactId="scala-compiler" version="${starr.version}"/>
      </artifact:dependencies>
      <copy-deps project="starr"/>

      <property name="maven-deps-done"     value="yep!"/>
    </then></if>


    <!-- NOTE: ant properties are write-once: second writes are silently discarded; the logic below relies on this -->

    <!-- Compute defaults (i.e., if not specified on command-line) for OSGi/maven version suffixes.
      Try to establish the invariant (verified below):
      `version.suffix == maven.version.suffix == osgi.version.suffix`,
      except for:
        - snapshot builds, where:
          - `maven.suffix == "-SNAPSHOT"`
          - `version.suffix == osgi.version.suffix == ""`
        - final builds, where:
          - `osgi.suffix == "-VFINAL"`
          - `version.suffix == maven.version.suffix == ""`
    -->
    <if><not><equals arg1="${version.bnum}" arg2="0"/></not><then>
      <property name="version.suffix"          value="-${version.bnum}"/>
    </then></if>

    <if><or><not><isset property="version.suffix"/></not><equals arg1="${version.suffix}" arg2=""/></or><then>
      <if><isset property="build.release"/><then>
        <property name="maven.version.suffix"  value=""/>
        <property name="version.suffix"        value="${maven.version.suffix}"/>
        <if><equals arg1="${maven.version.suffix}" arg2=""/><then>
          <property name="osgi.version.suffix" value="-VFINAL"/></then>
        <else>
          <property name="osgi.version.suffix" value="${maven.version.suffix}"/></else></if></then></if></then>
    <else> <!-- version.suffix set and not empty -->
      <property name="maven.version.suffix"    value="${version.suffix}"/>
      <property name="osgi.version.suffix"     value="${version.suffix}"/></else></if>

    <!-- if a maven version suffix was set (or inferred), assume we're building a release -->
    <if><isset property="maven.version.suffix"/><then>
      <property name="build.release"  value="1"/></then></if>

    <!-- not building a release and no version.suffix specified -->
    <property name="maven.version.suffix"      value="-SNAPSHOT"/>

    <if><equals arg1="${maven.version.suffix}" arg2="-SNAPSHOT"/><then>
      <property name="osgi.version.suffix"     value=""/>
      <property name="version.suffix"          value=""/></then>
    <else>
      <property name="osgi.version.suffix"     value="${maven.version.suffix}"/>
      <property name="version.suffix"          value="${maven.version.suffix}"/></else></if>

    <!-- We use the git describe to determine the OSGi modifier for our build. -->
    <property name="maven.version.number"
      value="${version.major}.${version.minor}.${version.patch}${maven.version.suffix}"/>
    <property name="osgi.version.number"
      value="${version.major}.${version.minor}.${version.patch}.v${git.commit.date}${osgi.version.suffix}-${git.commit.sha}"/>

    <if><isset property="build.release"/><then>
      <property name="version.number"        value="${maven.version.number}"/>
    </then><else>
      <property name="version.number"        value="${version.major}.${version.minor}.${version.patch}${version.suffix}-${git.commit.date}-${git.commit.sha}"/>
    </else></if>

    <!-- some default in case something went wrong getting the revision -->
    <property name="version.number"       value="-unknown-"/>

    <condition property="has.java6">
        <equals arg1="${ant.java.version}" arg2="1.6"/>
    </condition>
    <condition property="has.java7">
        <equals arg1="${ant.java.version}" arg2="1.7"/>
    </condition>
    <condition property="has.java8">
        <equals arg1="${ant.java.version}" arg2="1.8"/>
    </condition>
    <condition property="has.unsupported.jdk">
       <not><or>
         <isset property="has.java8" />
         <isset property="has.java7" />
         <isset property="has.java6" />
       </or></not>
    </condition>

    <fail if="has.unsupported.jdk" message="JDK ${ant.java.version} is not supported by this build!"/>
    <fail message="Ant 1.9+ required">
      <condition>
        <not><antversion atleast="1.9" /></not>
      </condition>
    </fail>

    <!-- Allow this to be overridden simply -->
    <property name="sbt.latest.version"    value="0.12.4"/>

    <property name="sbt.src.dir"           value="${build-sbt.dir}/${sbt.latest.version}/src"/>
    <property name="sbt.lib.dir"           value="${build-sbt.dir}/${sbt.latest.version}/lib"/>

    <property name="sbt.interface.jar"     value="${sbt.lib.dir}/interface.jar"/>
    <property name="sbt.interface.url"     value="http://dl.bintray.com/typesafe/ivy-releases/org.scala-sbt/interface/${sbt.latest.version}/jars/interface.jar"/>
    <property name="sbt.interface.src.jar" value="${sbt.src.dir}/compiler-interface-src.jar"/>
    <property name="sbt.interface.src.url" value="http://dl.bintray.com/typesafe/ivy-releases/org.scala-sbt/compiler-interface/${sbt.latest.version}/jars/compiler-interface-src.jar"/>


    <!-- Additional command line arguments for scalac. They are added to all build targets -->
    <property name="scalac.args"           value=""/>
    <property name="javac.args"            value=""/>

    <property name="scalac.args.always"    value="-feature" />
    <property name="scalac.args.optimise"  value=""/> <!-- scalac.args.optimise is selectively overridden in certain antcall tasks. -->
    <property name="scalac.args.all"       value="${scalac.args.always} ${scalac.args} ${scalac.args.optimise}"/>
    <property name="scalac.args.locker"    value="${scalac.args.all}"/>
    <property name="scalac.args.quick"     value="${scalac.args.all}"/>
    <property name="scalac.args.strap"     value="${scalac.args.quick}"/>

    <property name="partest.scalac_opts"   value=""/> <!-- set default value, otherwise the property name will be passed to partest if undefined -->

    <!-- This is the start time for the distribution -->
    <tstamp prefix="time">
      <format property="human" pattern="d MMMM yyyy, HH:mm:ss" locale="en,US"/>
      <format property="short" pattern="yyyyMMddHHmmss"/>
    </tstamp>

    <!-- Local libs (developer use.) -->
    <mkdir dir="${lib-extra.dir}"/>

    <!-- Auxiliary libs placed on every classpath. -->
    <path id="aux.libs">
      <pathelement location="${ant.jar}"/>
      <!-- needs ant 1.7.1 -->
      <!-- <fileset dir="${lib-extra.dir}" erroronmissingdir="false"> -->
      <fileset dir="${lib-extra.dir}">
        <include name="**/*.jar"/>
      </fileset>
    </path>

    <!-- And print-out what we are building -->
    <echo message="       build time: ${time.human}" />
    <echo message="     java version: ${java.vm.name} ${java.version} (${ant.java.version})" />
    <echo message="        java args: ${env.ANT_OPTS} ${jvm.opts}" />
    <echo message="       javac args: ${javac.args}" />
    <echo message="      scalac args: ${scalac.args.all}" />
    <echo message="scalac quick args: ${scalac.args.quick}" />
    <echo message="         git date: ${git.commit.date}" />
    <echo message="         git hash: ${git.commit.sha}" />
    <echo message="    maven version: ${maven.version.number}"/>
    <echo message="     OSGi version: ${osgi.version.number}" />
    <echo message="canonical version: ${version.number}" />

    <echoproperties destfile="buildcharacter.properties">
      <propertyset>
        <propertyref regex="time.*" />
        <propertyref regex="git.*" />
        <propertyref name="java.vm.name" />
        <propertyref regex=".*version.*" />
        <propertyref regex="scalac.args.*" />
        <propertyref name="scalacfork.jvmargs" />
      </propertyset>
    </echoproperties>

    <!-- validate version suffixes -->
    <if><equals arg1="${maven.version.suffix}" arg2="-SNAPSHOT"/><then>
      <condition property="version.suffixes.consistent"><and>
        <equals arg1="${osgi.version.suffix}" arg2=""/>
        <equals arg1="${version.suffix}" arg2=""/>
      </and></condition></then>
    <else>
      <if><equals arg1="${osgi.version.suffix}" arg2="-VFINAL"/><then>
        <condition property="version.suffixes.consistent"><and>
          <equals arg1="${maven.version.suffix}" arg2=""/>
          <equals arg1="${version.suffix}" arg2=""/>
        </and></condition></then>
      <else>
        <condition property="version.suffixes.consistent"><and>
          <equals arg1="${osgi.version.suffix}" arg2="${maven.version.suffix}"/>
          <equals arg1="${version.suffix}" arg2="${maven.version.suffix}"/>
        </and></condition></else></if></else></if>

    <!-- <echo message="    maven suffix: ${maven.version.suffix}"/>
    <echo message="     OSGi suffix: ${osgi.version.suffix}" />
    <echo message="canonical suffix: ${version.suffix}" /> -->
    <fail unless="version.suffixes.consistent" message="Version suffixes inconsistent!"/>


    <!-- used during releases to bump versions in versions.properties -->
    <if><isset property="update.versions"/><then>
      <echo message="Updating `versions.properties`:"/>
      <echo message="starr.version                              = ${starr.version}"/>
      <echo message="scala.binary.version                       = ${scala.binary.version}"/>
      <echo message="scala.full.version                         = ${scala.full.version}"/>
      <echo message="scala-xml.version.number                   = ${scala-xml.version.number}"/>
      <echo message="scala-parser-combinators.version.number    = ${scala-parser-combinators.version.number}"/>
      <echo message="scala-continuations-plugin.version.number  = ${scala-continuations-plugin.version.number}"/>
      <echo message="scala-continuations-library.version.number = ${scala-continuations-library.version.number}"/>
      <echo message="scala-swing.version.number                 = ${scala-swing.version.number}"/>
      <echo message="akka-actor.version.number                  = ${akka-actor.version.number}"/>
      <echo message="actors-migration.version.number            = ${actors-migration.version.number}"/>
      <echo message="jline.version                              = ${jline.version}"/>
      <echo message="partest.version.number                     = ${partest.version.number}"/>
      <echo message="scalacheck.version.number                  = ${scalacheck.version.number}"/>

      <propertyfile file="versions.properties">
        <entry key="starr.version"                              value="${starr.version}"/>
        <entry key="scala.binary.version"                       value="${scala.binary.version}"/>
        <entry key="scala.full.version"                         value="${scala.full.version}"/>
        <entry key="scala-xml.version.number"                   value="${scala-xml.version.number}"/>
        <entry key="scala-parser-combinators.version.number"    value="${scala-parser-combinators.version.number}"/>
        <entry key="scala-continuations-plugin.version.number"  value="${scala-continuations-plugin.version.number}"/>
        <entry key="scala-continuations-library.version.number" value="${scala-continuations-library.version.number}"/>
        <entry key="scala-swing.version.number"                 value="${scala-swing.version.number}"/>
        <entry key="akka-actor.version.number"                  value="${akka-actor.version.number}"/>
        <entry key="actors-migration.version.number"            value="${actors-migration.version.number}"/>
        <entry key="jline.version"                              value="${jline.version}"/>
        <entry key="partest.version.number"                     value="${partest.version.number}"/>
        <entry key="scalacheck.version.number"                  value="${scalacheck.version.number}"/>
      </propertyfile>
    </then></if>

    <path id="forkjoin.classpath" path="${build-forkjoin.dir}/classes/forkjoin"/>
    <property name="forkjoin-classes" refid="forkjoin.classpath"/>

    <!-- the following properties fully define staged-docs, staged-pack, make-bundle, copy-bundle and mvn-package for each of the projects -->
    <property name="library.description"           value="Scala Standard Library"/>
    <property name="library.docroot"               value="rootdoc.txt"/>
    <property name="library.skipPackages"          value="scala.concurrent.impl"/>

    <property name="reflect.description"           value="Scala Reflection Library"/>
    <property name="reflect.skipPackages"          value="scala.reflect.macros.internal:scala.reflect.internal:scala.reflect.io"/>

    <property name="compiler.description"          value="Scala Compiler"/>
    <property name="compiler.docroot"              value="rootdoc.txt"/>

    <!-- these are not used used, preparation for the 'TODO modularize compiler' task -->
    <property name="interactive.description"       value="Scala Interactive Compiler"   />
    <property name="interactive.package"           value="modules." />
    <property name="interactive.name"              value="scala-compiler-interactive"/>
    <property name="interactive.namesuffix"        value="_${scala.binary.version}"/>
    <property name="interactive.version"           value="${scala-compiler-interactive.version.number}"/>
    <property name="interactive.targetjar"         value="scala-compiler-interactive_${scala.binary.version}-${scala-compiler-interactive.version.number}.jar"/>

    <property name="scaladoc.description"          value="Scala Documentation Generator"/>
    <property name="scaladoc.package"              value="modules." />
    <property name="scaladoc.name"                 value="scala-compiler-doc"         />
    <property name="scaladoc.namesuffix"           value="_${scala.binary.version}"/>
    <property name="scaladoc.version"              value="${scala-compiler-doc.version.number}"/>
    <property name="scaladoc.targetjar"            value="scala-compiler-doc_${scala.binary.version}-${scala-compiler-doc.version.number}.jar"/>

    <property name="actors.description"            value="Scala Actors Library"/>

    <property name="swing.description"             value="Scala Swing Library"/>
    <property name="swing.package"                 value="modules."/>
    <property name="swing.jar"                     value="${scala-swing}"/>
    <property name="swing.src"                     value="false"/>
    <property name="swing.srcjar"                  value="${scala-swing-sources}"/>

    <property name="continuations-plugin.description" value="Scala Delimited Continuations Compiler Plugin"/>
    <property name="continuations-plugin.package"     value="plugins." />
    <property name="continuations-plugin.jar"         value="${scala-continuations-plugin}"/>
    <property name="continuations-plugin.src"         value="false"/>
    <property name="continuations-plugin.srcjar"      value="${scala-continuations-plugin-sources}"/>

    <property name="continuations-library.description" value="Scala Delimited Continuations Library"/>
    <property name="continuations-library.package"     value="plugins." />
    <property name="continuations-library.jar"         value="${scala-continuations-library}"/>
    <property name="continuations-library.src"         value="false"/>
    <property name="continuations-library.srcjar"      value="${scala-continuations-library-sources}"/>

    <property name="parser-combinators.description" value="Scala Parser Combinators Library"/>
    <property name="parser-combinators.package"    value="modules."/>
    <property name="parser-combinators.jar"        value="${scala-parser-combinators}"/>
    <property name="parser-combinators.src"        value="false"/>
    <property name="parser-combinators.srcjar"     value="${scala-parser-combinators-sources}"/>

    <property name="xml.description"               value="Scala XML Library"/>
    <property name="xml.package"                   value="modules."/>
    <property name="xml.jar"                       value="${scala-xml}"/>
    <property name="xml.src"                       value="false"/>
    <property name="xml.srcjar"                    value="${scala-xml-sources}"/>

    <property name="scalap.description"            value="Scala Bytecode Parser"/>
    <property name="scalap.targetjar"              value="scalap.jar"/>

    <property name="partest.description"           value="Scala Compiler Testing Tool"/>
    <property name="partest-extras.description"    value="Scala Compiler Testing Tool (compiler-specific extras)"/>
    <property name="partest-javaagent.description" value="Scala Compiler Testing Tool (compiler-specific java agent)"/>

    <!-- projects without project-specific options: forkjoin, manual, bin, repl -->
    <for list="actors,compiler,interactive,scaladoc,library,parser-combinators,partest,partest-extras,partest-javaagent,reflect,scalap,swing,xml,continuations-plugin,continuations-library,repl-jline" param="project">
      <sequential>
        <!-- description is mandatory -->
        <init-project-prop project="@{project}" name="package"     default=""/> <!-- used by mvn-package, copy-bundle, make-bundle -->
        <init-project-prop project="@{project}" name="dir"         default=""/> <!-- used by mvn-package -->
        <init-project-prop project="@{project}" name="name"        default="scala-@{project}"/> <!-- used for defaults in this block and by mvn-package, copy-bundle, make-bundle -->
        <init-project-prop project="@{project}" name="namesuffix"  default=""/>
        <init-project-prop project="@{project}" name="version"     default="${osgi.version.number}"/>
        <init-project-prop project="@{project}" name="targetdir"   default="lib"/>
        <init-project-prop project="@{project}" name="targetjar"   default="${@{project}.name}.jar"/>
        <init-project-prop project="@{project}" name="jar"         default="${build-pack.dir}/${@{project}.targetdir}/${@{project}.targetjar}" />
        <init-project-prop project="@{project}" name="docroot"     default="NOT SET"/>
        <init-project-prop project="@{project}" name="skipPackages" default=""/>
        <init-project-prop project="@{project}" name="srcdir"      default="@{project}"/>
        <init-project-prop project="@{project}" name="src"         default="true"/>
        <init-project-prop project="@{project}" name="srcjar"      default="${build-osgi.dir}/${@{project}.name}-src.jar"/>
      </sequential>
    </for>


    <!-- Compilers to use for the various stages.
      There must be a variable of the shape @{stage}.compiler.path  for all @{stage} in starr, locker, quick, strap.
    -->

    <!-- starr is resolved (to starr.compiler.path) in the block protected by maven-deps-done
         the maven task must not be executed twice, or you get a java.lang.ClassCastException:
         org.apache.maven.artifact.ant.RemoteRepository cannot be cast to org.apache.maven.artifact.ant.Repository
    -->

    <!-- To skip locker, use -Dlocker.skip=1 -->
    <if><isset property="locker.skip"/><then>
      <echo message="Using STARR to build the quick stage (skipping locker)."/>
      <path id="locker.compiler.path" refid="starr.compiler.path"/>
       <!-- this is cheating (we don't know the classpath used to build starr)
            but should be close enough: -->
      <path id="locker.compiler.build.path" refid="starr.compiler.path"/>
      <property name="locker.locked" value="locker skipped"/></then>
    <else>
      <path id="locker.compiler.path"><path refid="locker.compiler.build.path"/></path></else></if>

    <!-- compilerpathref for compiling with quick -->
    <path id="quick.compiler.path"> <path refid="quick.compiler.build.path"/></path>


    <!-- What to have on the compilation path when compiling during certain phases.

      There must be a variable of the shape @{stage}.@{project}.build.path
      for all @{stage} in locker, quick, strap
      and all @{project} in library, reflect, compiler
        when stage is quick, @{project} also includes: actors, repl, scalap

      NOTE: interactive, scaladoc, are only used upto quick; they are still packed into the compiler jar
    -->

    <!-- LOCKER -->
    <path id="locker.library.build.path">
      <pathelement location="${build-locker.dir}/classes/library"/>
      <path refid="forkjoin.classpath"/>
      <path refid="aux.libs"/>
      <path refid="scala-java8-compat.libs"/>
    </path>

    <path id="locker.reflect.build.path">
      <path refid="locker.library.build.path"/>
      <pathelement location="${build-locker.dir}/classes/reflect"/>
    </path>

    <if><not><isset property="locker.skip"/></not><then>
    <path id="locker.compiler.build.path">
      <path refid="locker.reflect.build.path"/>
      <pathelement location="${build-locker.dir}/classes/compiler"/>
      <path refid="asm.classpath"/>
    </path>
    </then></if>
    <!-- else, locker.compiler.build.path is set above -->

    <!-- QUICK -->
    <path id="quick.library.build.path">
      <pathelement location="${build-quick.dir}/classes/library"/>
      <path refid="forkjoin.classpath"/>
      <path refid="aux.libs"/>
      <path refid="scala-java8-compat.libs"/>
    </path>

    <path id="quick.actors.build.path">
      <path refid="quick.library.build.path"/>
      <pathelement location="${build-quick.dir}/classes/actors"/>
    </path>

    <path id="quick.reflect.build.path">
      <path refid="quick.library.build.path"/>
      <pathelement location="${build-quick.dir}/classes/reflect"/>
    </path>

    <path id="quick.compiler.build.path">
      <path refid="quick.reflect.build.path"/>
      <pathelement location="${build-quick.dir}/classes/compiler"/>
      <path refid="asm.classpath"/>
    </path>

    <path id="quick.repl.build.path">
      <path refid="quick.compiler.build.path"/>
      <path refid="quick.interactive.build.path"/>
      <pathelement location="${build-quick.dir}/classes/repl"/>
    </path>

    <path id="quick.repl-jline.build.path">
      <path refid="quick.repl.build.path"/>
      <pathelement location="${build-quick.dir}/classes/repl-jline"/>
      <path refid="repl.deps.classpath"/>
    </path>

    <path id="quick.scalap.build.path">
      <path refid="quick.compiler.build.path"/>
      <pathelement location="${build-quick.dir}/classes/scalap"/>
    </path>

    <path id="quick.partest-extras.build.path">
      <path refid="asm.classpath"/>
      <path refid="partest.classpath"/>
      <path refid="quick.compiler.build.path"/>
      <pathelement location="${build-quick.dir}/classes/repl"/>
      <!-- for the java dependency: Profiler.java -->
      <pathelement location="${build-quick.dir}/classes/partest-extras"/>
    </path>

    <path id="quick.partest-javaagent.build.path">
      <path refid="asm.classpath"/>
    </path>

    <path id="quick.scaladoc.build.path">
      <path refid="quick.compiler.build.path"/>
      <path refid="partest.classpath"/>
      <path refid="external-modules-nocore"/>
      <pathelement location="${build-quick.dir}/classes/scaladoc"/>
    </path>

    <path id="quick.interactive.build.path">
      <path refid="quick.compiler.build.path"/>
      <pathelement location="${build-quick.dir}/classes/interactive"/>
    </path>

    <path id="quick.bin.tool.path">
      <path refid="quick.repl-jline.build.path"/>
      <path refid="quick.actors.build.path"/>
      <pathelement location="${build-quick.dir}/classes/scalap"/>
      <pathelement location="${build-quick.dir}/classes/scaladoc"/>
      <path refid="external-modules-nocore"/>
    </path>

    <!-- PACK -->
    <path id="pack.compiler.path">
      <pathelement location="${library.jar}"/>
      <pathelement location="${reflect.jar}"/>
      <pathelement location="${compiler.jar}"/>
      <pathelement location="${ant.jar}"/>
      <path refid="forkjoin.classpath"/>
      <path refid="aux.libs"/>
    </path>

    <path id="pack.lib.path">
      <pathelement location="${library.jar}"/>
      <path refid="jarlister.classpath"/>
    </path>

    <path id="pack.bin.tool.path">
      <pathelement location="${library.jar}"/>
      <pathelement location="${xml.jar}"/>
      <pathelement location="${parser-combinators.jar}"/>
      <pathelement location="${actors.jar}"/>
      <pathelement location="${reflect.jar}"/>
      <pathelement location="${compiler.jar}"/>
      <!-- TODO modularize compiler: <pathelement location="${scaladoc.jar}"/> -->
      <pathelement location="${scalap.jar}"/>
      <path refid="repl.deps.classpath"/>
      <path refid="aux.libs"/>
    </path>

    <path id="pack.library.files">
      <fileset dir="${build-quick.dir}/classes/library"/>
      <fileset dir="${forkjoin-classes}"/>
      <fileset refid="scala-java8-compat.fileset"/>
    </path>

    <path id="pack.actors.files">
      <fileset dir="${build-quick.dir}/classes/actors"/>
    </path>

    <path id="pack.repl-jline.files">    <fileset dir="${build-quick.dir}/classes/repl-jline"/> </path>

    <path id="pack.compiler.files">
      <fileset dir="${build-quick.dir}/classes/compiler"/>

      <!-- TODO modularize compiler. Remove the other class dirs as soon as they become modules -->
      <fileset dir="${build-quick.dir}/classes/scaladoc"/>
      <fileset dir="${build-quick.dir}/classes/interactive"/>
      <fileset dir="${build-quick.dir}/classes/repl"/>
    </path>
    <fileset id="pack.compiler.include-jars" refid="asm.fileset"/>
    <property name="pack.compiler.include-jars.defined" value="yeah"/>

    <!-- TODO modularize compiler.
    <path id="pack.scaladoc.files">   <fileset dir="${build-quick.dir}/classes/scaladoc"/> </path>
    <path id="pack.interactive.files"><fileset dir="${build-quick.dir}/classes/interactive"/> </path>
    -->

    <path id="pack.reflect.files">    <fileset dir="${build-quick.dir}/classes/reflect"/> </path>
    <path id="pack.scalap.files">     <fileset dir="${build-quick.dir}/classes/scalap"/>  </path>

    <path id="pack.partest-extras.files"> <fileset dir="${build-quick.dir}/classes/partest-extras"/> </path>
    <path id="pack.partest-javaagent.files"> <fileset dir="${build-quick.dir}/classes/partest-javaagent"/> </path>

    <!-- STRAP -->
    <path id="strap.library.build.path">
      <pathelement location="${build-strap.dir}/classes/library"/>
      <path refid="forkjoin.classpath"/>
      <path refid="aux.libs"/>
    </path>

    <path id="strap.reflect.build.path">
      <path refid="strap.library.build.path"/>
      <pathelement location="${build-strap.dir}/classes/reflect"/>
    </path>

    <path id="strap.compiler.build.path">
      <path refid="strap.reflect.build.path"/>
      <pathelement location="${build-strap.dir}/classes/compiler"/>
      <path refid="asm.classpath"/>
    </path>

    <!-- DOCS -->
    <path id="docs.library.build.path">               <path refid="quick.library.build.path"/>  </path>
    <path id="docs.reflect.build.path">               <path refid="quick.reflect.build.path"/>  </path>
    <path id="docs.compiler.build.path">              <path refid="quick.compiler.build.path"/> </path>
    <path id="docs.scaladoc.build.path">              <path refid="quick.scaladoc.build.path"/> </path>
    <path id="docs.interactive.build.path">           <path refid="quick.interactive.build.path"/> </path>
    <path id="docs.scalap.build.path">                <path refid="quick.scalap.build.path"/>   </path>
    <path id="docs.actors.build.path">                <path refid="quick.actors.build.path"/>   </path>

    <!-- run-time classpath for scaladoc TODO: resolve through maven -->
    <path id="scaladoc.classpath">
      <path refid="external-modules-nocore"/>
      <pathelement location="${library.jar}"/>
      <pathelement location="${reflect.jar}"/>
      <pathelement location="${compiler.jar}"/>

      <!-- TODO modularize compiler
      <pathelement location="${interactive.jar}"/>
      <pathelement location="${scaladoc.jar}"/>
      -->

      <pathelement location="${ant.jar}"/>
      <path refid="aux.libs"/>
    </path>

    <path id="manual.build.path">
      <path refid="external-modules-nocore"/> <!-- xml -->
      <pathelement location="${library.jar}"/>
      <pathelement location="${build.dir}/manmaker/classes"/>
      <path refid="aux.libs"/>  <!-- for ant -->
    </path>

    <!-- MISC -->
    <path id="sbt.compile.build.path">
      <path refid="scaladoc.classpath"/>
      <!-- TODO modularize compiler: bring back when repl leaves compiler jar
        <pathelement location="${build-quick.dir}/classes/repl"/>
      -->
      <pathelement location="${sbt.interface.jar}"/>
    </path>


    <!--
       This is the classpath used to run partest, which is what it uses to run the compiler and find other required jars.
       "What's on the compiler's compilation path when compiling partest tests," you ask?
        Why, the compiler we're testing, of course, and partest with all its dependencies.
    -->
    <path id="partest.compilation.path">
      <path refid="partest.compilation.path.core"/>
      <path refid="partest.compilation.path.noncore"/>
    </path>
    <path id="partest.compilation.path.core">
      <pathelement location="${library.jar}"/>
      <pathelement location="${reflect.jar}"/>
      <pathelement location="${compiler.jar}"/>
    </path>
    <path id="partest.compilation.path.noncore">

      <!-- TODO modularize compiler
      <pathelement location="${scaladoc.jar}"/>
      <pathelement location="${interactive.jar}"/>
      -->

      <!-- TODO: move scalap & actors out of repo -->
      <pathelement location="${scalap.jar}"/>
      <pathelement location="${actors.jar}"/>

      <!-- partest's dependencies, which marks most of its dependencies as provided,
           (but not scala-library, so we filter that one out...)
           so we provide them: scala-[library/reflect/compiler], scalap built here,
           scala-xml, scala-parser-combinators via external-modules-nocore,
           scalacheck as part of `partest.classpath` -->
      <restrict>
        <path refid="partest.classpath"/>
        <rsel:not><rsel:or>
          <rsel:name name="scala-library*.jar"/>
        </rsel:or></rsel:not>
      </restrict>
      <pathelement location="${scala-xml}"/>
      <pathelement location="${scala-parser-combinators}"/>
      <!-- <pathelement location="${scala-swing}"/> -->

      <restrict>
        <path refid="scalacheck.classpath"/>
        <rsel:not><rsel:or>
          <rsel:name name="scala-library*.jar"/>
          <rsel:name name="scala-compiler*.jar"/>
          <rsel:name name="scala-reflect*.jar"/>
          <rsel:name name="scala-actors*.jar"/>
          <rsel:name name="scala-parser-combinators*.jar"/>
          <rsel:name name="scala-xml*.jar"/>
        </rsel:or></rsel:not>
      </restrict>

      <!-- partest classes specific to the core compiler build -->
      <pathelement location="${partest-extras.jar}"/>
      <pathelement location="${partest-javaagent.jar}"/>

      <!-- sneaky extras used in tests -->
      <fileset dir="${partest.dir}/files/lib" includes="*.jar" />
    </path>

    <path id="test.junit.compiler.build.path">
      <pathelement location="${test.junit.classes}"/>
      <path refid="quick.compiler.build.path"/>
      <path refid="quick.repl.build.path"/>
      <path refid="quick.scaladoc.build.path"/>
      <path refid="quick.partest-extras.build.path"/>
      <path refid="junit.classpath"/>
    </path>

    <path id="test.osgi.compiler.build.path">
      <pathelement location="${test.osgi.classes}"/>
      <pathelement location="${build-osgi.dir}/org.scala-lang.scala-library.jar"/>
      <pathelement location="${build-osgi.dir}/org.scala-lang.scala-reflect.jar"/>
      <pathelement location="${build-osgi.dir}/org.scala-lang.scala-compiler.jar"/>
      <pathelement location="${build-osgi.dir}/org.scala-lang.scala-actors.jar"/>
      <path refid="pax.exam.classpath"/>
      <path refid="forkjoin.classpath"/>
    </path>

    <path id="test.osgi.compiler.build.path.felix">
      <path refid="test.osgi.compiler.build.path"/>
      <path refid="osgi.framework.felix"/>
    </path>

    <path id="test.osgi.compiler.build.path.equinox">
      <path refid="test.osgi.compiler.build.path"/>
      <path refid="osgi.framework.equinox"/>
    </path>

    <path id="test.positions.sub.build.path" path="${build-quick.dir}/classes/library"/>

    <!-- TODO: consolidate *.includes -->
    <patternset id="lib.includes">
      <include name="**/*.tmpl"/>
      <include name="**/*.xml"/>
      <include name="**/*.js"/>
      <include name="**/*.css"/>
    </patternset>

    <patternset id="lib.rootdoc.includes">
      <include name="**/*.tmpl"/>
      <include name="**/*.xml"/>
      <include name="**/*.js"/>
      <include name="**/*.css"/>
      <include name="rootdoc.txt"/>
    </patternset>

    <patternset id="comp.includes">
      <include name="**/*.tmpl"/>
      <include name="**/*.xml"/>
      <include name="**/*.js"/>
      <include name="**/*.css"/>
      <include name="**/*.html"/>
      <include name="**/*.properties"/>
      <include name="**/*.swf"/>
      <include name="**/*.png"/>
      <include name="**/*.gif"/>
      <include name="**/*.txt"/>
    </patternset>

    <taskdef resource="scala/tools/ant/sabbus/antlib.xml" classpathref="starr.compiler.path"/>
    <taskdef name="jarjar" classname="com.tonicsystems.jarjar.JarJarTask" classpathref="jarjar.classpath" />
  </target>

<!-- ===========================================================================
                                  CLEANLINESS
=============================================================================-->
  <target name="libs.clean">                         <clean build="libs"/>                                               </target>
  <target name="quick.clean"  depends="libs.clean">  <clean build="quick"/> <clean build="pack"/> <clean build="strap"/> </target>
  <target name="locker.clean" depends="quick.clean"> <clean build="locker"/>                                             </target>

  <target name="docs.clean"> <clean build="docs"/> <delete dir="${build.dir}/manmaker" includeemptydirs="yes" quiet="yes" failonerror="no"/> </target>
  <target name="dist.clean"> <delete dir="${dists.dir}" includeemptydirs="yes" quiet="yes" failonerror="no"/> </target>

  <target name="junit.clean"> <clean build="junit"/> </target>

  <target name="all.clean" depends="locker.clean, docs.clean, junit.clean">
    <clean build="sbt"/> <clean build="osgi"/>
  </target>

  <!-- Used by the scala-installer script -->
  <target name="allallclean" depends="all.clean, dist.clean"/>

<!-- ===========================================================================
                                  LOCAL DEPENDENCIES
============================================================================ -->

  <target name="forkjoin.done" depends="init"> <simple-javac project="forkjoin" args="-XDignore.symbol.file" jar="no"/></target>

  <!-- For local development only. We only allow released versions of Scala for STARR.
    This builds quick (core only) and publishes it with a generated version number,
    saving it as starr.version in build.properties, so this compiler will be used as STARR in your next build
    NOTES:
      - to speed things up, you can also pass -Dlocker.skip=1
  -->
  <target name="replacestarr" depends="init.git" description="Produces a new STARR from current sources. Publishes core locally with a generated version number,
    stored in build.properties as starr.version (overriding the one in versions.properties).">
    <antcall target="publish-core-local">
      <param name="maven.version.suffix" value="-STARR-${git.commit.sha}-SNAPSHOT"/>
      <param name="docs.skip" value="1"/>
      <param name="scalac.args.optimise" value="-optimise"/>
      <param name="update.starr.version" value="alright then"/>
    </antcall>
  </target>


<!-- ===========================================================================
                                  LOCAL REFERENCE BUILD (LOCKER)
============================================================================ -->
  <target name="locker.start"  depends="forkjoin.done">
    <condition property="locker.locked"><available file="${build-locker.dir}/locker.locked"/></condition></target>

  <target name="locker.lib"    depends="locker.start"     unless="locker.locked">
    <staged-build with="starr" stage="locker" project="library" srcpath="${src.dir}/library" includes="lib.includes"/></target>

  <target name="locker.reflect" depends="locker.lib"      unless="locker.locked">
    <staged-build with="starr" stage="locker" project="reflect"/></target>

  <target name="locker.comp"    depends="locker.reflect" unless="locker.locked">
    <staged-build with="starr" stage="locker" project="compiler"/></target>

  <target name="locker.done"    depends="locker.comp">
    <mkdir dir="${build-locker.dir}"/>
    <touch file="${build-locker.dir}/locker.locked" verbose="no"/>
  </target>
  <target name="locker.unlock"> <delete file="${build-locker.dir}/locker.locked"/>
                                <delete file="${build-locker.dir}/*.complete"/></target>

<!-- ===========================================================================
                                  QUICK BUILD (QUICK)
============================================================================ -->
  <target name="quick.start"      depends="locker.done"/>

  <target name="quick.lib"        depends="quick.start">
    <staged-build with="locker"   stage="quick" project="library" srcpath="${src.dir}/library" includes="lib.rootdoc.includes"/></target>

  <target name="quick.reflect"    depends="quick.lib">
    <staged-build with="locker"   stage="quick" project="reflect"/> </target>

  <target name="quick.comp"       depends="quick.reflect">
    <staged-build with="locker"   stage="quick" project="compiler"/> </target>

  <target name="quick.repl"       depends="quick.comp, quick.interactive">
    <staged-build with="locker"   stage="quick" project="repl"/>
    <staged-build with="locker"   stage="quick" project="repl-jline"/>

    <staged-pack project="repl-jline"/>

    <!-- make jline_embedded jar with classes of repl-jline and jline, then shade-->
    <jarjar jarfile="${build-pack.dir}/${repl-jline.targetdir}/scala-repl-jline-embedded.jar" whenmanifestonly="fail">
      <zipfileset src="${jline:jline:jar}"/>
      <zipfileset src="${build-pack.dir}/${repl-jline.targetdir}/${repl-jline.targetjar}"/>

      <rule pattern="org.fusesource.**" result="scala.tools.fusesource_embedded.@1"/>
      <rule pattern="jline.**" result="scala.tools.jline_embedded.@1"/>
      <rule pattern="scala.tools.nsc.interpreter.jline.**" result="scala.tools.nsc.interpreter.jline_embedded.@1"/>
      <keep pattern="scala.tools.**"/>
    </jarjar>

    <!-- unzip jar to repl's class dir to obtain
           - standard repl-jline
           - a shaded repl-jline (scala/tools/nsc/interpreter/jline_embedded) & jline (scala.tools.jline_embedded)
    -->
    <copy todir="${build-quick.dir}/classes/repl">
      <zipfileset src="${build-pack.dir}/${repl-jline.targetdir}/${repl-jline.targetjar}"/>
      <zipfileset src="${build-pack.dir}/${repl-jline.targetdir}/scala-repl-jline-embedded.jar"/>
    </copy>
  </target>

  <target name="quick.scaladoc"   depends="quick.comp">
    <staged-build with="locker"   stage="quick" project="scaladoc"/> </target>

  <target name="quick.interactive" depends="quick.comp, quick.scaladoc">
    <staged-build with="locker"    stage="quick" project="interactive"/> </target>

  <target name="quick.scalap"     depends="quick.repl">
    <staged-build with="locker"   stage="quick" project="scalap"/> </target>

  <target name="quick.actors"     depends="quick.lib">
    <staged-build with="locker"   stage="quick" project="actors"/> </target>



  <target name="quick.modules" depends="quick.repl, quick.scaladoc, quick.interactive, quick.scalap"/>

  <target name="quick.bin" depends="quick.lib, quick.reflect, quick.comp, quick.modules">
    <staged-bin stage="quick" classpathref="quick.bin.tool.path"/>
  </target>

  <target name="quick.done" depends="quick.bin"/>
  <target name="quick-opt" description="Optimized version of quick.done."> <optimized name="quick.done"/></target>


<!-- ===========================================================================
                                  PACKED QUICK BUILD (PACK)
============================================================================ -->
  <target name="pack.lib" depends="quick.lib, forkjoin.done"> <staged-pack project="library"/>
    <taskdef resource="scala/tools/ant/antlib.xml" classpathref="pack.lib.path"/>
    <jarlister file="${library.jar}"/>
  </target>

  <target name="pack.reflect" depends="quick.reflect"> <staged-pack project="reflect"/> </target>

  <!-- TODO modularize compiler. Remove other quick targets when they become modules. -->
  <target name="pack.comp"    depends="quick.comp, quick.scaladoc, quick.interactive, quick.repl">
    <staged-pack project="compiler" manifest="${build-pack.dir}/META-INF/MANIFEST.MF">
      <pre> <!-- TODO the files copied here do not influence actuality of this target (nor does the manifest) -->
        <copy todir="${build-pack.dir}/lib">
          <resources refid="repl.fileset"/>
          <mapper classpathref="maven-ant-tasks.classpath" classname="org.apache.maven.artifact.ant.VersionMapper" from="${repl.deps.versions}" to="flatten"/>
        </copy>
        <copy todir="${build-pack.dir}/lib">
          <fileset dir="${lib-extra.dir}">
            <include name="**/*.jar"/>
          </fileset>
        </copy>
        <mkdir dir="${build-pack.dir}/META-INF"/>
        <copy file="${basedir}/META-INF/MANIFEST.MF" toDir="${build-pack.dir}/META-INF"/>
        <manifest file="${build-pack.dir}/META-INF/MANIFEST.MF" mode="update">
          <attribute name="Bundle-Version" value="${version.number}"/>
          <attribute name="Class-Path" value="scala-reflect.jar scala-library.jar"/>
        </manifest>
      </pre>
      <!-- JSR-223 support introduced in 2.11 -->
      <jar-opts>
        <service type="javax.script.ScriptEngineFactory" provider="scala.tools.nsc.interpreter.IMain$Factory"/>
      </jar-opts>
    </staged-pack>
  </target>

  <!-- TODO modularize compiler. These targets are currently not used.
  <target name="pack.scaladoc" depends="quick.scaladoc">       <staged-pack project="scaladoc"/> </target>
  <target name="pack.interactive" depends="quick.interactive"> <staged-pack project="interactive"/> </target>
  -->

  <target name="pack.actors" depends="quick.actors"> <staged-pack project="actors"/> </target>

  <target name="pack.scalap"     depends="quick.scalap">     <staged-pack project="scalap"/> </target>

  <target name="pack.core" depends="pack.reflect, pack.comp, pack.lib"/>

  <!-- TODO modularize compiler: pack.scaladoc, pack.interactive, -->
  <target name="pack.modules" depends="pack.actors, pack.scalap">
    <copy todir="${build-pack.dir}/lib">
      <path refid="external-modules-nocore" />
      <mapper type="flatten" />
    </copy>
  </target>

  <!-- depends on pack.core for scaladoc -->
  <target name="scaladoc.task" depends="pack.core, pack.modules" unless="docs.skip">
    <taskdef resource="scala/tools/ant/antlib.xml" classpathref="scaladoc.classpath"/>
  </target>

  <target name="pack.partest-extras" depends="quick.comp">
    <!-- compile compiler-specific parts of partest -->
    <staged-build with="quick" stage="quick" project="partest-extras" />
    <staged-build with="quick" stage="quick" project="partest-javaagent" />

    <staged-pack project="partest-extras"/>
    <staged-pack project="partest-javaagent"
                 manifest="${src.dir}/partest-javaagent/scala/tools/partest/javaagent/MANIFEST.MF"/>
  </target>

  <target name="pack.bin" depends="pack.core, pack.modules, pack.partest-extras">
    <staged-bin stage="pack"/>
  </target>

  <!-- depend on quick.done so quick.bin is run when pack.done is -->
  <target name="pack.done" depends="quick.done, pack.bin"/>


<!-- ===========================================================================
                                  BOOTSTRAPPING BUILD (STRAP)
============================================================================ -->
  <target name="strap.done" depends="pack.done">
    <staged-build with="pack" stage="strap" project="library" srcpath="${src.dir}/library" includes="lib.rootdoc.includes"/>
    <staged-build with="pack" stage="strap" project="reflect"/>
    <staged-build with="pack" stage="strap" project="compiler"/>
  </target>

  <target name="strap-opt" description="Optimized version of strap.done."> <optimized name="strap.done"/></target>


<!-- ===========================================================================
                                  OSGi Artifacts
============================================================================ -->
  <!-- This task takes the output of the pack stage and OSGi-fies the jars based on the bnd files in src/build/bnd
       This means adding manifests and enforcing the Exports clauses (removing non-exported classes!)
       These jars are then copied to the distribution and published to maven.
  -->


  <target name="osgi.core" depends="pack.core">
    <mkdir dir="${build-osgi.dir}"/>

    <uptodate property="osgi.bundles.available" targetfile="${build-osgi.dir}/bundles.core.complete">
      <srcresources>
        <fileset dir="${basedir}">
          <include name="build.xml"/>
          <include name="build-ant-macros.xml"/>
          <include name="src/build/bnd/*.bnd"/>
        </fileset>
        <filelist>
          <file name="${library.jar}"/>
          <file name="${reflect.jar}"/>
          <file name="${compiler.jar}"/>
        </filelist>
      </srcresources>
    </uptodate>

    <if><not><isset property="osgi.bundles.available"/></not><then>
      <stopwatch name="osgi.core.timer"/>
      <make-bundle project="library">
        <fileset dir="${src.dir}/library"/>
      </make-bundle>

      <make-bundle project="reflect">
        <fileset dir="${src.dir}/reflect"/>
      </make-bundle>

      <!-- TODO modularize compiler. Remove the other class dirs as soon as they become modules -->
      <make-bundle project="compiler">
        <fileset dir="${src.dir}/compiler"/>
        <fileset dir="${src.dir}/scaladoc"/>
        <fileset dir="${src.dir}/interactive"/>
        <fileset dir="${src.dir}/repl"/>
      </make-bundle>

      <touch file="${build-osgi.dir}/bundles.core.complete" verbose="no"/>
      <stopwatch name="osgi.core.timer" action="total"/>
    </then></if>
  </target>

  <target name="osgi.done" depends="pack.done, osgi.core">
    <uptodate property="osgi.all.bundles.available" targetfile="${build-osgi.dir}/bundles.all.complete">
      <srcresources>
        <fileset dir="${basedir}">
          <include name="build.xml"/>
          <include name="build-ant-macros.xml"/>
          <include name="src/build/bnd/*.bnd"/>
        </fileset>
        <filelist>
            <!-- TODO modularize compiler
            <include name="${interactive.jar}"/>
            <include name="${scaladoc.jar}"/>
            -->

          <file name="${actors.jar}"/>

          <file name="${continuations-plugin.jar}"/>
          <file name="${continuations-library.jar}"/>
          <file name="${parser-combinators.jar}"/>
          <file name="${xml.jar}"/>
          <file name="${swing.jar}"/>
        </filelist>
      </srcresources>
    </uptodate>

    <if><not><isset property="osgi.all.bundles.available"/></not><then>
      <stopwatch name="osgi.all.timer"/>

      <!-- TODO modularize compiler
      TODO: refactor so that we can restrict exported packages to scala.tools.nsc.doc.*
           move ant task, partest stuff to other jars,
           and move scala.tools.nsc.ScalaDoc main class to scala.tools.nsc.doc
      <make-bundle project="scaladoc">
        <fileset dir="${src.dir}/scaladoc"/>
      </make-bundle>

      TODO: refactor so that we can restrict exported packages to scala.tools.nsc.interactive.*
      <make-bundle project="interactive">
        <fileset dir="${src.dir}/interactive"/>
      </make-bundle>
      -->

      <make-bundle project="actors">
        <fileset dir="${src.dir}/actors"/>
      </make-bundle>


      <make-bundle project="continuations-plugin"/>
      <make-bundle project="continuations-library"/>
      <make-bundle project="parser-combinators"/>
      <make-bundle project="xml"/>
      <make-bundle project="swing"/>

      <touch file="${build-osgi.dir}/bundles.all.complete" verbose="no"/>
      <stopwatch name="osgi.all.timer" action="total"/>
    </then></if>
  </target>


<!-- ===========================================================================
                                  TEST SUITE
============================================================================ -->
  <!-- bootstrapping stability: compare {quick,strap}/(lib|reflect|comp) -->
  <target name="test.stability" depends="strap.done">
    <exec osfamily="unix" vmlauncher="false" executable="${basedir}/tools/stability-test.sh" failonerror="true" />
    <!-- I think doing it this way means it will auto-pass on windows... that's the idea. If not, something like this. -->
    <!-- <exec osfamily="windows" executable="foo" failonerror="false" failifexecutionfails="false" /> -->
  </target>

  <target name="test.stability-opt" description="Optimized version of test.stability."> <optimized name="test.stability"/></target>

  <target name="test.osgi.init" depends="osgi.done">
    <uptodate property="test.osgi.available" targetfile="${build-osgi.dir}/test-compile.complete">
      <srcfiles dir="${test.osgi.src}">
        <include name="**/*.scala"/>
      </srcfiles>
    </uptodate>
  </target>

  <target name="test.osgi.comp" depends="test.osgi.init, quick.done" unless="test.osgi.available">
    <stopwatch name="test.osgi.compiler.timer"/>
    <mkdir dir="${test.osgi.classes}"/>
    <scalacfork
      destdir="${test.osgi.classes}"
      compilerpathref="quick.compiler.path"
      params="${scalac.args.quick}"
      srcdir="${test.osgi.src}"
      jvmargs="${scalacfork.jvmargs}">
      <include name="**/*.scala"/>
      <compilationpath refid="test.osgi.compiler.build.path.felix"/>
    </scalacfork>
    <touch file="${build-osgi.dir}/test-compile.complete" verbose="no"/>
    <stopwatch name="test.osgi.compiler.timer" action="total"/>
  </target>

  <target name="test.osgi" depends="test.osgi.comp">
    <if><isset property="test.osgi.skip"/><then>
      <echo message="Skipping OSGi JUnit tests"/>
    </then><else>
      <echo message="Running OSGi JUnit tests. Output in ${build-osgi.dir}"/>
      <stopwatch name="test.osgi.timer"/>
      <mkdir dir="${test.osgi.classes}"/>

      <echo message="Test pass 1 of 2 using Apache Felix ${osgi.felix.version}"/>
      <junit fork="yes" haltonfailure="yes">
        <classpath refid="test.osgi.compiler.build.path.felix"/>
        <jvmarg value="-Duser.home=${user.home}"/>
        <batchtest fork="yes" todir="${build-osgi.dir}">
          <fileset dir="${test.osgi.classes}">
            <include name="**/*Test.class"/>
          </fileset>
        </batchtest>
        <formatter type="xml" />
      </junit>

      <echo message="Test pass 2 of 2 using Eclipse Equinox ${osgi.equinox.version}"/>
      <junit fork="yes" haltonfailure="yes">
        <classpath refid="test.osgi.compiler.build.path.equinox"/>
        <jvmarg value="-Duser.home=${user.home}"/>
        <batchtest fork="yes" todir="${build-osgi.dir}">
          <fileset dir="${test.osgi.classes}">
            <include name="**/*Test.class"/>
          </fileset>
        </batchtest>
        <formatter type="xml" /> <!-- silenced by having it use a file; I tried for an hour to use other formatters but classpath issues drove me to this usefile="false" -->
      </junit>
      <stopwatch name="test.osgi.timer" action="total"/>
    </else></if>
  </target>


<!-- ===========================================================================
                                  SBT Compiler Interface
============================================================================ -->
  <target name="test.sbt" depends="quick.done">
    <if><not><and>
        <available file="${sbt.interface.jar}"/>
        <available file="${sbt.interface.src.jar}"/></and></not>
    <then>
      <!-- Ensure directories exist -->
      <mkdir dir="${sbt.src.dir}"/>
      <mkdir dir="${sbt.lib.dir}"/>

      <get src="${sbt.interface.url}" dest="${sbt.interface.jar}"/>
      <get src="${sbt.interface.src.url}" dest="${sbt.interface.src.jar}"/>

      <!-- Explode sources -->
      <unzip src="${sbt.interface.src.jar}" dest="${sbt.src.dir}"/>
    </then></if>

    <stopwatch name="quick.sbt-interface.timer"/>
    <mkdir dir="${build-sbt.dir}/classes"/>
    <scalacfork
      destdir="${build-sbt.dir}/classes"
      compilerpathref="quick.compiler.path"
      params="${scalac.args.quick}"
      srcdir="${sbt.src.dir}"
      jvmargs="${scalacfork.jvmargs}">
      <include name="**/*.scala"/>
      <compilationpath refid="sbt.compile.build.path"/>
    </scalacfork>
    <touch file="${build-sbt.dir}/sbt-interface.complete" verbose="no"/>
    <stopwatch name="quick.sbt-interface.timer" action="total"/>
  </target>

  <target name="test.junit.comp" depends="pack.done">
    <stopwatch name="test.junit.compiler.timer"/>
    <mkdir dir="${test.junit.classes}"/>
    <javac
      debug="true"
      srcdir="${test.junit.src}"
      destdir="${test.junit.classes}"
      classpathref="test.junit.compiler.build.path"
      target="1.6"
      source="1.5"
      compiler="javac1.6"
      includes="**/*.java"/>
    <scalacfork
      destdir="${test.junit.classes}"
      compilerpathref="quick.compiler.path"
      params="${scalac.args.quick}"
      srcdir="${test.junit.src}"
      jvmargs="${scalacfork.jvmargs}">
      <include name="**/*.scala"/>
      <compilationpath refid="test.junit.compiler.build.path"/>
    </scalacfork>
    <touch file="${build-junit.dir}/test-compile.complete" verbose="no"/>
    <stopwatch name="test.junit.compiler.timer" action="total"/>
  </target>

  <target name="test.junit" depends="test.junit.comp">
    <stopwatch name="test.junit.timer"/>
    <mkdir dir="${test.junit.classes}"/>
    <echo message="Note: details of failed tests will be output to ${build-junit.dir}"/>

    <if><isset property="test.method" /><then><property name="test.methods" value="${test.method}" /></then></if>
    <junit fork="yes" haltonfailure="yes" printsummary="on">
      <classpath refid="test.junit.compiler.build.path"/>
      <test fork="yes" todir="${build-junit.dir}" if="test.class" unless="test.methods" name="${test.class}" />
      <test fork="yes" todir="${build-junit.dir}" if="test.methods" name="${test.class}" methods="${test.methods}" />
      <batchtest fork="yes" todir="${build-junit.dir}" unless="test.class">
        <fileset dir="${test.junit.classes}">
          <include name="**/*Test.class"/>
        </fileset>
      </batchtest>
      <formatter type="plain"/>
    </junit>
    <stopwatch name="test.junit.timer" action="total"/>
  </target>

  <!-- See test/build-partest.xml for the macro(s) being used here. -->
  <target name="partest.task" depends="pack.done">
    <!-- note the classpathref! this is the classpath used to run partest,
    so it must have the new compiler.... -->
    <taskdef
       classpathref="partest.compilation.path"
       resource="scala/tools/partest/antlib.xml"/>
  </target>

  <target name="test.suite.init" depends="partest.task">
    <!-- read by test/partest to determine classpath used to run partest -->
    <propertyfile file = "build/pack/partest.properties">
      <!-- TODO: change "partest.classpath" to "partest.runtime.classpath" or something -->
      <entry key       = "partest.classpath" value="${toString:partest.compilation.path}"/>
    </propertyfile>
  </target>

  <target name="test.suite" depends="test.suite.init">
    <testSuite kinds="pos neg run jvm res scalap scalacheck specialized instrumented"/>
  </target>

  <target name="test.suite.color" depends="test.suite.init">
    <testSuite colors="8" kinds="pos neg run jvm res scalap scalacheck specialized instrumented"/>
  </target>

  <target name="test.suite.quick" depends="init, quick.done">
    <path id="test.suite.path">
      <path refid="quick.bin.tool.path"/>
      <path refid="quick.interactive.build.path"/>
      <path refid="partest.compilation.path.noncore"/>
    </path>
    <property name="pcp" value="${toString:test.suite.path}"/>
    <taskdef classpathref="test.suite.path" resource="scala/tools/partest/antlib.xml"/>
    <testSuite colors="8" kinds="pos neg run jvm res scalap scalacheck specialized instrumented" pcp="${pcp}"/>
  </target>

  <target name="test.run" depends="test.suite.init">
    <testSuite kinds="run jvm"/>
  </target>

  <target name="test.scaladoc" depends="test.suite.init">
    <testSuite kinds="run scalacheck" srcdir="scaladoc"/>
  </target>

  <target name="test.interactive" depends="test.suite.init">
    <testSuite kinds="presentation"/>
  </target>

  <!-- for use in PR validation, where stability is rarely broken, so we're going to use starr for locker,
       and skip test.stability (which requires locker == quick) -->
  <target name="test.core" depends="test.osgi, test.sbt, test.bc, test.junit, test.interactive, test.scaladoc, test.suite"/>
  <target name="test.done" depends="test.core, test.stability"/>

<!-- ===========================================================================
                                  BINARY COMPATIBILITY TESTING
============================================================================ -->
  <target name="bc.init" depends="init" if="test.bc.skip">
    <!-- if test.bc.skip is set, make sure that pc.prepare is not executed either -->
    <property name="maven-deps-done-mima" value="true"/>
  </target>

  <target name="bc.prepare" depends="bc.init" unless="maven-deps-done-mima">
    <property name="bc-reference-version" value="2.11.0"/>

    <property name="bc-build.dir" value="${build.dir}/bc"/>
    <!-- Obtain mima -->
    <mkdir dir="${bc-build.dir}"/>
    <!-- Pull down MIMA -->
    <artifact:dependencies pathId="mima.classpath">
      <dependency groupId="com.typesafe" artifactId="mima-reporter_2.10" version="0.1.14"/>
    </artifact:dependencies>
    <artifact:dependencies pathId="old.bc.classpath">
      <dependency groupId="org.scala-lang" artifactId="scala-library" version="${bc-reference-version}"/>
      <dependency groupId="org.scala-lang" artifactId="scala-reflect" version="${bc-reference-version}"/>
    </artifact:dependencies>
    <property name="maven-deps-done-mima" value="true"/>
  </target>

  <target name="test.bc-opt" description="Optimized version of test.bc."> <optimized name="test.bc"/></target>
  <target name="test.bc" depends="bc.prepare, pack.lib, pack.reflect" unless="test.bc.skip">
    <bc.check project="library"/>
    <bc.check project="reflect"/>
  </target>

<!-- ===========================================================================
                                  DOCUMENTATION
============================================================================ -->
  <target name="docs.start" depends="scaladoc.task" unless="docs.skip">
    <!-- Set the github commit scaladoc sources point to -->
    <!-- For releases, look for the tag with the same name as the maven version -->
    <condition property="scaladoc.git.commit" value="v${maven.version.number}">
      <isset property="build.release"/>
    </condition>
    <!-- For snapshots, if we know the commit, point scaladoc to that particular commit instead of master -->
    <condition property="scaladoc.git.commit" value="${git.commit.sha}">
      <not><equals arg1="${git.commit.sha}" arg2="unknown"/></not>
    </condition>
    <!-- Fallback: point scaladoc to master -->
    <property name="scaladoc.git.commit" value="master"/>
    <!-- Compute the URL and show it -->
    <property name="scaladoc.url" value="https://github.com/scala/scala/tree/${scaladoc.git.commit}/src"/>
    <echo message="Scaladoc will point to ${scaladoc.url} for source files."/>

    <!-- Unless set with -Dscaladoc.<...>, these won't be activated -->
    <property name="scaladoc.raw.output" value="no"/>
    <property name="scaladoc.no.prefixes" value="no"/>
  </target>

  <target name="docs.lib" depends="docs.start" unless="docs.skip">
    <staged-docs project="library">
      <include name="**/*.scala"/>
      <exclude name="**/runtime/*$.scala"/>
      <exclude name="**/runtime/ScalaRunTime.scala"/>
      <exclude name="**/runtime/StringAdd.scala"/>
    </staged-docs>
  </target>

  <target name="docs.reflect" depends="docs.start" unless="docs.skip">
    <staged-docs project="reflect">
      <include name="**/*.scala"/>
    </staged-docs>
  </target>

  <target name="docs.comp" depends="docs.start" unless="docs.skip">
    <staged-docs project="compiler">
      <include name="**/*.scala"/>
    </staged-docs>
  </target>

  <!-- TODO modularize compiler. These targets are currently not used.
  <target name="docs.scaladoc" depends="docs.start" unless="docs.skip">
    <staged-docs project="scaladoc">
      <include name="**/*.scala"/>
    </staged-docs>
  </target>

  <target name="docs.interactive" depends="docs.start" unless="docs.skip">
    <staged-docs project="interactive">
      <include name="**/*.scala"/>
    </staged-docs>
  </target>
  -->

  <target name="docs.actors" depends="docs.start" unless="docs.skip">
    <staged-docs project="actors">
      <include name="**/*.scala"/>
    </staged-docs>
  </target>

  <target name="docs.scalap" depends="docs.start" unless="docs.skip">
    <staged-docs project="scalap">
      <include name="**/*.scala"/>
    </staged-docs>
  </target>

  <target name="docs.core" depends="docs.lib, docs.reflect, docs.comp" unless="docs.skip"/>
  <!-- TODO modularize compiler:  docs.scaladoc, docs.interactive, -->
  <target name="docs.done" depends="docs.core, docs.actors, docs.scalap" unless="docs.skip"/>

  <!-- doc/ and man/ -->
  <target name="pack.doc" depends="scaladoc.task" unless="docs.skip"> <!-- depends on scaladoc.task for scalac taskdef -->
    <mkdir dir="${build-pack.dir}/doc"/>
    <copy toDir="${build-pack.dir}/doc" overwrite="true">
      <fileset dir="${doc.dir}"/>
    </copy>

    <mkdir dir="${build-pack.dir}/doc/tools"/>
    <mkdir dir="${build-pack.dir}/man/man1"/>
    <staged-uptodate stage="manual" project="manual">
      <check><srcfiles dir="${src.dir}/manual"/></check>
      <do>
        <mkdir dir="${build.dir}/manmaker/classes"/>
        <scalac
          destdir="${build.dir}/manmaker/classes"
          classpathref="manual.build.path"
          srcdir="${src.dir}/manual"
          includes="**/*.scala"
          addparams="${scalac.args.all} -language:implicitConversions"/>
        <mkdir dir="${build-manual.dir}/genman/man1"/>
        <taskdef name="genman"
                 classname="scala.tools.docutil.ManMaker"
                 classpathref="manual.build.path"/>
        <genman command="fsc, scala, scalac, scaladoc, scalap"
                htmlout="${build-pack.dir}/doc/tools"
                manout="${build-manual.dir}/genman"/>
      </do>
    </staged-uptodate>

    <!-- On Windows source and target files can't be the same ! -->
    <fixcrlf
      srcdir="${build-manual.dir}/genman"
      destdir="${build-pack.dir}/man"
      eol="unix" includes="**/*.1"/>
    <copy todir="${build-pack.dir}/doc/tools" overwrite="true">
      <fileset dir="${src.dir}/manual/scala/tools/docutil/resources">
        <include name="**/*.html"/>
        <include name="**/*.css"/>
        <include name="**/*.gif"/>
        <include name="**/*.png"/>
      </fileset>
    </copy>
  </target>

<!-- ===========================================================================
MAIN DISTRIBUTION PACKAGING
============================================================================ -->
  <target name="pack-maven.core" depends="osgi.core, docs.core">
    <property name="dist.maven" value="${dists.dir}/maven/${version.number}"/>
    <mkdir dir="${dist.maven}"/>

    <mvn-package project="library"/>
    <mvn-package project="reflect"/>
    <mvn-package project="compiler"/>

    <copy tofile="${dist.maven}/scala-library-all/scala-library-all-pom.xml"
            file="${src.dir}/build/maven/scala-library-all-pom.xml" overwrite="true"/>

    <!-- for replacestarr -->
    <if><isset property="update.starr.version"/><then>
      <echo message="From now on, ${maven.version.number} will be used as STARR (`build.properties`'s `starr.version` was modified)."/>
      <propertyfile file = "build.properties">
        <entry key       = "starr.version" value="${maven.version.number}"/>
      </propertyfile>
    </then></if>
  </target>

  <target name="pack-maven.done" depends="pack-maven.core, osgi.done, docs.done, pack.bin, pack.doc">
    <!-- TODO modularize compiler
    <mvn-package project="interactive"/>
    <mvn-package project="scaladoc"/>
    -->

    <mvn-package project="actors"/>

    <!-- don't bother fitting scalap into the mould: it will move out soon -->
    <copy tofile="${dist.maven}/scalap/scalap-pom.xml" file="${src.dir}/build/maven/scalap-pom.xml" overwrite="true"/>
    <copy tofile="${dist.maven}/scalap/scalap.jar" file="${scalap.jar}" overwrite="true"/>
    <jar destfile="${dist.maven}/scalap/scalap-src.jar" basedir="${src.dir}/scalap" whenmanifestonly="fail"/>
    <if><not><isset property="docs.skip"/></not><then>
      <jar destfile="${dist.maven}/scalap/scalap-docs.jar" basedir="${build-docs.dir}/scalap"/>
    </then></if>

    <copy tofile="${dist.maven}/scala-dist/scala-dist-pom.xml" file="${src.dir}/build/maven/scala-dist-pom.xml" overwrite="true"/>
    <jar whenmanifestonly="fail" destfile="${dist.maven}/scala-dist/scala-dist.jar" basedir="${build-pack.dir}">
      <include name="bin/" />
      <include name="doc/" />
      <include name="man/" />
    </jar>
  </target>

<!-- ===========================================================================
                                  MAVEN PUBLISHING
============================================================================ -->
  <target name="init.maven" depends="init">
    <property name="remote.snapshot.repository" value="https://oss.sonatype.org/content/repositories/snapshots" />
    <property name="remote.release.repository"  value="https://oss.sonatype.org/service/local/staging/deploy/maven2" />

    <property name="local.snapshot.repository" value="${user.home}/.m2/repository" />
    <property name="local.release.repository"  value="${user.home}/.m2/repository" />

    <property name="repository.credentials.id" value="sonatype-nexus" />
    <property name="settings.file" value="${user.home}/.m2/settings.xml" />

    <if><contains string="${maven.version.number}" substring="-SNAPSHOT"/><then>
      <property name="remote.repository" value="${remote.snapshot.repository}"/>
      <property name="local.repository"  value="${local.snapshot.repository}"/>
    </then><else>
      <property name="remote.repository" value="${remote.release.repository}"/>
      <property name="local.repository"  value="${local.release.repository}"/>
    </else></if>
  </target>

  <target name="publish"        depends="pack-maven.done, init.maven" description="Publishes unsigned artifacts to the maven repo.">
    <deploy />
    <deploy-pom name="scala-library-all"/>
    <deploy-jar name="scala-dist"/>
  </target>

  <target name="publish.local"  depends="pack-maven.done, init.maven" description="Publishes unsigned artifacts to the local maven repo.">
    <deploy local="true"/>
    <deploy-pom name="scala-library-all" local="true"/>
    <deploy-jar name="scala-dist" local="true"/>
  </target>

  <target name="publish.signed" depends="pack-maven.done, init.maven" description="Publishes signed artifacts to the remote maven repo.">
    <deploy signed="true"/>
    <deploy-pom name="scala-library-all" signed="true"/>
    <deploy-jar name="scala-dist" signed="true"/>
  </target>

  <target name="publish-core"   depends="pack-maven.core, init.maven">
    <deploy-one name="scala-compiler" />
    <deploy-one name="scala-library"  />
    <deploy-one name="scala-reflect"  />
  </target>

  <target name="publish-core-local" depends="pack-maven.core, init.maven">
    <deploy-one name="scala-compiler" local="true"/>
    <deploy-one name="scala-library"  local="true"/>
    <deploy-one name="scala-reflect"  local="true"/>
  </target>

  <target name="publish-core-opt" description="Builds an untested optimised core (library/reflect/compiler) and publishes to maven.">
    <optimized name="publish-core"/>
  </target>

<!-- ===========================================================================
                                  VISUALIZATION
============================================================================ -->

  <target name="graph.init">
    <taskdef name="vizant" classname="vizant.Vizant" classpath="${lib-ant.dir}/vizant.jar"/>
  </target>

  <target name="graph.all" depends="graph.init">
    <vizant antfile="${ant.file}" outfile="${ant.project.name}.dot" from="all.done"/>
  </target>

  <target name="graph.sabbus" depends="graph.init">
    <vizant antfile="${ant.file}" outfile="${ant.project.name}.dot"/>
  </target>
</project>
