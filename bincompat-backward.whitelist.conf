filter {
  packages = [
    "scala.reflect.internal"
    # "scala.concurrent.impl"
    # "scala.reflect.runtime"
  ]
  problems=[
    // see SI-8372
    {
        matchName="scala.collection.mutable.ArrayOps#ofChar.unzip"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofChar.unzip3"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofByte.unzip"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofByte.unzip3"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofShort.unzip"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofShort.unzip3"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofLong.unzip"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofLong.unzip3"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofInt.unzip"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofInt.unzip3"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps.unzip"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps.unzip3"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps.unzip"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps.unzip3"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofFloat.unzip"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofFloat.unzip3"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofBoolean.unzip"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofBoolean.unzip3"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofRef.unzip"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofRef.unzip3"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofUnit.unzip"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofUnit.unzip3"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofDouble.unzip"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofDouble.unzip3"
        problemName=IncompatibleMethTypeProblem
    },
    // see SI-9732
    {
        matchName="scala.collection.mutable.OpenHashMap$OpenEntry"
        problemName=MissingTypesProblem
    },
    {
        matchName="scala.collection.mutable.OpenHashMap#OpenEntry.value_="
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.OpenHashMap#OpenEntry.value"
        problemName=IncompatibleResultTypeProblem
    },
    {
        matchName="scala.collection.mutable.OpenHashMap#OpenEntry.this"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.OpenHashMap#OpenEntry.next"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.collection.mutable.OpenHashMap#OpenEntry.next_="
        problemName=MissingMethodProblem
    },
    // see SI-8200
    {
        matchName="scala.reflect.api.StandardLiftables#StandardLiftableInstances.liftTree"
        problemName=MissingMethodProblem
    },
    // see SI-8331
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi#SyntacticTypeAppliedExtractor.unapply"
        problemName=IncompatibleResultTypeProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi#SyntacticTypeAppliedExtractor.unapply"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticSelectType"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticAppliedType"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticSelectTerm"
        problemName=MissingMethodProblem
    },
    // see SI-8366
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticPartialFunction"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Mirror.symbolOf"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Mirror.typeOf"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Mirror.weakTypeOf"
        problemName=MissingMethodProblem
    },
    // see SI-8388
    {
        matchName="scala.reflect.api.Internals$ReificationSupportApi$SyntacticIdentExtractor"
        problemName=MissingClassProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticIdent"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticSingletonType"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticTermIdent"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticTypeIdent"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticCompoundType"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticAnnotatedType"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticTypeProjection"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticExistentialType"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.runtime.SynchronizedOps.newNestedScope"
        problemName=MissingMethodProblem
    },
    // https://github.com/scala/scala/pull/3848 -- SI-8680
    {
        matchName="scala.collection.immutable.Stream.scala$collection$immutable$Stream$$loop$6"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.collection.immutable.Stream.scala$collection$immutable$Stream$$loop$5"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.collection.immutable.Stream.scala$collection$immutable$Stream$$loop$4"
        problemName=MissingMethodProblem
    },
    // SI-8946
    {
        matchName="scala.reflect.runtime.ThreadLocalStorage#MyThreadLocalStorage.values"
        problemName=MissingMethodProblem
    },
    // the below method was the unused private (sic!) method but the compatibility checker was complaining about it
    {
        matchName="scala.reflect.io.ZipArchive.scala$reflect$io$ZipArchive$$walkIterator"
        problemName=MissingMethodProblem
    },
    // SI-8362: AbstractPromise extends AtomicReference
    // It's ok to change a package-protected class in an impl package,
    // even though it's not clear why it changed -- bug in generic signature generation?
    // -public class scala.concurrent.impl.Promise$DefaultPromise<T>                          extends scala.concurrent.impl.AbstractPromise implements scala.concurrent.impl.Promise<T>
    // +public class scala.concurrent.impl.Promise$DefaultPromise<T extends java.lang.Object> extends scala.concurrent.impl.AbstractPromise implements scala.concurrent.impl.Promise<T>
    {
        matchName="scala.concurrent.impl.Promise$DefaultPromise"
        problemName=MissingTypesProblem
    },
    // SI-9488: Due to SI-8362 above, toString was silently changed to the AtomicReference toString implementation,
    // This is fixed by SI-9488, and this should be safe since the class in question is stdlib internal.
    {
        matchName="scala.concurrent.impl.Promise.toString"
        problemName=MissingMethodProblem
    }
  ]
}
