filter {
  packages = [
    "scala.reflect.internal"
    # "scala.concurrent.impl"
    # "scala.reflect.runtime"
  ]
  problems=[
    {
      matchName="scala.collection.immutable.Vector.debug"
      problemName=DirectMissingMethodProblem
    },
    {
      matchName="scala.collection.immutable.VectorBuilder.debug"
      problemName=DirectMissingMethodProblem
    },
    {
      matchName="scala.collection.immutable.VectorPointer.debug"
      problemName=DirectMissingMethodProblem
    },
    {
      matchName="scala.collection.immutable.VectorIterator.debug"
      problemName=DirectMissingMethodProblem
    },
    {
      matchName="scala.collection.mutable.OpenHashMap.nextPositivePowerOfTwo"
      problemName=DirectMissingMethodProblem
    },
    {
      matchName="scala.collection.mutable.HashTable.nextPositivePowerOfTwo"
      problemName=DirectMissingMethodProblem
    },
    {
      matchName="scala.collection.mutable.HashTable.powerOfTwo"
      problemName=DirectMissingMethodProblem
    },
    {
      matchName="scala.reflect.runtime.JavaMirrors#JavaMirror.unpickleClass"
      problemName=IncompatibleMethTypeProblem
    },
    {
      matchName="scala.reflect.runtime.SymbolLoaders#TopClassCompleter.this"
      problemName=IncompatibleMethTypeProblem
    },
    {
      matchName="scala.sys.process.ProcessImpl#CompoundProcess.getExitValue"
      problemName=DirectMissingMethodProblem
    },
    {
      matchName="scala.reflect.runtime.SynchronizedOps.scala$reflect$runtime$SynchronizedOps$$super$newMappedBaseTypeSeq"
      problemName=ReversedMissingMethodProblem
    },
    {
      matchName="scala.reflect.runtime.SynchronizedOps#SynchronizedBaseTypeSeq.lateMap"
      problemName=DirectMissingMethodProblem
    },
    {
      matchName="scala.collection.immutable.HashMap.contains0"
      problemName=DirectMissingMethodProblem
    },
    {
      matchName="scala.collection.immutable.HashMap#HashTrieMap.contains0"
      problemName=DirectMissingMethodProblem
    },
    {
      matchName="scala.collection.immutable.HashMap#HashMap1.contains0"
      problemName=DirectMissingMethodProblem
    },
    {
      matchName="scala.collection.immutable.HashMap#HashMapCollision1.contains0"
      problemName=DirectMissingMethodProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps.unzip"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps.unzip3"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofFloat.unzip"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofFloat.unzip3"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofBoolean.unzip"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofBoolean.unzip3"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofRef.unzip"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofRef.unzip3"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofUnit.unzip"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofUnit.unzip3"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofDouble.unzip"
        problemName=IncompatibleMethTypeProblem
    },
    {
        matchName="scala.collection.mutable.ArrayOps#ofDouble.unzip3"
        problemName=IncompatibleMethTypeProblem
    },
    // see scala/bug#8200
    {
        matchName="scala.reflect.api.StandardLiftables#StandardLiftableInstances.liftTree"
        problemName=MissingMethodProblem
    },
    // see scala/bug#8331
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi#SyntacticTypeAppliedExtractor.unapply"
        problemName=IncompatibleResultTypeProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi#SyntacticTypeAppliedExtractor.unapply"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticSelectType"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticAppliedType"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticSelectTerm"
        problemName=MissingMethodProblem
    },
    // see scala/bug#8366
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticPartialFunction"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Mirror.symbolOf"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Mirror.typeOf"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Mirror.weakTypeOf"
        problemName=MissingMethodProblem
    },
    // see scala/bug#8388
    {
        matchName="scala.reflect.api.Internals$ReificationSupportApi$SyntacticIdentExtractor"
        problemName=MissingClassProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticIdent"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticSingletonType"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticTermIdent"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticTypeIdent"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticCompoundType"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticAnnotatedType"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticTypeProjection"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.api.Internals#ReificationSupportApi.SyntacticExistentialType"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.reflect.runtime.SynchronizedOps.newNestedScope"
        problemName=MissingMethodProblem
    },
    // https://github.com/scala/scala/pull/3848 -- scala/bug#8680
    {
        matchName="scala.collection.immutable.Stream.scala$collection$immutable$Stream$$loop$6"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.collection.immutable.Stream.scala$collection$immutable$Stream$$loop$5"
        problemName=MissingMethodProblem
    },
    {
        matchName="scala.collection.immutable.Stream.scala$collection$immutable$Stream$$loop$4"
        problemName=MissingMethodProblem
    },
    // scala/bug#8946
    {
        matchName="scala.reflect.runtime.ThreadLocalStorage#MyThreadLocalStorage.values"
        problemName=MissingMethodProblem
    },
    // the below method was the unused private (sic!) method but the compatibility checker was complaining about it
    {
        matchName="scala.reflect.io.ZipArchive.scala$reflect$io$ZipArchive$$walkIterator"
        problemName=MissingMethodProblem
    },
    // scala/bug#8362: AbstractPromise extends AtomicReference
    // It's ok to change a package-protected class in an impl package,
    // even though it's not clear why it changed -- bug in generic signature generation?
    // -public class scala.concurrent.impl.Promise$DefaultPromise<T>                          extends scala.concurrent.impl.AbstractPromise implements scala.concurrent.impl.Promise<T>
    // +public class scala.concurrent.impl.Promise$DefaultPromise<T extends java.lang.Object> extends scala.concurrent.impl.AbstractPromise implements scala.concurrent.impl.Promise<T>
    {
        matchName="scala.concurrent.impl.Promise$DefaultPromise"
        problemName=MissingTypesProblem
    },
    // scala/bug#9488: Due to scala/bug#8362 above, toString was silently changed to the AtomicReference toString implementation,
    // This is fixed by scala/bug#9488, and this should be safe since the class in question is stdlib internal.
    {
        matchName="scala.concurrent.impl.Promise.toString"
        problemName=MissingMethodProblem
    }
  ]
}
